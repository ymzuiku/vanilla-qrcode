(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 87);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(160);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(45),
  create: __webpack_require__(46),
  clone: __webpack_require__(92),
  fromValues: __webpack_require__(93),
  copy: __webpack_require__(94),
  set: __webpack_require__(95),
  equals: __webpack_require__(96),
  exactEquals: __webpack_require__(97),
  add: __webpack_require__(98),
  subtract: __webpack_require__(47),
  sub: __webpack_require__(99),
  multiply: __webpack_require__(48),
  mul: __webpack_require__(100),
  divide: __webpack_require__(49),
  div: __webpack_require__(101),
  inverse: __webpack_require__(102),
  min: __webpack_require__(103),
  max: __webpack_require__(104),
  rotate: __webpack_require__(105),
  floor: __webpack_require__(106),
  ceil: __webpack_require__(107),
  round: __webpack_require__(108),
  scale: __webpack_require__(109),
  scaleAndAdd: __webpack_require__(110),
  distance: __webpack_require__(50),
  dist: __webpack_require__(111),
  squaredDistance: __webpack_require__(51),
  sqrDist: __webpack_require__(112),
  length: __webpack_require__(52),
  len: __webpack_require__(113),
  squaredLength: __webpack_require__(53),
  sqrLen: __webpack_require__(114),
  negate: __webpack_require__(115),
  normalize: __webpack_require__(116),
  dot: __webpack_require__(117),
  cross: __webpack_require__(118),
  lerp: __webpack_require__(119),
  random: __webpack_require__(120),
  transformMat2: __webpack_require__(121),
  transformMat2d: __webpack_require__(122),
  transformMat3: __webpack_require__(123),
  transformMat4: __webpack_require__(124),
  forEach: __webpack_require__(125),
  limit: __webpack_require__(126)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "h", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ computeImageArea; });

// UNUSED EXPORTS: computeIntegralImage2, computeIntegralImage, thresholdImage, computeHistogram, sharpenLine, determineOtsuThreshold, computeBinaryImage, Tracer, DILATE, ERODE, dilate, erode, subtract, bitwiseOr, countNonZero, grayArrayFromImage, grayArrayFromContext, loadImageArray, _computeDivisors, _parseCSSDimensionValues, _dimensionsConverters

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(83);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__[/* hsv2rgb */ "g"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 12 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(161),
    createAssigner = __webpack_require__(216);
/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */


var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
module.exports = merge;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(226);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(227);

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(67);
/** Detect free variable `self`. */


var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    getRawTag = __webpack_require__(174),
    objectToString = __webpack_require__(175);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(85);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(86);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* calculatePatchSize */ "a"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if ( true && _config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if ( true && _config.debug.showPatches) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if ( true && _config.debug.boxFromPatches.showTransformed) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if ( true && _config.debug.boxFromPatches.showTransformedBox) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if ( true && _config.debug.boxFromPatches.showBB) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* otsuThreshold */ "i"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if ( true && _config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if ( true && _config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      } // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if ( true && _config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if ( true && _config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* hsv2rgb */ "g"])(hsv, rgb);
          _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* cluster */ "b"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* topGeneric */ "j"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* imageRef */ "h"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if ( true && _config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* imageRef */ "h"])(x, y));
  }
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if ( true && _config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* hsv2rgb */ "g"])(hsv, rgb);
        _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* halfSample */ "f"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* computeImageArea */ "d"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* calculatePatchSize */ "a"])(config.patchSize, size);

    if (true) {
      // console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(163),
    listCacheDelete = __webpack_require__(164),
    listCacheGet = __webpack_require__(165),
    listCacheHas = __webpack_require__(166),
    listCacheSet = __webpack_require__(167);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(25);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Symbol = root.Symbol;
module.exports = Symbol;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(35);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(188);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(203),
    isObjectLike = __webpack_require__(18);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(13),
    isKey = __webpack_require__(231),
    stringToPath = __webpack_require__(232),
    toString = __webpack_require__(235);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(223);

var iterableToArray = __webpack_require__(224);

var unsupportedIterableToArray = __webpack_require__(43);

var nonIterableSpread = __webpack_require__(225);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(247),
  transpose: __webpack_require__(248),
  multiply: __webpack_require__(249),
  identity: __webpack_require__(250),
  adjoint: __webpack_require__(251),
  rotate: __webpack_require__(252),
  invert: __webpack_require__(253),
  create: __webpack_require__(254),
  scale: __webpack_require__(255),
  copy: __webpack_require__(256),
  frob: __webpack_require__(257),
  ldu: __webpack_require__(258)
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(173),
    getValue = __webpack_require__(179);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObject = __webpack_require__(12);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(71);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(36),
    isLength = __webpack_require__(40);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(41);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(44);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(35),
    root = __webpack_require__(17);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))

/***/ }),
/* 68 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(180),
    mapCacheDelete = __webpack_require__(187),
    mapCacheGet = __webpack_require__(189),
    mapCacheHas = __webpack_require__(190),
    mapCacheSet = __webpack_require__(191);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(37),
    eq = __webpack_require__(25);
/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(35);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(202);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 73 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17),
    stubFalse = __webpack_require__(205);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)(module)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(207),
    baseUnary = __webpack_require__(208),
    nodeUtil = __webpack_require__(209);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(37),
    eq = __webpack_require__(25);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(212),
    baseKeysIn = __webpack_require__(214),
    isArrayLike = __webpack_require__(39);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(218);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(219),
    shortOut = __webpack_require__(221);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(89);

var iterableToArrayLimit = __webpack_require__(90);

var unsupportedIterableToArray = __webpack_require__(43);

var nonIterableRest = __webpack_require__(91);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(54),
  create: __webpack_require__(55),
  clone: __webpack_require__(127),
  angle: __webpack_require__(128),
  fromValues: __webpack_require__(56),
  copy: __webpack_require__(129),
  set: __webpack_require__(130),
  equals: __webpack_require__(131),
  exactEquals: __webpack_require__(132),
  add: __webpack_require__(133),
  subtract: __webpack_require__(59),
  sub: __webpack_require__(134),
  multiply: __webpack_require__(60),
  mul: __webpack_require__(135),
  divide: __webpack_require__(61),
  div: __webpack_require__(136),
  min: __webpack_require__(137),
  max: __webpack_require__(138),
  floor: __webpack_require__(139),
  ceil: __webpack_require__(140),
  round: __webpack_require__(141),
  scale: __webpack_require__(142),
  scaleAndAdd: __webpack_require__(143),
  distance: __webpack_require__(62),
  dist: __webpack_require__(144),
  squaredDistance: __webpack_require__(63),
  sqrDist: __webpack_require__(145),
  length: __webpack_require__(64),
  len: __webpack_require__(146),
  squaredLength: __webpack_require__(65),
  sqrLen: __webpack_require__(147),
  negate: __webpack_require__(148),
  inverse: __webpack_require__(149),
  normalize: __webpack_require__(57),
  dot: __webpack_require__(58),
  cross: __webpack_require__(150),
  lerp: __webpack_require__(151),
  random: __webpack_require__(152),
  transformMat4: __webpack_require__(153),
  transformMat3: __webpack_require__(154),
  transformQuat: __webpack_require__(155),
  rotateX: __webpack_require__(156),
  rotateY: __webpack_require__(157),
  rotateZ: __webpack_require__(158),
  forEach: __webpack_require__(159)
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(228),
    flatRest = __webpack_require__(242);
/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */


var pick = flatRest(function (object, paths) {
  return object == null ? {} : basePick(object, paths);
});
module.exports = pick;

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(259);


/***/ }),
/* 88 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 89 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 90 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 91 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(45);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(47);

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(48);

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(49);

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 108 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(50);

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(51);

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(52);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53);

/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(46)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(56);

var normalize = __webpack_require__(57);

var dot = __webpack_require__(58);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(54);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(59);

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(60);

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(61);

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 143 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(62);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(63);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(64);

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(65);

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(55)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(162),
    assignMergeValue = __webpack_require__(70),
    baseFor = __webpack_require__(192),
    baseMergeDeep = __webpack_require__(194),
    isObject = __webpack_require__(12),
    keysIn = __webpack_require__(78),
    safeGet = __webpack_require__(76);
/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23),
    stackClear = __webpack_require__(168),
    stackDelete = __webpack_require__(169),
    stackGet = __webpack_require__(170),
    stackHas = __webpack_require__(171),
    stackSet = __webpack_require__(172);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 163 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(24);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 170 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 171 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(23),
    Map = __webpack_require__(66),
    MapCache = __webpack_require__(69);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(36),
    isMasked = __webpack_require__(176),
    isObject = __webpack_require__(12),
    toSource = __webpack_require__(178);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 175 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(177);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 178 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 179 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(181),
    ListCache = __webpack_require__(23),
    Map = __webpack_require__(66);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(182),
    hashDelete = __webpack_require__(183),
    hashGet = __webpack_require__(184),
    hashHas = __webpack_require__(185),
    hashSet = __webpack_require__(186);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 183 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(27);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 188 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(28);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(193);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 193 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(70),
    cloneBuffer = __webpack_require__(195),
    cloneTypedArray = __webpack_require__(196),
    copyArray = __webpack_require__(199),
    initCloneObject = __webpack_require__(200),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(13),
    isArrayLikeObject = __webpack_require__(204),
    isBuffer = __webpack_require__(74),
    isFunction = __webpack_require__(36),
    isObject = __webpack_require__(12),
    isPlainObject = __webpack_require__(206),
    isTypedArray = __webpack_require__(75),
    safeGet = __webpack_require__(76),
    toPlainObject = __webpack_require__(210);
/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */


function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)(module)))

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(197);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(198);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(17);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 199 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(201),
    getPrototype = __webpack_require__(72),
    isPrototype = __webpack_require__(73);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(12);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 202 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(39),
    isObjectLike = __webpack_require__(18);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 205 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    getPrototype = __webpack_require__(72),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(21),
    isLength = __webpack_require__(40),
    isObjectLike = __webpack_require__(18);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 208 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(67);
/** Detect free variable `exports`. */


var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)(module)))

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(211),
    keysIn = __webpack_require__(78);
/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */


function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(77),
    baseAssignValue = __webpack_require__(37);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(213),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(13),
    isBuffer = __webpack_require__(74),
    isIndex = __webpack_require__(30),
    isTypedArray = __webpack_require__(75);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 213 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(12),
    isPrototype = __webpack_require__(73),
    nativeKeysIn = __webpack_require__(215);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 215 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(217),
    isIterateeCall = __webpack_require__(222);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(79),
    overRest = __webpack_require__(80),
    setToString = __webpack_require__(81);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 218 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(220),
    defineProperty = __webpack_require__(71),
    identity = __webpack_require__(79);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 220 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 221 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(25),
    isArrayLike = __webpack_require__(39),
    isIndex = __webpack_require__(30),
    isObject = __webpack_require__(12);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(44);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 224 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 225 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(229),
    hasIn = __webpack_require__(239);
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */


function basePick(object, paths) {
  return basePickBy(object, paths, function (value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(230),
    baseSet = __webpack_require__(238),
    castPath = __webpack_require__(31);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(31),
    toKey = __webpack_require__(42);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(13),
    isSymbol = __webpack_require__(41);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(233);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(234);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(69);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(236);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    arrayMap = __webpack_require__(237),
    isArray = __webpack_require__(13),
    isSymbol = __webpack_require__(41);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 237 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(77),
    castPath = __webpack_require__(31),
    isIndex = __webpack_require__(30),
    isObject = __webpack_require__(12),
    toKey = __webpack_require__(42);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(240),
    hasPath = __webpack_require__(241);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 240 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(31),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(13),
    isIndex = __webpack_require__(30),
    isLength = __webpack_require__(40),
    toKey = __webpack_require__(42);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(243),
    overRest = __webpack_require__(80),
    setToString = __webpack_require__(81);
/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */


function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(244);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(245),
    isFlattenable = __webpack_require__(246);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 245 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(26),
    isArguments = __webpack_require__(29),
    isArray = __webpack_require__(13);
/** Built-in value references. */


var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 247 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 248 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 249 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 252 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 254 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 257 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 258 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(88);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(11);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  createClass_default()(BarcodeReader, null, [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    value: function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/lodash/merge.js
var merge = __webpack_require__(14);
var merge_default = /*#__PURE__*/__webpack_require__.n(merge);

// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, merge_default()({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(32);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(15);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, merge_default()({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_decodeCode32",
    value: function _decodeCode32(code) {
      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
        return null;
      }

      var res = 0;

      for (var i = 0; i < code.length; i++) {
        res = res * 32 + code32set.indexOf(code[i]);
      }

      var code32 = '' + res;

      if (code32.length < 9) {
        code32 = ('000000000' + code32).slice(-9);
      }

      return 'A' + code32;
    } // TODO (this was todo in original repo, no text was there. sorry.)

  }, {
    key: "_checkChecksum",
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!this._checkChecksum(code)) {
        return null;
      }

      var code32 = this._decodeCode32(code);

      if (!code32) {
        return null;
      }

      result.code = code32;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');

        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';

          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }

        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');

        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';

          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }

        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');

        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (true) {
          // console.log('Before registering reader: ', reader);
        }

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (true) {
        // console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
        //   return JSON.stringify({
        //     format: reader.FORMAT,
        //     config: reader.config
        //   });
        // }).join(', ')));
      }
    }

    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];

        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if ( true && config.debug.showFrequency) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, _canvas.ctx.overlay, {
          color: 'red',
          lineWidth: 3
        });
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }

      bresenham.toBinaryLine(barcodeLine);

      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug["a" /* default */].drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(16);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(33);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__(84);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
var ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    var error = new Error("enumerateDevices is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    var error = new Error("getUserMedia is not defined. ".concat(ERROR_DESC));
    error.code = -1;
    return Promise.reject(error);
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    // console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    // console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return pickConstraints(videoConstraints);

            case 2:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
    var tracks = streamRef && streamRef.getVideoTracks();

    if (tracks && tracks.length) {
      tracks[0].stop();
    }

    streamRef = null;
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  true ? config_dev : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(22);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (true) {
    // console.log("image wrapper size ".concat(inputImageWrapper.size));
  }

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?
// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }

  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);

  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }

  return buffer;
}

function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();

    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';

    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };

    http.onerror = reject;
    http.send();
  });
}

function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];

    if (exifTag) {
      result[exifTag] = selectedTag;
    }

    return result;
  }, {});
  var offset = 2;
  var marker;

  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }

  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }

    marker = dataView.getUint8(offset + 1);

    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }

    offset += 2 + dataView.getUint16(offset + 2);
  }

  return false;
}

function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }

  var tiffOffset = start + 6;
  var bigEnd;

  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }

  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }

  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

  if (firstIFDOffset < 0x00000008) {
    return false;
  }

  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};

  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];

    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }

  return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);

  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }

  }

  return null;
}

function getStringFromBuffer(buffer, start, length) {
  var outstr = '';

  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }

  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js

var ImageLoader = {};

ImageLoader.load = function (directory, callback, offset, size, sequence) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;

  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = "".concat(directory, "image-").concat("00".concat(num).slice(-3), ".jpg");
    }
  }

  htmlImagesArray.notLoaded = [];

  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };

  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;

    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);

        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));

          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }

        break;
      }
    }

    if (notloadedImgs.length === 0) {
      if (true) {
        // console.log('Images loaded');
      }

      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };

  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};

function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
}

/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};

    var _calculatedWidth;

    var _calculatedHeight;

    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function initSize() {
      var _config2, _config3;

      var width = video.videoWidth;
      var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

      _calculatedWidth = ((_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

      _calculatedHeight = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }

    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;

        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];

          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        var handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
          initSize();
        }

        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    if (video) {
      video.setAttribute('autoplay', 'true');
    }

    var that = inputStreamFactory.createVideoStream(video);

    that.ended = function ended() {
      return false;
    };

    return that;
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function loadImages() {
      var _config7;

      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;

        imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;

            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        } // eslint-disable-next-line no-nested-ternary


        calculatedWidth = ((_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config6 = _config) === null || _config6 === void 0 ? void 0 : _config6.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);
    }

    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    } // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

          size = stream.length;
        }

        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;

        if (!loaded) {
          return null;
        }

        if (!paused) {
          var _imgArray;

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];

          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
var cv_utils = __webpack_require__(8);

// CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
// NOTE FOR ANYONE IN HERE IN THE FUTURE:
// webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.

var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
  if (canvas.width !== targetSize.x) {
    if (true) {
      // console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.width = targetSize.x;
  }

  if (canvas.height !== targetSize.y) {
    if (true) {
      // console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.height = targetSize.y;
  }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _streamConfig = inputStream.getConfig();

  var _videoSize = Object(cv_utils["h" /* imageRef */])(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = Object(cv_utils["h" /* imageRef */])(inputStream.getWidth(), inputStream.getHeight());

  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;

  var _canvas;

  var _ctx = null;
  var _data = null;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  _ctx = _canvas.getContext('2d');
  _data = new Uint8Array(_size.x * _size.y);

  if (true) {
    // console.log('FrameGrabber', JSON.stringify({
    //   size: _size,
    //   topRight: topRight,
    //   videoSize: _videoSize,
    //   canvasSize: _canvasSize
    // }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    var ctxData;

    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize);

      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;

        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;

            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

        _ctx.rotate(drawAngle);

        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);

        _ctx.rotate(-drawAngle);

        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }

      ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

      if (doHalfSample) {
        Object(cv_utils["e" /* grayAndHalfSampleFromCanvasData */])(ctxData, _size, _data);
      } else {
        Object(cv_utils["c" /* computeGray */])(ctxData, _data, _streamConfig);
      }

      return true;
    }

    return false;
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

/* harmony default export */ var frame_grabber_browser = (FrameGrabber);
// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (true) {
        console.log('Worker initialized');
      }

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts


















var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = frame_grabber_browser.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream_browser),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          if (timestamp >= next) {
            next += delay;

            _this4.update();
          }

          window.requestAnimationFrame(newFrame);
        }
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$context$config7;

      this.context.stopped = true;
      adjustWorkerPool(0);

      if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
        camera_access.release();
        this.context.inputStream.clearEventHandlers();
      }
    }
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js

 // eslint-disable-line no-unused-vars











var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    instance.start();
  },
  stop: function stop() {
    instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return _context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = merge_default()({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Vwc2lsb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZG90LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9yYXN0ZXJpemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3NrZWxldG9uaXplci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jbG9uZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9hZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3ViLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvaW52ZXJzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9taW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWF4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mbG9vci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jZWlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JvdW5kLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3FyTGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZG90LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Nyb3NzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcmFuZG9tLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0MmQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGltaXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvYW5nbGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY29weS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2V4YWN0RXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpdi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9taW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWF4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Zsb29yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NlaWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2NhbGVBbmRBZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXJEaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXJMZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbmVnYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVycC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybVF1YXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVZLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVouanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZGV0ZXJtaW5hbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvdHJhbnNwb3NlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2lkZW50aXR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2Fkam9pbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvcm90YXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2ludmVydC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY29weS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9mcm9iLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2xkdS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMTI4X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGFiYXJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvdXBjX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl84X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl8yX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl81X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2kyb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzMyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9iYXJjb2RlX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9ldmVudHMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2NhbWVyYV9hY2Nlc3MudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLmRldi50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnByb2QudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL1F1YWdnYUNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0QnVmZmVycy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdENhbnZhcy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZXhpZl9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2ltYWdlX2xvYWRlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9icm93c2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xd29ya2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2Evc2V0dXBJbnB1dFN0cmVhbS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F1YWdnYS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhLmpzIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIl90eXBlb2YiLCJyZXF1aXJlIiwiYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjYWxsIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJFUFNJTE9OIiwiY2xvbmUiLCJmcm9tVmFsdWVzIiwiY29weSIsInNldCIsImVxdWFscyIsImV4YWN0RXF1YWxzIiwiYWRkIiwic3VidHJhY3QiLCJzdWIiLCJtdWx0aXBseSIsIm11bCIsImRpdmlkZSIsImRpdiIsImludmVyc2UiLCJtaW4iLCJtYXgiLCJyb3RhdGUiLCJmbG9vciIsImNlaWwiLCJyb3VuZCIsInNjYWxlIiwic2NhbGVBbmRBZGQiLCJkaXN0YW5jZSIsImRpc3QiLCJzcXVhcmVkRGlzdGFuY2UiLCJzcXJEaXN0IiwibGVuIiwic3F1YXJlZExlbmd0aCIsInNxckxlbiIsIm5lZ2F0ZSIsIm5vcm1hbGl6ZSIsImRvdCIsImNyb3NzIiwibGVycCIsInJhbmRvbSIsInRyYW5zZm9ybU1hdDIiLCJ0cmFuc2Zvcm1NYXQyZCIsInRyYW5zZm9ybU1hdDMiLCJ0cmFuc2Zvcm1NYXQ0IiwiZm9yRWFjaCIsImxpbWl0IiwidmVjMiIsInBvaW50IiwidGhyZXNob2xkIiwicG9pbnRzIiwiY2VudGVyIiwicmFkIiwidmVjIiwicG9pbnRNYXAiLCJwb2ludFRvQWRkIiwiaWQiLCJwdXNoIiwidXBkYXRlQ2VudGVyIiwic3VtIiwiTWF0aCIsImNvcyIsInNpbiIsImluaXQiLCJmaXRzIiwib3RoZXJQb2ludCIsInNpbWlsYXJpdHkiLCJhYnMiLCJnZXRQb2ludHMiLCJnZXRDZW50ZXIiLCJjcmVhdGVQb2ludCIsIm5ld1BvaW50IiwicHJvcGVydHkiLCJ2MmNsb25lIiwidmVjMyIsInYzY2xvbmUiLCJpbWFnZVJlZiIsIngiLCJ5IiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsImNvbXB1dGVJbnRlZ3JhbEltYWdlMiIsImltYWdlV3JhcHBlciIsImludGVncmFsV3JhcHBlciIsImltYWdlRGF0YSIsImRhdGEiLCJ3aWR0aCIsInNpemUiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInYiLCJ1IiwidGhyZXNob2xkSW1hZ2UiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImNvbXB1dGVIaXN0b2dyYW0iLCJiaXRzUGVyUGl4ZWwiLCJiaXRTaGlmdCIsImJ1Y2tldENudCIsImhpc3QiLCJJbnQzMkFycmF5Iiwic2hhcnBlbkxpbmUiLCJsaW5lIiwibGVmdCIsInJpZ2h0IiwiZGV0ZXJtaW5lT3RzdVRocmVzaG9sZCIsInB4IiwiZW5kIiwibXgiLCJkZXRlcm1pbmVUaHJlc2hvbGQiLCJ2ZXQiLCJwMSIsInAyIiwicDEyIiwibTEiLCJtMiIsIm0xMiIsImsiLCJBcnJheUhlbHBlciIsIm1heEluZGV4Iiwib3RzdVRocmVzaG9sZCIsImNvbXB1dGVCaW5hcnlJbWFnZSIsImtlcm5lbCIsIkEiLCJCIiwiQyIsIkQiLCJhdmciLCJjbHVzdGVyIiwidGhpc0NsdXN0ZXIiLCJjbHVzdGVycyIsImFkZFRvQ2x1c3RlciIsImZvdW5kIiwiQ2x1c3RlcjIiLCJUcmFjZXIiLCJ0cmFjZSIsIml0ZXJhdGlvbiIsIm1heEl0ZXJhdGlvbnMiLCJ0b3AiLCJyZXN1bHQiLCJjZW50ZXJQb3MiLCJjdXJyZW50UG9zIiwiaWR4IiwiZm9yd2FyZCIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicG9zIiwicHJlZGljdGVkIiwiZnJvbSIsIkRJTEFURSIsIkVST0RFIiwiZGlsYXRlIiwiaW5JbWFnZVdyYXBwZXIiLCJvdXRJbWFnZVdyYXBwZXIiLCJpbkltYWdlRGF0YSIsIm91dEltYWdlRGF0YSIsInlTdGFydDEiLCJ5U3RhcnQyIiwieFN0YXJ0MSIsInhTdGFydDIiLCJlcm9kZSIsImFJbWFnZVdyYXBwZXIiLCJiSW1hZ2VXcmFwcGVyIiwicmVzdWx0SW1hZ2VXcmFwcGVyIiwiYUltYWdlRGF0YSIsImJJbWFnZURhdGEiLCJjSW1hZ2VEYXRhIiwiYml0d2lzZU9yIiwiY291bnROb25aZXJvIiwidG9wR2VuZXJpYyIsImxpc3QiLCJzY29yZUZ1bmMiLCJtaW5JZHgiLCJxdWV1ZSIsInNjb3JlIiwiaGl0IiwiaXRlbSIsImFwcGx5IiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiZ3JheUFycmF5RnJvbUltYWdlIiwiaHRtbEltYWdlIiwib2Zmc2V0WCIsImN0eCIsImFycmF5IiwiZHJhd0ltYWdlIiwiY3R4RGF0YSIsImdldEltYWdlRGF0YSIsImNvbXB1dGVHcmF5IiwiZ3JheUFycmF5RnJvbUNvbnRleHQiLCJvZmZzZXQiLCJncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhIiwiY2FudmFzRGF0YSIsIm91dEFycmF5IiwidG9wUm93SWR4IiwiYm90dG9tUm93SWR4IiwiZW5kSWR4Iiwib3V0V2lkdGgiLCJvdXRJbWdJZHgiLCJpbldpZHRoIiwiY29uZmlnIiwibCIsInNpbmdsZUNoYW5uZWwiLCJsb2FkSW1hZ2VBcnJheSIsInNyYyIsImNhbGxiYWNrIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJnZXRDb250ZXh0IiwiVWludDhBcnJheSIsImhhbGZTYW1wbGUiLCJpbkltZ1dyYXBwZXIiLCJvdXRJbWdXcmFwcGVyIiwiaW5JbWciLCJvdXRJbWciLCJoc3YycmdiIiwiaHN2IiwicmdiIiwiaCIsInMiLCJjIiwibSIsInIiLCJnIiwiYiIsIl9jb21wdXRlRGl2aXNvcnMiLCJuIiwibGFyZ2VEaXZpc29ycyIsImRpdmlzb3JzIiwic3FydCIsInVuc2hpZnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiaiIsImNhbGN1bGF0ZVBhdGNoU2l6ZSIsInBhdGNoU2l6ZSIsImltZ1NpemUiLCJkaXZpc29yc1giLCJkaXZpc29yc1kiLCJ3aWRlU2lkZSIsImNvbW1vbiIsIm5yT2ZQYXRjaGVzTGlzdCIsIm5yT2ZQYXRjaGVzTWFwIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsIm5yT2ZQYXRjaGVzSWR4IiwibnJPZlBhdGNoZXMiLCJkZXNpcmVkUGF0Y2hTaXplIiwib3B0aW1hbFBhdGNoU2l6ZSIsImZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyIsIl9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyIsImRpbWVuc2lvbiIsInBhcnNlRmxvYXQiLCJ1bml0IiwiaW5kZXhPZiIsIl9kaW1lbnNpb25zQ29udmVydGVycyIsImNvbnRleHQiLCJib3R0b20iLCJjb21wdXRlSW1hZ2VBcmVhIiwiaW5wdXRXaWR0aCIsImlucHV0SGVpZ2h0IiwiYXJlYSIsInBhcnNlZEFyZWEiLCJrZXlzIiwicmVkdWNlIiwicGFyc2VkIiwiY2FsY3VsYXRlZCIsInN4Iiwic3kiLCJzdyIsInNoIiwiZHJhd1JlY3QiLCJzdHlsZSIsInN0cm9rZVN0eWxlIiwiY29sb3IiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJzdHJva2VSZWN0IiwiZHJhd1BhdGgiLCJwYXRoIiwiZGVmIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwiY2FudmFzRGF0YVBvcyIsImltYWdlRGF0YVBvcyIsInB1dEltYWdlRGF0YSIsImFyciIsInZhbCIsInNodWZmbGUiLCJ0b1BvaW50TGlzdCIsInJvd3MiLCJwIiwicm93Iiwiam9pbiIsInByZXYiLCJuZXh0IiwiYXNzZXJ0TnVtYmVyUG9zaXRpdmUiLCJFcnJvciIsIkltYWdlV3JhcHBlciIsIkFycmF5VHlwZSIsImluaXRpYWxpemUiLCJpbWdSZWYiLCJib3JkZXIiLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJpc05hTiIsImF0YW4iLCJyZXQiLCJVaW50OENsYW1wZWRBcnJheSIsInBpeGVsIiwiY3VycmVudCIsImdldCIsImZyYW1lIiwiZ2V0QXNSR0JBIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlIiwib2JqZWN0Iiwic291cmNlIiwic3JjSW5kZXgiLCJzdXBlclByb3BCYXNlIiwiX2dldCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJhc2UiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiaXNPYmplY3RMaWtlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiZWRnZWxhYmVsIiwiY3kiLCJkaXIiLCJjeCIsInZlcnRleDJEIiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiYmFzZUdldFRhZyIsIl9jb25maWciLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiX2NhbnZhc0NvbnRhaW5lciIsImJpbmFyeSIsImRvbSIsIl9udW1QYXRjaGVzIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX3NrZWxldG9uaXplciIsImluaXRCdWZmZXJzIiwic2tlbGV0b25JbWFnZURhdGEiLCJBcnJheUJ1ZmZlciIsInNrZWxldG9uaXplciIsIndpbmRvdyIsImdsb2JhbCIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwic2hvd0ZvdW5kUGF0Y2hlcyIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJhIiwiZmlsdGVyIiwiZWwiLCJmaW5kQm94ZXMiLCJib3hlcyIsInNob3dSZW1haW5pbmdQYXRjaExhYmVscyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsImUiLCJzdWJJbWFnZUFzQ29weSIsInNob3dTa2VsZXRvbiIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwiaW5kZXgiLCJyYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eSIsImN1cnJJZHgiLCJub3RZZXRQcm9jZXNzZWQiLCJjdXJyZW50SWR4IiwiY3VycmVudFBhdGNoIiwic2hvd1BhdGNoTGFiZWxzIiwiaW5wdXRJbWFnZVdyYXBwZXIiLCJsb2NhdGUiLCJjaGVja0ltYWdlQ29uc3RyYWludHMiLCJpbnB1dFN0cmVhbSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwidGhpc0hhbGZTYW1wbGUiLCJnZXRDb25maWciLCJzZXRUb3BSaWdodCIsInNldENhbnZhc1NpemUiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldFdpZHRoIiwic2V0SGVpZ2h0IiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwib3RoZXIiLCJnZXROYXRpdmUiLCJuYXRpdmVDcmVhdGUiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJiYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImFyZ3VtZW50cyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsImlzSW5kZXgiLCJ0ZXN0IiwiaXNLZXkiLCJzdHJpbmdUb1BhdGgiLCJ0b1N0cmluZyIsImNhc3RQYXRoIiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiYXJnIiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsImFyZ3MiLCJlcnIiLCJkZXRlcm1pbmFudCIsInRyYW5zcG9zZSIsImlkZW50aXR5IiwiYWRqb2ludCIsImludmVydCIsImZyb2IiLCJsZHUiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsInRhZyIsImJhc2VBc3NpZ25WYWx1ZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInRvS2V5IiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsInNsaWNlIiwibmFtZSIsIl9hcnJheUxpa2VUb0FycmF5Iiwib3V0IiwiRmxvYXQzMkFycmF5IiwieiIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImZ1bmMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsInNhZmVHZXQiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJrZXlzSW4iLCJuYXRpdmVNYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwib3RoZXJBcmdzIiwiYmFzZVNldFRvU3RyaW5nIiwic2hvcnRPdXQiLCJzZXRUb1N0cmluZyIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJub25JdGVyYWJsZVJlc3QiLCJfc2xpY2VkVG9BcnJheSIsImFuZ2xlIiwidHJhbnNmb3JtUXVhdCIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsImJhc2VQaWNrIiwiZmxhdFJlc3QiLCJwaWNrIiwiY3JlYXRlQ29udG91cjJEIiwiZmlyc3RWZXJ0ZXgiLCJpbnNpZGVDb250b3VycyIsIm5leHRwZWVyIiwicHJldnBlZXIiLCJDT05UT1VSX0RJUiIsIkNXX0RJUiIsIkNDV19ESVIiLCJVTktOT1dOX0RJUiIsIkRJUiIsIk9VVFNJREVfRURHRSIsIklOU0lERV9FREdFIiwidHJhY2VyIiwiZGVwdGhsYWJlbCIsImJjIiwibGMiLCJsYWJlbGluZGV4IiwiY29sb3JNYXAiLCJ2ZXJ0ZXgiLCJjYyIsInNjIiwiY29ubmVjdGVkQ291bnQiLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImFoIiwiYWwiLCJiaCIsImJsIiwiYXNzaWduIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIl9ub25JdGVyYWJsZVJlc3QiLCJhMCIsImExIiwiYjAiLCJiMSIsInQiLCJheCIsImF5Iiwic3RyaWRlIiwibVNxIiwidGVtcEEiLCJ0ZW1wQiIsImNvc2luZSIsImFjb3MiLCJhMiIsImIyIiwiYXoiLCJieCIsImJ5IiwiYnoiLCJ6U2NhbGUiLCJ3IiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInB5IiwicHoiLCJfc2V0UHJvdG90eXBlT2YiLCJTdGFjayIsImJhc2VGb3IiLCJiYXNlTWVyZ2VEZWVwIiwiY3VzdG9taXplciIsInN0YWNrIiwic3JjVmFsdWUiLCJuZXdWYWx1ZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJsYXN0SW5kZXgiLCJwb3AiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInJlcGxhY2UiLCJwYXR0ZXJuIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJIYXNoIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhBU0hfVU5ERUZJTkVEIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsIml0ZXJhdGVlIiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsImNsb25lQnVmZmVyIiwiY2xvbmVUeXBlZEFycmF5IiwiY29weUFycmF5IiwiaW5pdENsb25lT2JqZWN0IiwiaXNBcnJheUxpa2VPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsIm1lcmdlRnVuYyIsInN0YWNrZWQiLCJpc0NvbW1vbiIsImlzQXJyIiwiaXNCdWZmIiwiaXNUeXBlZCIsImFsbG9jVW5zYWZlIiwiaXNEZWVwIiwiY2xvbmVBcnJheUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJieXRlT2Zmc2V0IiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiYmFzZUNyZWF0ZSIsIm9iamVjdENyZWF0ZSIsImFyZ3NUYWciLCJvYmplY3RUYWciLCJvYmplY3RDdG9yU3RyaW5nIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsInR5cGVzIiwiYmluZGluZyIsImNvcHlPYmplY3QiLCJpc05ldyIsImJhc2VUaW1lcyIsImluaGVyaXRlZCIsImlzQXJnIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwidGhpc0FyZyIsImNvbnN0YW50Iiwic3RyaW5nIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc3VwZXJQcm9wQmFzZSIsInJ1bnRpbWUiLCJPcCIsImhhc093biIsIiRTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJ0cnlMb2NzTGlzdCIsInByb3RvR2VuZXJhdG9yIiwiR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiQ29udGV4dCIsIl9pbnZva2UiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0IiwiR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCIsIkdlblN0YXRlRXhlY3V0aW5nIiwiR2VuU3RhdGVDb21wbGV0ZWQiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsInZhbHVlcyIsIkdwIiwiZGlzcGxheU5hbWUiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJtZXRob2QiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiZ2VuRnVuIiwiY3RvciIsIm1hcmsiLCJhd3JhcCIsIl9fYXdhaXQiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJyZWNvcmQiLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJlbnF1ZXVlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJhc3luYyIsInN0YXRlIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsImNoYXJBdCIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwiYmFzZVBpY2tCeSIsImhhc0luIiwiYmFzZUdldCIsImJhc2VTZXQiLCJwcmVkaWNhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsImNhY2hlIiwiRlVOQ19FUlJPUl9URVhUIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwiYmFzZVRvU3RyaW5nIiwiYXJyYXlNYXAiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwibmVzdGVkIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJmbGF0dGVuIiwiYmFzZUZsYXR0ZW4iLCJhcnJheVB1c2giLCJpc0ZsYXR0ZW5hYmxlIiwiZGVwdGgiLCJpc1N0cmljdCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsInBvdyIsIkwiLCJVIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJ4MSIsInkxIiwic3RlZXAiLCJyZWFkIiwiZGVsdGFYIiwiZGVsdGFZIiwieVN0ZXAiLCJ0b0JpbmFyeUxpbmUiLCJzbG9wZSIsInNsb3BlMiIsImV4dHJlbWEiLCJjdXJyZW50RGlyIiwiclRocmVzaG9sZCIsInByaW50RnJlcXVlbmN5IiwicHJpbnRQYXR0ZXJuIiwiZmlsbENvbG9yIiwiZmlsbFJlY3QiLCJCYXJjb2RlRGlyZWN0aW9uIiwiQmFyY29kZVJlYWRlciIsIlN0YXJ0Tm90Rm91bmRFeGNlcHRpb24iLCJDb2RlTm90Rm91bmRFeGNlcHRpb24iLCJQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb24iLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJjb3VudGVyIiwiY29kZSIsIm1heFNpbmdsZUVycm9yIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJfZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiQ29kZTEyOFJlYWRlciIsImJhciIsInNwYWNlIiwiYmVzdE1hdGNoIiwiX2NvcnJlY3QiLCJDT0RFX1BBVFRFUk4iLCJfbWF0Y2hQYXR0ZXJuIiwiQVZHX0NPREVfRVJST1IiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJfbmV4dFNldCIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsInN0YXJ0SW5mbyIsIl9maW5kU3RhcnQiLCJkZWNvZGVkQ29kZXMiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIl9kZWNvZGVDb2RlIiwiU1RPUF9DT0RFIiwiZnJvbUNoYXJDb2RlIiwiQ09ERV9TSElGVCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX21hdGNoUmFuZ2UiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJDT0RFX0dfU1RBUlQiLCJTVEFSVF9QQVRURVJOIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwidHJ5SGFyZGVyIiwiZmlsbCIsImVwc2lsb24iLCJjb2RlcmFuZ2UiLCJfZmluZFBhdHRlcm4iLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwiX2NhbGN1bGF0ZUZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiU1RPUF9QQVRURVJOIiwicmVzdWx0SW5mbyIsIl9kZWNvZGVQYXlsb2FkIiwiX2ZpbmRFbmQiLCJfY2hlY2tzdW0iLCJzdXBwbGVtZW50IiwiX2RlY29kZUV4dGVuc2lvbnMiLCJsYXN0Q29kZSIsIkFMUEhBQkVUSF9TVFJJTkciLCJBTFBIQUJFVCIsIlVpbnQxNkFycmF5IiwiY2hhciIsIkNIQVJBQ1RFUl9FTkNPRElOR1MiLCJBU1RFUklTSyIsIkNvZGUzOVJlYWRlciIsInBhdHRlcm5TdGFydCIsIl90b1BhdHRlcm4iLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwibWF4TmFycm93V2lkdGgiLCJudW1XaWRlQmFycyIsIndpZGVCYXJXaWR0aCIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJsYXN0U3RhcnQiLCJuZXh0U3RhcnQiLCJwYXR0ZXJuU2l6ZSIsImRlY29kZWRDaGFyIiwiX3RvQ291bnRlcnMiLCJfcGF0dGVyblRvQ2hhciIsInBhdHRlcm5zIiwiSU9RIiwiQVowOSIsIkNvZGUzOVZJTlJlYWRlciIsIl9jaGVja0NoZWNrc3VtIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJOZXdDb2RhYmFyUmVhZGVyIiwiX2NvdW50ZXJzIiwiYmFyVGhyZXNob2xkIiwiX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZCIsInNwYWNlVGhyZXNob2xkIiwiYml0bWFzayIsIl9pc1N0YXJ0RW5kIiwiX3N1bUNvdW50ZXJzIiwic3RhcnRDb3VudGVyIiwiZW5kQ291bnRlciIsIl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoIiwiY2hhckNvZGUiLCJjYXRlZ29yaXphdGlvbiIsIm5hcnJvdyIsImNvdW50cyIsIndpZGUiLCJfY2hhclRvUGF0dGVybiIsImtpbmQiLCJjYXQiLCJuZXdraW5kIiwidGhyZXNob2xkcyIsIl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuIiwiX2ZpbGxDb3VudGVycyIsIl92ZXJpZnlXaGl0ZXNwYWNlIiwiX3ZhbGlkYXRlUmVzdWx0IiwiVVBDUmVhZGVyIiwic3Vic3RyaW5nIiwiRUFOOFJlYWRlciIsIkVBTjJSZWFkZXIiLCJwYXJzZUludCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwidXBjYSIsImxhc3REaWdpdCIsIl9jb252ZXJ0VG9VUENBIiwiTiIsIlciLCJJMm9mNVJlYWRlciIsIm9wdHMiLCJub3JtYWxpemVCYXJTcGFjZVdpZHRoIiwiY291bnRlclN1bSIsImNvZGVTdW0iLCJjb3JyZWN0aW9uUmF0aW8iLCJNQVhfQ09SUkVDVElPTl9GQUNUT1IiLCJjb3JyZWN0aW9uUmF0aW9JbnZlcnNlIiwiYmFyU3BhY2VSYXRpbyIsIm5hcnJvd0JhcldpZHRoIiwiY291bnRlclBhaXIiLCJjb2RlcyIsImNvdW50ZXJMZW5ndGgiLCJfZGVjb2RlUGFpciIsIl92ZXJpZnlDb3VudGVyTGVuZ3RoIiwiU1RBUlRfUEFUVEVSTl9MRU5HVEgiLCJUd29PZkZpdmVSZWFkZXIiLCJDb2RlOTNSZWFkZXIiLCJjaGFyQXJyYXkiLCJuZXh0Q2hhciIsIm5leHRDaGFyQ29kZSIsIndhcm4iLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJfbWF0Y2hDaGVja0NoYXIiLCJfdmVyaWZ5RW5kIiwiX3ZlcmlmeUNoZWNrc3VtcyIsIl9kZWNvZGVFeHRlbmRlZCIsIkFFSU8iLCJjb2RlMzJzZXQiLCJDb2RlMzJSZWFkZXIiLCJyZXMiLCJjb2RlMzIiLCJfZGVjb2RlQ29kZTMyIiwiUkVBREVSUyIsImNvZGVfMTI4X3JlYWRlciIsImVhbl9yZWFkZXIiLCJlYW5fNV9yZWFkZXIiLCJlYW5fMl9yZWFkZXIiLCJlYW5fOF9yZWFkZXIiLCJjb2RlXzM5X3JlYWRlciIsImNvZGVfMzlfdmluX3JlYWRlciIsImNvZGFiYXJfcmVhZGVyIiwiQ29kYWJhclJlYWRlciIsInVwY19yZWFkZXIiLCJ1cGNfZV9yZWFkZXIiLCJpMm9mNV9yZWFkZXIiLCJjb2RlXzkzX3JlYWRlciIsImNvZGVfMzJfcmVhZGVyIiwicmVnaXN0ZXJSZWFkZXIiLCJyZWFkZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdFJlYWRlcnMiLCJpbml0Q29uZmlnIiwiJGRlYnVnIiwicmVhZGVycyIsInJlYWRlckNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJyZWFkZXJPYmoiLCJ2aXMiLCJub2RlIiwicHJvcCIsInNob3dGcmVxdWVuY3kiLCJzaG93UGF0dGVybiIsImRpc3BsYXkiLCJnZXRFeHRlbmRlZExpbmUiLCJleHQiLCJleHRlbmRMaW5lIiwiYW1vdW50IiwiZXh0ZW5zaW9uIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJkZWNvZGVQYXR0ZXJuIiwiY29kZVJlc3VsdCIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUltYWdlIiwiZGVjb2RlSW1hZ2UiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJkcmF3Qm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiYXRhbjIiLCJkcmF3U2NhbmxpbmUiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyIsImJhcmNvZGVzIiwibXVsdGlwbGUiLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiX3N1YnNjcmliZSIsImV2ZW50Iiwic3Vic2NyaWJlIiwicHVibGlzaCIsInN1YnNjcmliZXIiLCJvbmNlIiwidW5zdWJzY3JpYmUiLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwic3RyZWFtIiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJsb2NhdG9yIiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiUHJvZENvbmZpZyIsIlF1YWdnYUNvbmZpZyIsIlF1YWdnYUNvbnRleHQiLCJDYW52YXNDb250YWluZXIiLCJDYW52YXNJbmZvIiwiYm94U2l6ZSIsIkJhcmNvZGVMb2NhdG9yIiwiZ2V0Vmlld1BvcnQiLCJIVE1MRWxlbWVudCIsIm5vZGVOYW1lIiwic2VsZWN0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwiY2FudmFzU2l6ZSIsImltYWdlIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJnZXRDYW52YXNTaXplIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsInRhZ3MiLCJvYmplY3RVUkxUb0Jsb2IiLCJyZWFkVG9CdWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJiYXNlNjQiLCJhdG9iIiwidmlldyIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwidXJsIiwiaHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwic3RhdHVzIiwicmVzcG9uc2UiLCJvbmVycm9yIiwic2VuZCIsImZpbGUiLCJzZWxlY3RlZFRhZ3MiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiZXhpZlRhZ3MiLCJzZWxlY3RlZFRhZyIsImV4aWZUYWciLCJtYXJrZXIiLCJnZXRVaW50OCIsInJlYWRFWElGRGF0YSIsImdldFVpbnQxNiIsImdldFN0cmluZ0Zyb21CdWZmZXIiLCJ0aWZmT2Zmc2V0IiwiYmlnRW5kIiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJyZWFkVGFncyIsInRpZmZTdGFydCIsImRpclN0YXJ0Iiwic3RyaW5ncyIsImVudHJ5T2Zmc2V0IiwicmVhZFRhZ1ZhbHVlIiwibnVtVmFsdWVzIiwib3V0c3RyIiwiSW1hZ2VMb2FkZXIiLCJsb2FkIiwiZGlyZWN0b3J5IiwiaHRtbEltYWdlc1NyY0FycmF5IiwiaHRtbEltYWdlc0FycmF5IiwibnVtIiwibm90TG9hZGVkIiwiYWRkSW1hZ2UiLCJsb2FkZWQiLCJsb2FkZWRJbWciLCJub3Rsb2FkZWRJbWdzIiwiaW1nTmFtZSIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiYWRkT25sb2FkSGFuZGxlciIsImlucHV0U3RyZWFtRmFjdG9yeSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsIl9jYWxjdWxhdGVkV2lkdGgiLCJfY2FsY3VsYXRlZEhlaWdodCIsIl90b3BSaWdodCIsIl9jYW52YXNTaXplIiwiaW5pdFNpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0Iiwic2V0SW5wdXRTdHJlYW0iLCJlbmRlZCIsInBhdXNlIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiZiIsImJvb2wiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidHJpZ2dlciIsInRvcFJpZ2h0IiwiZ2V0VG9wUmlnaHQiLCJnZXRGcmFtZSIsImNyZWF0ZUxpdmVTdHJlYW0iLCJjcmVhdGVJbWFnZVN0cmVhbSIsImZyYW1lSWR4IiwicGF1c2VkIiwiaW1nQXJyYXkiLCJiYXNlVXJsIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsImxvYWRJbWFnZXMiLCJpbWdzIiwib3JpZW50YXRpb24iLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3N0cmVhbUNvbmZpZyIsIl92aWRlb1NpemUiLCJfc2l6ZSIsIl9zeCIsIl9zeSIsIl9jdHgiLCJfZGF0YSIsInZpZGVvU2l6ZSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiZ3JhYiIsImRvSGFsZlNhbXBsZSIsImRyYXdhYmxlIiwiZHJhd0FuZ2xlIiwidHJhbnNsYXRlIiwiZ2V0U2l6ZSIsIndvcmtlclBvb2wiLCJ1cGRhdGVXb3JrZXJzIiwiZnJhbWVHcmFiYmVyIiwiYXZhaWxhYmxlV29ya2VyIiwid29ya2VyVGhyZWFkIiwiYnVzeSIsIndvcmtlciIsInBvc3RNZXNzYWdlIiwiY21kIiwiY29uZmlnRm9yV29ya2VyIiwid29ya2VySW50ZXJmYWNlIiwiZmFjdG9yeSIsIlF1YWdnYSIsIm1lc3NhZ2UiLCJvblByb2Nlc3NlZCIsIndvcmtlckludGVyZmFjZVJlYWR5Iiwib25tZXNzYWdlIiwiZ2VuZXJhdGVXb3JrZXJCbG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImluaXRXb3JrZXIiLCJjYiIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJhZGp1c3RXb3JrZXJQb29sIiwiaW5jcmVhc2VCeSIsIndvcmtlcnNUb1Rlcm1pbmF0ZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic2V0dXBJbnB1dFN0cmVhbSIsIklucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJmcmFtZWdyYWJiZXIiLCJjYW52YXNDb250YWluZXIiLCJRV29ya2VycyIsImluaXRpYWxpemVEYXRhIiwicmVhZHkiLCJvblVJVGhyZWFkIiwid29ya2Vyc1VwZGF0ZWQiLCJsb2NhdGVBbmREZWNvZGUiLCJfaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsIl9nZXRWaWV3UG9ydCIsIl9pbml0Q2FudmFzIiwiaW5wdXRUeXBlIiwiQ2FtZXJhQWNjZXNzIiwiY2FuUmVjb3JkIiwiYmluZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVzdWx0Q29sbGVjdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNB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VSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUhPLEVBSVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUpPLEVBS1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUxPLEVBTVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQU5PLEVBT1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVBPLEVBUVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVJPLEVBU1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVRPLEVBVVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVZPLEVBV1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVhPLEVBWVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQVpPLEVBYVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWJPLEVBY1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWRPLEVBZVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWZPLEVBZ0JQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FoQk8sRUFpQlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWpCTyxFQWtCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBbEJPLEVBbUJQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FuQk8sRUFvQlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXBCTyxFQXFCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBckJPLEVBc0JQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F0Qk8sRUF1QlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXZCTyxFQXdCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBeEJPLEVBeUJQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F6Qk8sRUEwQlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTFCTyxFQTJCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBM0JPLEVBNEJQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0E1Qk8sRUE2QlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTdCTyxFQThCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBOUJPLEVBK0JQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0EvQk8sRUFnQ1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWhDTyxFQWlDUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBakNPLEVBa0NQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FsQ08sRUFtQ1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQW5DTyxFQW9DUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBcENPLEVBcUNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FyQ08sRUFzQ1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXRDTyxFQXVDUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBdkNPLEVBd0NQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F4Q08sRUF5Q1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXpDTyxFQTBDUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBMUNPLEVBMkNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0EzQ08sRUE0Q1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTVDTyxFQTZDUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBN0NPLEVBOENQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0E5Q08sRUErQ1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQS9DTyxFQWdEUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBaERPLEVBaURQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FqRE8sRUFrRFAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWxETyxFQW1EUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBbkRPLEVBb0RQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FwRE8sRUFxRFAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXJETyxFQXNEUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBdERPLEVBdURQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F2RE8sRUF3RFAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXhETyxFQXlEUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBekRPLEVBMERQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0ExRE8sRUEyRFAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTNETyxFQTREUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBNURPLEVBNkRQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0E3RE8sRUE4RFAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTlETyxFQStEUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBL0RPLEVBZ0VQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FoRU8sRUFpRVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWpFTyxFQWtFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBbEVPLEVBbUVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FuRU8sRUFvRVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXBFTyxFQXFFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBckVPLEVBc0VQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F0RU8sRUF1RVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXZFTyxFQXdFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBeEVPLEVBeUVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F6RU8sRUEwRVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTFFTyxFQTJFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBM0VPLEVBNEVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0E1RU8sRUE2RVAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTdFTyxFQThFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBOUVPLEVBK0VQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0EvRU8sRUFnRlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWhGTyxFQWlGUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBakZPLEVBa0ZQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FsRk8sRUFtRlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQW5GTyxFQW9GUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBcEZPLEVBcUZQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FyRk8sRUFzRlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXRGTyxFQXVGUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBdkZPLEVBd0ZQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F4Rk8sRUF5RlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXpGTyxFQTBGUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBMUZPLEVBMkZQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0EzRk8sRUE0RlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQTVGTyxFQTZGUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBN0ZPLEVBOEZQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0E5Rk8sRUErRlAsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQS9GTyxFQWdHUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBaEdPLEVBaUdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FqR08sRUFrR1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWxHTyxFQW1HUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBbkdPLEVBb0dQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FwR08sRUFxR1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXJHTyxFQXNHUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBdEdPLEVBdUdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0F2R08sRUF3R1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQXhHTyxFQXlHUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBekdPLEVBMEdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0ExR08sRUEyR1AsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQTNHTyxDOzswRkE2R0ssSTs7dUZBQ0gsSTs7K0VBQ1IsVTs7dUZBQ1E7QUFBRUMsU0FBRyxFQUFFLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVA7QUFBa0JDLFdBQUssRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUDtBQUF6QixLOzs7Ozs7O2dDQUVMcmIsSyxFQUFlc2EsVSxFQUFnQztBQUN2RCxVQUFNZ0IsU0FBUyxHQUFHO0FBQ2RwZ0IsYUFBSyxFQUFFaFgsTUFBTSxDQUFDQyxTQURBO0FBRWQ0MUIsWUFBSSxFQUFFLENBQUMsQ0FGTztBQUdkL1osYUFBSyxFQUFFQSxLQUhPO0FBSWR6Z0IsV0FBRyxFQUFFeWdCLEtBSlM7QUFLZHNhLGtCQUFVLEVBQUU7QUFDUmMsYUFBRyxFQUFFLENBREc7QUFFUkMsZUFBSyxFQUFFO0FBRkM7QUFMRSxPQUFsQjtBQVVBLFVBQUl2QixPQUFPLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFkO0FBQ0EsVUFBTWgxQixNQUFNLEdBQUdrYixLQUFmO0FBQ0EsVUFBSSthLE9BQU8sR0FBRyxDQUFDLEtBQUtsQixJQUFMLENBQVUvMEIsTUFBVixDQUFmO0FBQ0EsVUFBSW0yQixVQUFVLEdBQUcsQ0FBakI7O0FBRUEsV0FBSyxJQUFJdmpDLENBQUMsR0FBR29OLE1BQWIsRUFBcUJwTixDQUFDLEdBQUcsS0FBS21pQyxJQUFMLENBQVVsaUMsTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7QUFDNUMsWUFBSSxLQUFLbWlDLElBQUwsQ0FBVW5pQyxDQUFWLEtBQWdCcWpDLE9BQU8sR0FBRyxDQUFILEdBQU8sQ0FBOUIsQ0FBSixFQUFzQztBQUNsQ2pCLGlCQUFPLENBQUNtQixVQUFELENBQVA7QUFDSCxTQUZELE1BRU87QUFDSCxjQUFJQSxVQUFVLEtBQUtuQixPQUFPLENBQUNuaUMsTUFBUixHQUFpQixDQUFwQyxFQUF1QztBQUNuQyxnQkFBSTJpQyxVQUFKLEVBQWdCO0FBQ1osbUJBQUtpQixRQUFMLENBQWN6QixPQUFkLEVBQXVCUSxVQUF2QjtBQUNIOztBQUNELGlCQUFLLElBQUlQLElBQUksR0FBRyxDQUFoQixFQUFtQkEsSUFBSSxHQUFHLEtBQUt5QixZQUFMLENBQWtCN2pDLE1BQTVDLEVBQW9Eb2lDLElBQUksRUFBeEQsRUFBNEQ7QUFDeEQsa0JBQU03ZSxLQUFLLEdBQUcsS0FBS3VnQixhQUFMLENBQW1CM0IsT0FBbkIsRUFBNEIsS0FBSzBCLFlBQUwsQ0FBa0J6QixJQUFsQixDQUE1QixDQUFkOztBQUNBLGtCQUFJN2UsS0FBSyxHQUFHb2dCLFNBQVMsQ0FBQ3BnQixLQUF0QixFQUE2QjtBQUN6Qm9nQix5QkFBUyxDQUFDdkIsSUFBVixHQUFpQkEsSUFBakI7QUFDQXVCLHlCQUFTLENBQUNwZ0IsS0FBVixHQUFrQkEsS0FBbEI7QUFDSDtBQUNKOztBQUNEb2dCLHFCQUFTLENBQUMvN0IsR0FBVixHQUFnQjdILENBQWhCOztBQUNBLGdCQUFJNGpDLFNBQVMsQ0FBQ3ZCLElBQVYsS0FBbUIsQ0FBQyxDQUFwQixJQUF5QnVCLFNBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCLEtBQUt3Z0IsY0FBcEQsRUFBb0U7QUFDaEUscUJBQU8sSUFBUDtBQUNIOztBQUNELGdCQUFJLEtBQUtGLFlBQUwsQ0FBa0JGLFNBQVMsQ0FBQ3ZCLElBQTVCLENBQUosRUFBdUM7QUFDbkN1Qix1QkFBUyxDQUFDaEIsVUFBVixDQUFxQmMsR0FBckIsR0FBMkIsS0FBS08sbUJBQUwsQ0FDdkIsS0FBS0gsWUFBTCxDQUFrQkYsU0FBUyxDQUFDdkIsSUFBNUIsQ0FEdUIsRUFDWUQsT0FEWixFQUV2QixLQUFLOEIsY0FBTCxDQUFvQlIsR0FGRyxDQUEzQjtBQUdBRSx1QkFBUyxDQUFDaEIsVUFBVixDQUFxQmUsS0FBckIsR0FBNkIsS0FBS00sbUJBQUwsQ0FDekIsS0FBS0gsWUFBTCxDQUFrQkYsU0FBUyxDQUFDdkIsSUFBNUIsQ0FEeUIsRUFDVUQsT0FEVixFQUV6QixLQUFLOEIsY0FBTCxDQUFvQlAsS0FGSyxDQUE3QjtBQUdIOztBQUNELG1CQUFPQyxTQUFQO0FBQ0gsV0F4QkQsTUF3Qk87QUFDSEwsc0JBQVU7QUFDYjs7QUFDRG5CLGlCQUFPLENBQUNtQixVQUFELENBQVAsR0FBc0IsQ0FBdEI7QUFDQUYsaUJBQU8sR0FBRyxDQUFDQSxPQUFYO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLElBQVA7QUFDSDs7OzZCQUVRakIsTyxFQUF3QlEsVSxFQUErQjtBQUM1RCxXQUFLdUIsWUFBTCxDQUFrQi9CLE9BQWxCLEVBQTJCUSxVQUFVLENBQUNjLEdBQXRDLEVBQTJDLEtBQUtRLGNBQUwsQ0FBb0JSLEdBQS9EOztBQUNBLFdBQUtTLFlBQUwsQ0FBa0IvQixPQUFsQixFQUEyQlEsVUFBVSxDQUFDZSxLQUF0QyxFQUE2QyxLQUFLTyxjQUFMLENBQW9CUCxLQUFqRTtBQUNIOzs7QUFFRDtpQ0FDYTtBQUNULFVBQU12QixPQUFPLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFoQjs7QUFDQSxVQUFNaDFCLE1BQU0sR0FBRyxLQUFLZzNCLFFBQUwsQ0FBYyxLQUFLakMsSUFBbkIsQ0FBZjs7QUFDQSxVQUFNeUIsU0FBUyxHQUFHO0FBQ2RwZ0IsYUFBSyxFQUFFaFgsTUFBTSxDQUFDQyxTQURBO0FBRWQ0MUIsWUFBSSxFQUFFLENBQUMsQ0FGTztBQUdkL1osYUFBSyxFQUFFLENBSE87QUFJZHpnQixXQUFHLEVBQUUsQ0FKUztBQUtkKzZCLGtCQUFVLEVBQUU7QUFDUmMsYUFBRyxFQUFFLENBREc7QUFFUkMsZUFBSyxFQUFFO0FBRkM7QUFMRSxPQUFsQjtBQVVBLFVBQUlOLE9BQU8sR0FBRyxLQUFkO0FBQ0EsVUFBSUUsVUFBVSxHQUFHLENBQWpCOztBQUVBLFdBQUssSUFBSXZqQyxDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUksS0FBS21pQyxJQUFMLENBQVVuaUMsQ0FBVixLQUFnQnFqQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQTlCLENBQUosRUFBc0M7QUFDbENqQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSUEsVUFBVSxLQUFLbkIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBcEMsRUFBdUM7QUFDbkMsZ0JBQU1zRSxHQUFHLEdBQUc2OUIsT0FBTyxDQUFDL3ZCLE1BQVIsQ0FBZSxVQUFDaUMsSUFBRCxFQUFPQyxJQUFQO0FBQUEscUJBQWdCRCxJQUFJLEdBQUdDLElBQXZCO0FBQUEsYUFBZixFQUE0QyxDQUE1QyxDQUFaOztBQUNBLGlCQUFLLElBQUk4dEIsSUFBSSxHQUFHLEtBQUtnQyxZQUFyQixFQUFtQ2hDLElBQUksSUFBSSxLQUFLaUMsWUFBaEQsRUFBOERqQyxJQUFJLEVBQWxFLEVBQXNFO0FBQ2xFLGtCQUFNN2UsS0FBSyxHQUFHLEtBQUt1Z0IsYUFBTCxDQUFtQjNCLE9BQW5CLEVBQTRCLEtBQUswQixZQUFMLENBQWtCekIsSUFBbEIsQ0FBNUIsQ0FBZDs7QUFDQSxrQkFBSTdlLEtBQUssR0FBR29nQixTQUFTLENBQUNwZ0IsS0FBdEIsRUFBNkI7QUFDekJvZ0IseUJBQVMsQ0FBQ3ZCLElBQVYsR0FBaUJBLElBQWpCO0FBQ0F1Qix5QkFBUyxDQUFDcGdCLEtBQVYsR0FBa0JBLEtBQWxCO0FBQ0g7QUFDSjs7QUFDRCxnQkFBSW9nQixTQUFTLENBQUNwZ0IsS0FBVixHQUFrQixLQUFLd2dCLGNBQTNCLEVBQTJDO0FBQ3ZDSix1QkFBUyxDQUFDdGIsS0FBVixHQUFrQnRvQixDQUFDLEdBQUd1RSxHQUF0QjtBQUNBcS9CLHVCQUFTLENBQUMvN0IsR0FBVixHQUFnQjdILENBQWhCO0FBQ0E0akMsdUJBQVMsQ0FBQ2hCLFVBQVYsQ0FBcUJjLEdBQXJCLEdBQTJCLEtBQUtPLG1CQUFMLENBQ3ZCLEtBQUtILFlBQUwsQ0FBa0JGLFNBQVMsQ0FBQ3ZCLElBQTVCLENBRHVCLEVBQ1lELE9BRFosRUFFdkIsS0FBSzhCLGNBQUwsQ0FBb0JSLEdBRkcsQ0FBM0I7QUFHQUUsdUJBQVMsQ0FBQ2hCLFVBQVYsQ0FBcUJlLEtBQXJCLEdBQTZCLEtBQUtNLG1CQUFMLENBQ3pCLEtBQUtILFlBQUwsQ0FBa0JGLFNBQVMsQ0FBQ3ZCLElBQTVCLENBRHlCLEVBQ1VELE9BRFYsRUFFekIsS0FBSzhCLGNBQUwsQ0FBb0JQLEtBRkssQ0FBN0I7QUFHQSxxQkFBT0MsU0FBUDtBQUNIOztBQUVELGlCQUFLLElBQUl2ekIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFwQixFQUF1QkEsQ0FBQyxFQUF4QixFQUE0QjtBQUN4Qit4QixxQkFBTyxDQUFDL3hCLENBQUQsQ0FBUCxHQUFhK3hCLE9BQU8sQ0FBQy94QixDQUFDLEdBQUcsQ0FBTCxDQUFwQjtBQUNIOztBQUNEK3hCLG1CQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWEsQ0FBYjtBQUNBQSxtQkFBTyxDQUFDLENBQUQsQ0FBUCxHQUFhLENBQWI7QUFDQW1CLHNCQUFVO0FBQ2IsV0EzQkQsTUEyQk87QUFDSEEsc0JBQVU7QUFDYjs7QUFDRG5CLGlCQUFPLENBQUNtQixVQUFELENBQVAsR0FBc0IsQ0FBdEI7QUFDQUYsaUJBQU8sR0FBRyxDQUFDQSxPQUFYO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLElBQVA7QUFDSDs7OzRCQUVPanZCLEcsRUFBcUJrVSxLLEVBQXlDO0FBQUE7O0FBQ2xFLFVBQU1pYyxTQUFTLEdBQUcsS0FBS0MsVUFBTCxFQUFsQjs7QUFDQSxVQUFJRCxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDcEIsZUFBTyxJQUFQO0FBQ0gsT0FKaUUsQ0FLbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsVUFBSWxDLElBQXdCLEdBQUc7QUFDM0JBLFlBQUksRUFBRWtDLFNBQVMsQ0FBQ2xDLElBRFc7QUFFM0IvWixhQUFLLEVBQUVpYyxTQUFTLENBQUNqYyxLQUZVO0FBRzNCemdCLFdBQUcsRUFBRTA4QixTQUFTLENBQUMxOEIsR0FIWTtBQUkzQis2QixrQkFBVSxFQUFFO0FBQ1JjLGFBQUcsRUFBRWEsU0FBUyxDQUFDM0IsVUFBVixDQUFxQmMsR0FEbEI7QUFFUkMsZUFBSyxFQUFFWSxTQUFTLENBQUMzQixVQUFWLENBQXFCZTtBQUZwQjtBQUplLE9BQS9CO0FBU0EsVUFBTWMsWUFBWSxHQUFHLEVBQXJCO0FBQ0FBLGtCQUFZLENBQUNwZ0MsSUFBYixDQUFrQmcrQixJQUFsQjtBQUNBLFVBQUlxQyxRQUFRLEdBQUdyQyxJQUFJLENBQUNBLElBQXBCOztBQUNBLFVBQUlzQyxPQUFPLEdBQUksVUFBQ3IxQixDQUFELEVBQWU7QUFDMUIsZ0JBQVFBLENBQVI7QUFDSSxlQUFLLE1BQUksQ0FBQyswQixZQUFWO0FBQ0ksbUJBQU8sTUFBSSxDQUFDTyxNQUFaOztBQUNKLGVBQUssTUFBSSxDQUFDQyxZQUFWO0FBQ0ksbUJBQU8sTUFBSSxDQUFDQyxNQUFaOztBQUNKLGVBQUssTUFBSSxDQUFDUixZQUFWO0FBQ0ksbUJBQU8sTUFBSSxDQUFDUyxNQUFaOztBQUNKO0FBQ0ksbUJBQU8sSUFBUDtBQVJSO0FBVUgsT0FYYSxDQVdYMUMsSUFBSSxDQUFDQSxJQVhNLENBQWQ7O0FBWUEsVUFBSTVlLElBQUksR0FBRyxLQUFYO0FBQ0EsVUFBSXVoQixTQUFTLEdBQUcsS0FBaEI7QUFDQSxVQUFJaDFCLE9BQU8sR0FBR2cxQixTQUFkO0FBQ0EsVUFBSUMsbUJBQW1CLEdBQUcsSUFBMUI7QUFDQSxVQUFJQyxVQUFVLEdBQUcsQ0FBakI7QUFDQSxVQUFJQyxTQUF3QixHQUFHLEVBQS9CO0FBQ0EsVUFBSXQ3QixNQUE4QixHQUFHLEVBQXJDLENBL0NrRSxDQStDekI7O0FBRXpDLGFBQU8sQ0FBQzRaLElBQVIsRUFBYztBQUNWelQsZUFBTyxHQUFHZzFCLFNBQVY7QUFDQUEsaUJBQVMsR0FBRyxLQUFaO0FBQ0EzQyxZQUFJLEdBQUcsS0FBSytDLFdBQUwsQ0FBaUIvQyxJQUFJLENBQUV4NkIsR0FBdkIsRUFBNEJ3NkIsSUFBSSxDQUFFTyxVQUFsQyxDQUFQOztBQUNBLFlBQUlQLElBQUksS0FBSyxJQUFiLEVBQW1CO0FBQ2YsY0FBSUEsSUFBSSxDQUFDQSxJQUFMLEtBQWMsS0FBS2dELFNBQXZCLEVBQWtDO0FBQzlCSiwrQkFBbUIsR0FBRyxJQUF0QjtBQUNIOztBQUVELGNBQUk1QyxJQUFJLENBQUNBLElBQUwsS0FBYyxLQUFLZ0QsU0FBdkIsRUFBa0M7QUFDOUJGLHFCQUFTLENBQUM5Z0MsSUFBVixDQUFlZytCLElBQUksQ0FBQ0EsSUFBcEI7QUFDQTZDLHNCQUFVO0FBQ1ZSLG9CQUFRLElBQUlRLFVBQVUsR0FBRzdDLElBQUksQ0FBQ0EsSUFBOUI7QUFDSDs7QUFDRG9DLHNCQUFZLENBQUNwZ0MsSUFBYixDQUFrQmcrQixJQUFsQjs7QUFFQSxrQkFBUXNDLE9BQVI7QUFDQSxpQkFBSyxLQUFLQyxNQUFWO0FBQ0ksa0JBQUl2QyxJQUFJLENBQUNBLElBQUwsR0FBWSxFQUFoQixFQUFvQjtBQUNoQng0QixzQkFBTSxDQUFDeEYsSUFBUCxDQUFZZ3lCLE1BQU0sQ0FBQ2lQLFlBQVAsQ0FBb0IsS0FBS2pELElBQUksQ0FBQ0EsSUFBOUIsQ0FBWjtBQUNILGVBRkQsTUFFTyxJQUFJQSxJQUFJLENBQUNBLElBQUwsR0FBWSxFQUFoQixFQUFvQjtBQUN2Qng0QixzQkFBTSxDQUFDeEYsSUFBUCxDQUFZZ3lCLE1BQU0sQ0FBQ2lQLFlBQVAsQ0FBb0JqRCxJQUFJLENBQUNBLElBQUwsR0FBWSxFQUFoQyxDQUFaO0FBQ0gsZUFGTSxNQUVBO0FBQ0gsb0JBQUlBLElBQUksQ0FBQ0EsSUFBTCxLQUFjLEtBQUtnRCxTQUF2QixFQUFrQztBQUM5QkoscUNBQW1CLEdBQUcsS0FBdEI7QUFDSDs7QUFDRCx3QkFBUTVDLElBQUksQ0FBQ0EsSUFBYjtBQUNBLHVCQUFLLEtBQUtrRCxVQUFWO0FBQ0lQLDZCQUFTLEdBQUcsSUFBWjtBQUNBTCwyQkFBTyxHQUFHLEtBQUtHLE1BQWY7QUFDQTs7QUFDSix1QkFBSyxLQUFLQSxNQUFWO0FBQ0lILDJCQUFPLEdBQUcsS0FBS0csTUFBZjtBQUNBOztBQUNKLHVCQUFLLEtBQUtDLE1BQVY7QUFDSUosMkJBQU8sR0FBRyxLQUFLSSxNQUFmO0FBQ0E7O0FBQ0osdUJBQUssS0FBS00sU0FBVjtBQUNJNWhCLHdCQUFJLEdBQUcsSUFBUDtBQUNBO0FBYko7QUFlSDs7QUFDRDs7QUFDSixpQkFBSyxLQUFLcWhCLE1BQVY7QUFDSSxrQkFBSXpDLElBQUksQ0FBQ0EsSUFBTCxHQUFZLEVBQWhCLEVBQW9CO0FBQ2hCeDRCLHNCQUFNLENBQUN4RixJQUFQLENBQVlneUIsTUFBTSxDQUFDaVAsWUFBUCxDQUFvQixLQUFLakQsSUFBSSxDQUFDQSxJQUE5QixDQUFaO0FBQ0gsZUFGRCxNQUVPO0FBQ0gsb0JBQUlBLElBQUksQ0FBQ0EsSUFBTCxLQUFjLEtBQUtnRCxTQUF2QixFQUFrQztBQUM5QkoscUNBQW1CLEdBQUcsS0FBdEI7QUFDSDs7QUFDRCx3QkFBUTVDLElBQUksQ0FBQ0EsSUFBYjtBQUNJLHVCQUFLLEtBQUtrRCxVQUFWO0FBQ0lQLDZCQUFTLEdBQUcsSUFBWjtBQUNBTCwyQkFBTyxHQUFHLEtBQUtDLE1BQWY7QUFDQTs7QUFDSix1QkFBSyxLQUFLQSxNQUFWO0FBQ0lELDJCQUFPLEdBQUcsS0FBS0MsTUFBZjtBQUNBOztBQUNKLHVCQUFLLEtBQUtHLE1BQVY7QUFDSUosMkJBQU8sR0FBRyxLQUFLSSxNQUFmO0FBQ0E7O0FBQ0osdUJBQUssS0FBS00sU0FBVjtBQUNJNWhCLHdCQUFJLEdBQUcsSUFBUDtBQUNBO0FBYlI7QUFlSDs7QUFDRDs7QUFDSixpQkFBSyxLQUFLc2hCLE1BQVY7QUFDSSxrQkFBSTFDLElBQUksQ0FBQ0EsSUFBTCxHQUFZLEdBQWhCLEVBQXFCO0FBQ2pCeDRCLHNCQUFNLENBQUN4RixJQUFQLENBQVlnK0IsSUFBSSxDQUFDQSxJQUFMLEdBQVksRUFBWixHQUFpQixNQUFNQSxJQUFJLENBQUNBLElBQTVCLEdBQW1DQSxJQUFJLENBQUNBLElBQXBEO0FBQ0gsZUFGRCxNQUVPO0FBQ0gsb0JBQUlBLElBQUksQ0FBQ0EsSUFBTCxLQUFjLEtBQUtnRCxTQUF2QixFQUFrQztBQUM5QkoscUNBQW1CLEdBQUcsS0FBdEI7QUFDSDs7QUFDRCx3QkFBUTVDLElBQUksQ0FBQ0EsSUFBYjtBQUNBLHVCQUFLLEtBQUt1QyxNQUFWO0FBQ0lELDJCQUFPLEdBQUcsS0FBS0MsTUFBZjtBQUNBOztBQUNKLHVCQUFLLEtBQUtFLE1BQVY7QUFDSUgsMkJBQU8sR0FBRyxLQUFLRyxNQUFmO0FBQ0E7O0FBQ0osdUJBQUssS0FBS08sU0FBVjtBQUNJNWhCLHdCQUFJLEdBQUcsSUFBUDtBQUNBO0FBVEo7QUFXSDs7QUFDRDtBQXRFSjtBQXdFSCxTQXBGRCxNQW9GTztBQUNIQSxjQUFJLEdBQUcsSUFBUDtBQUNIOztBQUNELFlBQUl6VCxPQUFKLEVBQWE7QUFDVDIwQixpQkFBTyxHQUFHQSxPQUFPLEtBQUssS0FBS0MsTUFBakIsR0FBMEIsS0FBS0UsTUFBL0IsR0FBd0MsS0FBS0YsTUFBdkQ7QUFDSDtBQUNKOztBQUVELFVBQUl2QyxJQUFJLEtBQUssSUFBYixFQUFtQjtBQUNmLGVBQU8sSUFBUDtBQUNIOztBQUVEQSxVQUFJLENBQUN4NkIsR0FBTCxHQUFXLEtBQUt1N0IsVUFBTCxDQUFnQixLQUFLakIsSUFBckIsRUFBMkJFLElBQUksQ0FBQ3g2QixHQUFoQyxDQUFYOztBQUNBLFVBQUksQ0FBQyxLQUFLMjlCLHlCQUFMLENBQStCbkQsSUFBL0IsQ0FBTCxFQUEwQztBQUN0QyxlQUFPLElBQVA7QUFDSDs7QUFFRHFDLGNBQVEsSUFBSVEsVUFBVSxHQUFHQyxTQUFTLENBQUNBLFNBQVMsQ0FBQ2xsQyxNQUFWLEdBQW1CLENBQXBCLENBQWxDOztBQUNBLFVBQUl5a0MsUUFBUSxHQUFHLEdBQVgsS0FBbUJTLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDbGxDLE1BQVYsR0FBbUIsQ0FBcEIsQ0FBaEMsRUFBd0Q7QUFDcEQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSSxDQUFDNEosTUFBTSxDQUFDNUosTUFBWixFQUFvQjtBQUNoQixlQUFPLElBQVA7QUFDSCxPQWpLaUUsQ0FtS2xFOzs7QUFDQSxVQUFJZ2xDLG1CQUFKLEVBQXlCO0FBQ3JCcDdCLGNBQU0sQ0FBQzJtQixNQUFQLENBQWMzbUIsTUFBTSxDQUFDNUosTUFBUCxHQUFnQixDQUE5QixFQUFpQyxDQUFqQztBQUNIOztBQUdELGFBQU87QUFDSG9pQyxZQUFJLEVBQUV4NEIsTUFBTSxDQUFDd0ssSUFBUCxDQUFZLEVBQVosQ0FESDtBQUVIaVUsYUFBSyxFQUFFaWMsU0FBUyxDQUFDamMsS0FGZDtBQUdIemdCLFdBQUcsRUFBRXc2QixJQUFJLENBQUN4NkIsR0FIUDtBQUlIODhCLGVBQU8sRUFBRUEsT0FKTjtBQUtISixpQkFBUyxFQUFFQSxTQUxSO0FBTUhFLG9CQUFZLEVBQUVBLFlBTlg7QUFPSGdCLGVBQU8sRUFBRXBELElBUE47QUFRSGEsY0FBTSxFQUFFLEtBQUtDO0FBUlYsT0FBUDtBQVVIOzs7OENBRXlCc0MsTyxFQUEwQztBQUVoRSxVQUFJdm1DLElBQUksR0FBRyxJQUFYO0FBQUEsVUFDSXdtQyxxQkFESjtBQUdBQSwyQkFBcUIsR0FBR0QsT0FBTyxDQUFDNTlCLEdBQVIsR0FBZSxDQUFDNDlCLE9BQU8sQ0FBQzU5QixHQUFSLEdBQWM0OUIsT0FBTyxDQUFDbmQsS0FBdkIsSUFBZ0MsQ0FBdkU7O0FBQ0EsVUFBSW9kLHFCQUFxQixHQUFHeG1DLElBQUksQ0FBQ2lqQyxJQUFMLENBQVVsaUMsTUFBdEMsRUFBOEM7QUFDMUMsWUFBSWYsSUFBSSxDQUFDeW1DLFdBQUwsQ0FBaUJGLE9BQU8sQ0FBQzU5QixHQUF6QixFQUE4QjY5QixxQkFBOUIsRUFBcUQsQ0FBckQsQ0FBSixFQUE2RDtBQUN6RCxpQkFBT0QsT0FBUDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7Ozt3Q0FHbUJHLFEsRUFBaUNDLFUsRUFBbUNoRCxPLEVBQXdDO0FBQzVILFVBQUk1aUMsTUFBTSxHQUFHNGlDLE9BQU8sQ0FBQzVpQyxNQUFyQjtBQUFBLFVBQ0k2bEMsYUFBYSxHQUFHLENBRHBCO0FBQUEsVUFFSUMsV0FBVyxHQUFHLENBRmxCOztBQUlBLGFBQU85bEMsTUFBTSxFQUFiLEVBQWlCO0FBQ2I4bEMsbUJBQVcsSUFBSUgsUUFBUSxDQUFDL0MsT0FBTyxDQUFDNWlDLE1BQUQsQ0FBUixDQUF2QjtBQUNBNmxDLHFCQUFhLElBQUlELFVBQVUsQ0FBQ2hELE9BQU8sQ0FBQzVpQyxNQUFELENBQVIsQ0FBM0I7QUFDSDs7QUFDRCxhQUFPOGxDLFdBQVcsR0FBR0QsYUFBckI7QUFDSDs7OztFQTlidUJoRSxjOztBQWljYjJCLGlGQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuY0E7Q0FHQTs7QUFDQSxJQUFNdUMsWUFBWSxHQUFHLEVBQXJCO0FBQ0E7QUFDQSxJQUFNQyxhQUFhLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBdEI7QUFDQSxJQUFNQyxjQUFjLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUF2QjtBQUNBO0FBQ0EsSUFBTUMsdUJBQXVCLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBaEM7QUFDQSxJQUFNckMsWUFBWSxHQUFHLENBQ2pCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQURpQixFQUVqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FGaUIsRUFHakIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBSGlCLEVBSWpCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUppQixFQUtqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FMaUIsRUFNakIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBTmlCLEVBT2pCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQVBpQixFQVFqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FSaUIsRUFTakIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBVGlCLEVBVWpCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQVZpQixFQVdqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FYaUIsRUFZakIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBWmlCLEVBYWpCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQWJpQixFQWNqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FkaUIsRUFlakIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBZmlCLEVBZ0JqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FoQmlCLEVBaUJqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FqQmlCLEVBa0JqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FsQmlCLEVBbUJqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FuQmlCLEVBb0JqQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FwQmlCLENBQXJCO0FBc0JBLElBQU1zQyxjQUFjLEdBQUcsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLEVBQWhDLEVBQW9DLEVBQXBDLENBQXZCLEMsQ0FDQTs7QUFDQSxJQUFNcEMsY0FBYyxHQUFHLElBQXZCOztJQUVNcUMsb0I7Ozs7O0FBR3dCO0FBRTFCLHFCQUFZdjRCLE1BQVosRUFBMENvMEIsV0FBMUMsRUFBOEU7QUFBQTs7QUFBQTs7QUFDMUUsOEJBQU14cUIsZUFBSyxDQUFDO0FBQUV3cUIsaUJBQVcsRUFBRTtBQUFmLEtBQUQsRUFBc0JwMEIsTUFBdEIsQ0FBWCxFQUEwQ28wQixXQUExQzs7QUFEMEUsK0VBSnJFLFFBSXFFOztBQUFBLDBGQUgxRCxJQUcwRDs7QUFBQSxxRkFGL0QsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FFK0Q7O0FBQUE7QUFFN0U7Ozs7aUNBQ1k1USxPLEVBQWdDbGtCLE0sRUFBZ0JpMkIsTyxFQUFrQmlELFMsRUFBNEM7QUFDdkgsVUFBTWxFLE9BQU8sR0FBRyxJQUFJN3FCLEtBQUosQ0FBa0IrWixPQUFPLENBQUNyeEIsTUFBMUIsRUFBa0NzbUMsSUFBbEMsQ0FBdUMsQ0FBdkMsQ0FBaEI7QUFDQSxVQUFNM0MsU0FBMEIsR0FBRztBQUMvQnBnQixhQUFLLEVBQUVoWCxNQUFNLENBQUNDLFNBRGlCO0FBRS9CNmIsYUFBSyxFQUFFLENBRndCO0FBRy9CemdCLFdBQUcsRUFBRTtBQUgwQixPQUFuQztBQUtBLFVBQU0yK0IsT0FBTyxHQUFHeEMsY0FBaEIsQ0FQdUgsQ0FRdkg7O0FBQ0EsVUFBSVQsVUFBVSxHQUFHLENBQWpCOztBQUNBLFVBQUksQ0FBQ24yQixNQUFMLEVBQWE7QUFDVEEsY0FBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixDQUFUO0FBQ0g7O0FBQ0QsVUFBSTc0QixLQUFLLEdBQUcsS0FBWjs7QUFDQSxXQUFLLElBQUl0SixDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDO0FBQ0EsWUFBSSxLQUFLbWlDLElBQUwsQ0FBVW5pQyxDQUFWLEtBQWdCcWpDLE9BQU8sR0FBRyxDQUFILEdBQU8sQ0FBOUIsQ0FBSixFQUFzQztBQUNsQ2pCLGlCQUFPLENBQUNtQixVQUFELENBQVAsSUFBdUIsQ0FBdkI7QUFDSCxTQUZELE1BRU87QUFDSCxjQUFJQSxVQUFVLEtBQUtuQixPQUFPLENBQUNuaUMsTUFBUixHQUFpQixDQUFwQyxFQUF1QztBQUNuQyxnQkFBTXVqQixLQUFLLEdBQUcsS0FBS3VnQixhQUFMLENBQW1CM0IsT0FBbkIsRUFBNEI5USxPQUE1QixDQUFkLENBRG1DLENBRW5DOzs7QUFDQSxnQkFBSTlOLEtBQUssR0FBR2dqQixPQUFSLElBQW1CNUMsU0FBUyxDQUFDcGdCLEtBQTdCLElBQXNDQSxLQUFLLEdBQUdvZ0IsU0FBUyxDQUFDcGdCLEtBQTVELEVBQW1FO0FBQy9EbGEsbUJBQUssR0FBRyxJQUFSO0FBQ0FzNkIsdUJBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCQSxLQUFsQjtBQUNBb2dCLHVCQUFTLENBQUN0YixLQUFWLEdBQWtCdG9CLENBQUMsR0FBR29pQyxPQUFPLENBQUMvdkIsTUFBUixDQUFlLFVBQUM5TixHQUFELEVBQU05RixLQUFOO0FBQUEsdUJBQWdCOEYsR0FBRyxHQUFHOUYsS0FBdEI7QUFBQSxlQUFmLEVBQTRDLENBQTVDLENBQXRCO0FBQ0FtbEMsdUJBQVMsQ0FBQy83QixHQUFWLEdBQWdCN0gsQ0FBaEIsQ0FKK0QsQ0FLL0Q7O0FBQ0EscUJBQU80akMsU0FBUDtBQUNIOztBQUNELGdCQUFJMEMsU0FBSixFQUFlO0FBQ1gsbUJBQUssSUFBSWoyQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK3hCLE9BQU8sQ0FBQ25pQyxNQUFSLEdBQWlCLENBQXJDLEVBQXdDb1EsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Qyt4Qix1QkFBTyxDQUFDL3hCLENBQUQsQ0FBUCxHQUFhK3hCLE9BQU8sQ0FBQy94QixDQUFDLEdBQUcsQ0FBTCxDQUFwQjtBQUNIOztBQUNEK3hCLHFCQUFPLENBQUNBLE9BQU8sQ0FBQ25pQyxNQUFSLEdBQWlCLENBQWxCLENBQVAsR0FBOEIsQ0FBOUI7QUFDQW1pQyxxQkFBTyxDQUFDQSxPQUFPLENBQUNuaUMsTUFBUixHQUFpQixDQUFsQixDQUFQLEdBQThCLENBQTlCO0FBQ0FzakMsd0JBQVU7QUFDYjtBQUNKLFdBbkJELE1BbUJPO0FBQ0hBLHNCQUFVO0FBQ2I7O0FBQ0RuQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQLEdBQXNCLENBQXRCO0FBQ0FGLGlCQUFPLEdBQUcsQ0FBQ0EsT0FBWDtBQUNIO0FBQ0o7O0FBQ0QsVUFBSS81QixLQUFKLEVBQVcsQ0FDUDtBQUNILE9BRkQsTUFFTyxDQUNIO0FBQ0g7O0FBQ0QsYUFBT0EsS0FBSyxHQUFHczZCLFNBQUgsR0FBZSxJQUEzQjtBQUNILEssQ0FFRDs7OztnQ0FDWXRiLEssRUFBZW1lLFMsRUFBd0M7QUFDL0Q7QUFDQSxVQUFNckUsT0FBTyxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFoQjtBQUNBLFVBQU1oMUIsTUFBTSxHQUFHa2IsS0FBZjtBQUNBLFVBQU1zYixTQUFzQixHQUFHO0FBQzNCcGdCLGFBQUssRUFBRWhYLE1BQU0sQ0FBQ0MsU0FEYTtBQUUzQjQxQixZQUFJLEVBQUUsQ0FBQyxDQUZvQjtBQUczQi9aLGFBQUssRUFBRUEsS0FIb0I7QUFJM0J6Z0IsV0FBRyxFQUFFeWdCO0FBSnNCLE9BQS9CO0FBTUEsVUFBTWtlLE9BQU8sR0FBR3hDLGNBQWhCO0FBQ0EsVUFBSVgsT0FBTyxHQUFHLENBQUMsS0FBS2xCLElBQUwsQ0FBVS8wQixNQUFWLENBQWY7QUFDQSxVQUFJbTJCLFVBQVUsR0FBRyxDQUFqQjs7QUFFQSxVQUFJLENBQUNrRCxTQUFMLEVBQWdCO0FBQ1o7QUFDQUEsaUJBQVMsR0FBRzNDLFlBQVksQ0FBQzdqQyxNQUF6QixDQUZZLENBR1o7QUFDSDs7QUFFRCxVQUFJcUosS0FBSyxHQUFHLEtBQVo7O0FBQ0EsV0FBSyxJQUFJdEosQ0FBQyxHQUFHb04sTUFBYixFQUFxQnBOLENBQUMsR0FBRyxLQUFLbWlDLElBQUwsQ0FBVWxpQyxNQUFuQyxFQUEyQ0QsQ0FBQyxFQUE1QyxFQUFnRDtBQUM1QyxZQUFJLEtBQUttaUMsSUFBTCxDQUFVbmlDLENBQVYsS0FBZ0JxakMsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUE5QixDQUFKLEVBQXNDO0FBQ2xDakIsaUJBQU8sQ0FBQ21CLFVBQUQsQ0FBUDtBQUNILFNBRkQsTUFFTztBQUNILGNBQUlBLFVBQVUsS0FBS25CLE9BQU8sQ0FBQ25pQyxNQUFSLEdBQWlCLENBQXBDLEVBQXVDO0FBQ25DLGlCQUFLLElBQUlvaUMsSUFBSSxHQUFHLENBQWhCLEVBQW1CQSxJQUFJLEdBQUdvRSxTQUExQixFQUFxQ3BFLElBQUksRUFBekMsRUFBNkM7QUFDekMsa0JBQU03ZSxLQUFLLEdBQUcsS0FBS3VnQixhQUFMLENBQW1CM0IsT0FBbkIsRUFBNEIwQixZQUFZLENBQUN6QixJQUFELENBQXhDLENBQWQ7O0FBQ0F1Qix1QkFBUyxDQUFDLzdCLEdBQVYsR0FBZ0I3SCxDQUFoQjs7QUFDQSxrQkFBSXdqQixLQUFLLEdBQUdvZ0IsU0FBUyxDQUFDcGdCLEtBQXRCLEVBQThCO0FBQzFCb2dCLHlCQUFTLENBQUN2QixJQUFWLEdBQWlCQSxJQUFqQjtBQUNBdUIseUJBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCQSxLQUFsQjtBQUNIO0FBQ0o7O0FBQ0QsZ0JBQUlvZ0IsU0FBUyxDQUFDcGdCLEtBQVYsR0FBbUJnakIsT0FBdkIsRUFBZ0M7QUFDNUI7QUFDQSxxQkFBTyxJQUFQO0FBQ0gsYUFaa0MsQ0FhbkM7OztBQUNBLG1CQUFPNUMsU0FBUDtBQUNILFdBZkQsTUFlTztBQUNITCxzQkFBVTtBQUNiOztBQUNEbkIsaUJBQU8sQ0FBQ21CLFVBQUQsQ0FBUCxHQUFzQixDQUF0QjtBQUNBRixpQkFBTyxHQUFHLENBQUNBLE9BQVg7QUFDSDtBQUNKOztBQUNELGFBQU8vNUIsS0FBSyxHQUFHczZCLFNBQUgsR0FBZSxJQUEzQjtBQUNIOzs7aUNBRThDO0FBQzNDO0FBQ0EsVUFBSXgyQixNQUFNLEdBQUcsS0FBS2czQixRQUFMLENBQWMsS0FBS2pDLElBQW5CLENBQWI7O0FBQ0EsVUFBSW9DLFNBQWlDLEdBQUcsSUFBeEM7O0FBRUEsYUFBTyxDQUFDQSxTQUFSLEVBQW1CO0FBQ2ZBLGlCQUFTLEdBQUcsS0FBS21DLFlBQUwsQ0FBa0JULGFBQWxCLEVBQWlDNzRCLE1BQWpDLEVBQXlDLEtBQXpDLEVBQWdELElBQWhELENBQVosQ0FEZSxDQUVmOztBQUNBLFlBQUksQ0FBQ20zQixTQUFMLEVBQWdCO0FBQ1osaUJBQU8sSUFBUDtBQUNIOztBQUVELFlBQU1vQyxzQkFBc0IsR0FBR3BDLFNBQVMsQ0FBQ2pjLEtBQVYsSUFBbUJpYyxTQUFTLENBQUMxOEIsR0FBVixHQUFnQjA4QixTQUFTLENBQUNqYyxLQUE3QyxDQUEvQjs7QUFFQSxZQUFJcWUsc0JBQXNCLElBQUksQ0FBOUIsRUFBaUM7QUFDN0IsY0FBSSxLQUFLaEIsV0FBTCxDQUFpQmdCLHNCQUFqQixFQUF5Q3BDLFNBQVMsQ0FBQ2pjLEtBQW5ELEVBQTBELENBQTFELENBQUosRUFBa0U7QUFDOUQ7QUFDQSxtQkFBT2ljLFNBQVA7QUFDSDtBQUNKOztBQUVEbjNCLGNBQU0sR0FBR20zQixTQUFTLENBQUMxOEIsR0FBbkI7QUFDQTA4QixpQkFBUyxHQUFHLElBQVo7QUFDSCxPQXZCMEMsQ0F3QjNDOzs7QUFDQSxhQUFPLElBQVA7QUFDSDs7O3lDQUU0QnFDLGEsRUFBc0M7QUFDL0Q7QUFDQSxXQUFLLElBQUk1bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29tQyxjQUFjLENBQUNubUMsTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7QUFDNUMsWUFBSTRtQyxhQUFhLEtBQUtSLGNBQWMsQ0FBQ3BtQyxDQUFELENBQXBDLEVBQXlDO0FBQ3JDO0FBQ0EsaUJBQU9BLENBQVA7QUFDSDtBQUNKLE9BUDhELENBUS9EOzs7QUFDQSxhQUFPLElBQVA7QUFDSDs7O21DQUV3QjZtQyxNLEVBQXlCaDlCLE0sRUFBdUI0NkIsWSxFQUEwRDtBQUMvSDtBQUNBLFVBQUlxQyxPQUE2QyxxQkFBUUQsTUFBUixDQUFqRDs7QUFDQSxVQUFJRCxhQUFhLEdBQUcsR0FBcEI7O0FBRUEsV0FBSyxJQUFJNW1DLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDeEI4bUMsZUFBTyxHQUFHLEtBQUsxQixXQUFMLENBQWlCMEIsT0FBTyxDQUFDai9CLEdBQXpCLENBQVYsQ0FEd0IsQ0FFeEI7O0FBQ0EsWUFBSSxDQUFDaS9CLE9BQUwsRUFBYztBQUNWO0FBQ0EsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQUtBLE9BQUQsQ0FBeUJ6RSxJQUF6QixJQUFpQzJELFlBQXJDLEVBQW1EO0FBQzlDYyxpQkFBRCxDQUF5QnpFLElBQXpCLElBQWlDMkQsWUFBakM7QUFDQVksdUJBQWEsSUFBSSxLQUFNLElBQUk1bUMsQ0FBM0I7QUFDSCxTQUhELE1BR087QUFDSDRtQyx1QkFBYSxJQUFJLEtBQU0sSUFBSTVtQyxDQUEzQjtBQUNIOztBQUNENkosY0FBTSxDQUFDeEYsSUFBUCxDQUFheWlDLE9BQUQsQ0FBeUJ6RSxJQUFyQztBQUNBb0Msb0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCeWlDLE9BQWxCO0FBQ0g7O0FBRUQsVUFBTUMsVUFBVSxHQUFHLEtBQUtDLG9CQUFMLENBQTBCSixhQUExQixDQUFuQixDQXRCK0gsQ0F1Qi9IOzs7QUFDQSxVQUFJRyxVQUFVLEtBQUssSUFBbkIsRUFBeUI7QUFDckI7QUFDQSxlQUFPLElBQVA7QUFDSDs7QUFFRGw5QixZQUFNLENBQUNtRyxPQUFQLENBQWUrMkIsVUFBZjs7QUFFQSxVQUFJRSxhQUFhLEdBQUcsS0FBS1AsWUFBTCxDQUFrQlIsY0FBbEIsRUFBa0NZLE9BQU8sQ0FBQ2ovQixHQUExQyxFQUErQyxJQUEvQyxFQUFxRCxLQUFyRCxDQUFwQixDQS9CK0gsQ0FnQy9IOzs7QUFFQSxVQUFJby9CLGFBQWEsS0FBSyxJQUFsQixJQUEwQixDQUFDQSxhQUFhLENBQUNwL0IsR0FBN0MsRUFBa0Q7QUFDOUM7QUFDQSxlQUFPLElBQVA7QUFDSDs7QUFFRDQ4QixrQkFBWSxDQUFDcGdDLElBQWIsQ0FBa0I0aUMsYUFBbEI7O0FBRUEsV0FBSyxJQUFJam5DLEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLEVBQUMsRUFBeEIsRUFBNEI7QUFDeEJpbkMscUJBQWEsR0FBRyxLQUFLN0IsV0FBTCxDQUFpQjZCLGFBQWEsQ0FBRXAvQixHQUFoQyxFQUFxQ20rQixZQUFyQyxDQUFoQixDQUR3QixDQUV4Qjs7QUFFQSxZQUFJLENBQUNpQixhQUFMLEVBQW9CO0FBQ2hCO0FBQ0EsaUJBQU8sSUFBUDtBQUNIOztBQUVEeEMsb0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCNGlDLGFBQWxCO0FBQ0FwOUIsY0FBTSxDQUFDeEYsSUFBUCxDQUFhNGlDLGFBQUQsQ0FBK0I1RSxJQUEzQztBQUNILE9BcEQ4SCxDQXNEL0g7QUFDQTtBQUNBOzs7QUFDQSxhQUFPNEUsYUFBUDtBQUNIOzs7OENBRW1DeEIsTyxFQUFrRDtBQUNsRjtBQUNBLFVBQU1DLHFCQUFxQixHQUFHRCxPQUFPLENBQUM1OUIsR0FBUixJQUFlNDlCLE9BQU8sQ0FBQzU5QixHQUFSLEdBQWM0OUIsT0FBTyxDQUFDbmQsS0FBckMsQ0FBOUI7O0FBRUEsVUFBSW9kLHFCQUFxQixHQUFHLEtBQUt2RCxJQUFMLENBQVVsaUMsTUFBdEMsRUFBOEM7QUFDMUMsWUFBSSxLQUFLMGxDLFdBQUwsQ0FBaUJGLE9BQU8sQ0FBQzU5QixHQUF6QixFQUE4QjY5QixxQkFBOUIsRUFBcUQsQ0FBckQsQ0FBSixFQUE2RDtBQUN6RDtBQUNBLGlCQUFPRCxPQUFQO0FBQ0g7QUFDSixPQVRpRixDQVVsRjs7O0FBQ0EsYUFBTyxJQUFQO0FBQ0g7Ozs2QkFFa0JyNEIsTSxFQUFnQmkyQixPLEVBQTBDO0FBQ3pFO0FBQ0EsVUFBTW9DLE9BQU8sR0FBRyxLQUFLaUIsWUFBTCxDQUFrQixLQUFLUSxZQUF2QixFQUFxQzk1QixNQUFyQyxFQUE2Q2kyQixPQUE3QyxFQUFzRCxLQUF0RCxDQUFoQjs7QUFFQSxhQUFPb0MsT0FBTyxLQUFLLElBQVosR0FBbUIsS0FBS0QseUJBQUwsQ0FBK0JDLE9BQS9CLENBQW5CLEdBQTZELElBQXBFO0FBQ0g7Ozs4QkFFbUI1N0IsTSxFQUFnQztBQUNoRDtBQUNBLFVBQUl0RixHQUFHLEdBQUcsQ0FBVjs7QUFFQSxXQUFLLElBQUl2RSxDQUFDLEdBQUc2SixNQUFNLENBQUM1SixNQUFQLEdBQWdCLENBQTdCLEVBQWdDRCxDQUFDLElBQUksQ0FBckMsRUFBd0NBLENBQUMsSUFBSSxDQUE3QyxFQUFnRDtBQUM1Q3VFLFdBQUcsSUFBSXNGLE1BQU0sQ0FBQzdKLENBQUQsQ0FBYjtBQUNIOztBQUVEdUUsU0FBRyxJQUFJLENBQVA7O0FBRUEsV0FBSyxJQUFJdkUsR0FBQyxHQUFHNkosTUFBTSxDQUFDNUosTUFBUCxHQUFnQixDQUE3QixFQUFnQ0QsR0FBQyxJQUFJLENBQXJDLEVBQXdDQSxHQUFDLElBQUksQ0FBN0MsRUFBZ0Q7QUFDNUN1RSxXQUFHLElBQUlzRixNQUFNLENBQUM3SixHQUFELENBQWI7QUFDSCxPQVorQyxDQWNoRDs7O0FBQ0EsYUFBT3VFLEdBQUcsR0FBRyxFQUFOLEtBQWEsQ0FBcEI7QUFDSDs7O3NDQUV5QjZJLE0sRUFBZ0M7QUFDdEQsVUFBTWtiLEtBQUssR0FBRyxLQUFLOGIsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixFQUF5Qi8wQixNQUF6QixDQUFkOztBQUNBLFVBQU1tM0IsU0FBUyxHQUFHLEtBQUttQyxZQUFMLENBQWtCUCx1QkFBbEIsRUFBMkM3ZCxLQUEzQyxFQUFrRCxLQUFsRCxFQUF5RCxLQUF6RCxDQUFsQjs7QUFFQSxVQUFJaWMsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCLGVBQU8sSUFBUDtBQUNILE9BTnFELENBUXREO0FBQ0E7OztBQUNBLFdBQUssSUFBSXZrQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtraUMsV0FBTCxDQUFpQmppQyxNQUFyQyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUM5QztBQUNBLFlBQUk7QUFDQSxjQUFJNkosTUFBTSxHQUFHLEtBQUtxNEIsV0FBTCxDQUFpQmxpQyxDQUFqQixFQUFvQjhpQyxPQUFwQixDQUE0QixLQUFLWCxJQUFqQyxFQUF1Q29DLFNBQVMsQ0FBQzE4QixHQUFqRCxDQUFiLENBREEsQ0FFQTs7O0FBQ0EsY0FBSWdDLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ2pCLG1CQUFPO0FBQ0h3NEIsa0JBQUksRUFBRXg0QixNQUFNLENBQUN3NEIsSUFEVjtBQUVIL1osbUJBQUssRUFBTEEsS0FGRztBQUdIaWMsdUJBQVMsRUFBVEEsU0FIRztBQUlIMThCLGlCQUFHLEVBQUVnQyxNQUFNLENBQUNoQyxHQUpUO0FBS0g0OEIsMEJBQVksRUFBRTU2QixNQUFNLENBQUM0NkIsWUFMbEI7QUFNSHZCLG9CQUFNLEVBQUUsS0FBS2hCLFdBQUwsQ0FBaUJsaUMsQ0FBakIsRUFBb0JtakM7QUFOekIsYUFBUDtBQVFIO0FBQ0osU0FiRCxDQWFFLE9BQU9wZixHQUFQLEVBQVk7QUFDVjFELGlCQUFPLENBQUNtRCxLQUFSLENBQWMsOEJBQWQsRUFBOEMsS0FBSzBlLFdBQUwsQ0FBaUJsaUMsQ0FBakIsQ0FBOUMsRUFBbUUsSUFBbkUsRUFBeUUrakIsR0FBekU7QUFDSDtBQUNKLE9BNUJxRCxDQThCdEQ7OztBQUNBLGFBQU8sSUFBUDtBQUNIOzs7NEJBRU8zUCxHLEVBQXFCa1UsSyxFQUFrRDtBQUMzRTtBQUNBO0FBQ0EsVUFBTXplLE1BQU0sR0FBRyxJQUFJME4sS0FBSixFQUFmO0FBQ0EsVUFBTWt0QixZQUFZLEdBQUcsSUFBSWx0QixLQUFKLEVBQXJCO0FBQ0EsVUFBSTR2QixVQUF3QixHQUFHLEVBQS9COztBQUNBLFVBQUk1QyxTQUFTLEdBQUcsS0FBS0MsVUFBTCxFQUFoQjs7QUFFQSxVQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDWixlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFJbEMsSUFBMEMsR0FBRztBQUM3Qy9aLGFBQUssRUFBRWljLFNBQVMsQ0FBQ2pjLEtBRDRCO0FBRTdDemdCLFdBQUcsRUFBRTA4QixTQUFTLENBQUMxOEI7QUFGOEIsT0FBakQ7QUFJQTQ4QixrQkFBWSxDQUFDcGdDLElBQWIsQ0FBa0JnK0IsSUFBbEI7QUFFQUEsVUFBSSxHQUFHLEtBQUsrRSxjQUFMLENBQW9CL0UsSUFBcEIsRUFBMEJ4NEIsTUFBMUIsRUFBa0M0NkIsWUFBbEMsQ0FBUDs7QUFFQSxVQUFJLENBQUNwQyxJQUFMLEVBQVc7QUFDUCxlQUFPLElBQVA7QUFDSDs7QUFFREEsVUFBSSxHQUFHLEtBQUtnRixRQUFMLENBQWNoRixJQUFJLENBQUN4NkIsR0FBbkIsRUFBd0IsS0FBeEIsQ0FBUDs7QUFFQSxVQUFJLENBQUN3NkIsSUFBTCxFQUFXO0FBQ1AsZUFBTyxJQUFQO0FBQ0g7O0FBRURvQyxrQkFBWSxDQUFDcGdDLElBQWIsQ0FBa0JnK0IsSUFBbEIsRUE5QjJFLENBZ0MzRTs7QUFDQSxVQUFJLENBQUMsS0FBS2lGLFNBQUwsQ0FBZXo5QixNQUFmLENBQUwsRUFBNkI7QUFDekIsZUFBTyxJQUFQO0FBQ0gsT0FuQzBFLENBcUMzRTs7O0FBQ0EsVUFBSSxLQUFLcTRCLFdBQUwsQ0FBaUJqaUMsTUFBakIsR0FBMEIsQ0FBOUIsRUFBaUM7QUFDN0IsWUFBTXNuQyxVQUFVLEdBQUcsS0FBS0MsaUJBQUwsQ0FBdUJuRixJQUFJLENBQUN4NkIsR0FBNUIsQ0FBbkIsQ0FENkIsQ0FFN0I7OztBQUNBLFlBQUksQ0FBQzAvQixVQUFMLEVBQWlCO0FBQ2IsaUJBQU8sSUFBUDtBQUNIOztBQUVELFlBQUksQ0FBQ0EsVUFBVSxDQUFDOUMsWUFBaEIsRUFBOEI7QUFDMUIsaUJBQU8sSUFBUDtBQUNIOztBQUVELFlBQU1nRCxRQUFRLEdBQUdGLFVBQVUsQ0FBQzlDLFlBQVgsQ0FBd0I4QyxVQUFVLENBQUM5QyxZQUFYLENBQXdCeGtDLE1BQXhCLEdBQWlDLENBQXpELENBQWpCO0FBQ0EsWUFBTXdsQyxPQUFPLEdBQUc7QUFDWm5kLGVBQUssRUFBRW1mLFFBQVEsQ0FBQ25mLEtBQVQsSUFBbUIsQ0FBQ21mLFFBQVEsQ0FBQzUvQixHQUFULEdBQWU0L0IsUUFBUSxDQUFDbmYsS0FBekIsSUFBa0MsQ0FBbkMsR0FBd0MsQ0FBMUQsQ0FESztBQUVaemdCLGFBQUcsRUFBRTQvQixRQUFRLENBQUM1L0I7QUFGRixTQUFoQjs7QUFLQSxZQUFJLENBQUMsS0FBSzI5Qix5QkFBTCxDQUErQkMsT0FBL0IsQ0FBTCxFQUE4QztBQUMxQyxpQkFBTyxJQUFQO0FBQ0g7O0FBRUQwQixrQkFBVSxHQUFHO0FBQ1RJLG9CQUFVLEVBQVZBLFVBRFM7QUFFVGxGLGNBQUksRUFBRXg0QixNQUFNLENBQUN3SyxJQUFQLENBQVksRUFBWixJQUFrQmt6QixVQUFVLENBQUNsRjtBQUYxQixTQUFiO0FBSUg7O0FBRUQ7QUFDSUEsWUFBSSxFQUFFeDRCLE1BQU0sQ0FBQ3dLLElBQVAsQ0FBWSxFQUFaLENBRFY7QUFFSWlVLGFBQUssRUFBRWljLFNBQVMsQ0FBQ2pjLEtBRnJCO0FBR0l6Z0IsV0FBRyxFQUFFdzZCLElBQUksQ0FBQ3g2QixHQUhkO0FBSUkwOEIsaUJBQVMsRUFBVEEsU0FKSjtBQUtJRSxvQkFBWSxFQUFaQTtBQUxKLFNBTU8wQyxVQU5QO0FBT0lqRSxjQUFNLEVBQUUsS0FBS0M7QUFQakI7QUFTSDs7OztFQXZXbUJyQixjOztBQTBXVHVFLG1FQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5WUE7QUFDQTtBQUVBLElBQU1xQixnQkFBZ0IsR0FBRyw4Q0FBekI7QUFDQSxJQUFNQyxRQUFRLEdBQUcsSUFBSUMsV0FBSixDQUFnQiw0QkFBSUYsZ0JBQUosRUFBc0J2cEIsR0FBdEIsQ0FBMEIsVUFBQTBwQixLQUFJO0FBQUEsU0FBSUEsS0FBSSxDQUFDM0osVUFBTCxDQUFnQixDQUFoQixDQUFKO0FBQUEsQ0FBOUIsQ0FBaEIsQ0FBakI7QUFDQSxJQUFNNEosbUJBQW1CLEdBQUcsSUFBSUYsV0FBSixDQUFnQixDQUN4QyxLQUR3QyxFQUNqQyxLQURpQyxFQUMxQixLQUQwQixFQUNuQixLQURtQixFQUNaLEtBRFksRUFDTCxLQURLLEVBQ0UsS0FERixFQUNTLEtBRFQsRUFDZ0IsS0FEaEIsRUFDdUIsS0FEdkIsRUFDOEIsS0FEOUIsRUFDcUMsS0FEckMsRUFFeEMsS0FGd0MsRUFFakMsS0FGaUMsRUFFMUIsS0FGMEIsRUFFbkIsS0FGbUIsRUFFWixLQUZZLEVBRUwsS0FGSyxFQUVFLEtBRkYsRUFFUyxLQUZULEVBRWdCLEtBRmhCLEVBRXVCLEtBRnZCLEVBRThCLEtBRjlCLEVBRXFDLEtBRnJDLEVBRTRDLEtBRjVDLEVBRW1ELEtBRm5ELEVBRTBELEtBRjFELEVBRWlFLEtBRmpFLEVBR3hDLEtBSHdDLEVBR2pDLEtBSGlDLEVBRzFCLEtBSDBCLEVBR25CLEtBSG1CLEVBR1osS0FIWSxFQUdMLEtBSEssRUFHRSxLQUhGLEVBR1MsS0FIVCxFQUdnQixLQUhoQixFQUd1QixLQUh2QixFQUc4QixLQUg5QixFQUdxQyxLQUhyQyxFQUc0QyxLQUg1QyxFQUdtRCxLQUhuRCxFQUcwRCxLQUgxRCxFQUdpRSxLQUhqRSxDQUFoQixDQUE1QjtBQUtBLElBQU1HLFFBQVEsR0FBRyxLQUFqQjs7SUFFTUMsMkI7Ozs7Ozs7Ozs7Ozs7Ozs7K0VBQ08sUzs7Ozs7OztpQ0FFSTtBQUNULFVBQU01NkIsTUFBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixDQUFmOztBQUNBLFVBQUk4RixZQUFZLEdBQUc3NkIsTUFBbkI7QUFDQSxVQUFNZzFCLE9BQU8sR0FBRyxJQUFJd0YsV0FBSixDQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLENBQWhCLENBQWhCO0FBQ0EsVUFBSXJFLFVBQVUsR0FBRyxDQUFqQjtBQUNBLFVBQUlGLE9BQU8sR0FBRyxLQUFkOztBQUVBLFdBQUssSUFBSXJqQyxDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUksS0FBS21pQyxJQUFMLENBQVVuaUMsQ0FBVixLQUFnQnFqQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQTlCLENBQUosRUFBc0M7QUFDbENqQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSUEsVUFBVSxLQUFLbkIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBcEMsRUFBdUM7QUFDbkM7QUFDQSxnQkFBSSxLQUFLaW9DLFVBQUwsQ0FBZ0I5RixPQUFoQixNQUE2QjJGLFFBQWpDLEVBQTJDO0FBQ3ZDLGtCQUFNSSxtQkFBbUIsR0FBRzNqQyxJQUFJLENBQUNyQyxLQUFMLENBQVdxQyxJQUFJLENBQUN2QyxHQUFMLENBQVMsQ0FBVCxFQUFZZ21DLFlBQVksR0FBSSxDQUFDam9DLENBQUMsR0FBR2lvQyxZQUFMLElBQXFCLENBQWpELENBQVgsQ0FBNUI7O0FBQ0Esa0JBQUksS0FBS3RDLFdBQUwsQ0FBaUJ3QyxtQkFBakIsRUFBc0NGLFlBQXRDLEVBQW9ELENBQXBELENBQUosRUFBNEQ7QUFDeEQsdUJBQU87QUFDSDNmLHVCQUFLLEVBQUUyZixZQURKO0FBRUhwZ0MscUJBQUcsRUFBRTdIO0FBRkYsaUJBQVA7QUFJSDtBQUNKOztBQUVEaW9DLHdCQUFZLElBQUk3RixPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFBLE9BQU8sQ0FBQyxDQUFELENBQXBDOztBQUNBLGlCQUFLLElBQUkveEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFwQixFQUF1QkEsQ0FBQyxFQUF4QixFQUE0QjtBQUN4Qit4QixxQkFBTyxDQUFDL3hCLENBQUQsQ0FBUCxHQUFhK3hCLE9BQU8sQ0FBQy94QixDQUFDLEdBQUcsQ0FBTCxDQUFwQjtBQUNIOztBQUNEK3hCLG1CQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWEsQ0FBYjtBQUNBQSxtQkFBTyxDQUFDLENBQUQsQ0FBUCxHQUFhLENBQWI7QUFDQW1CLHNCQUFVO0FBQ2IsV0FuQkQsTUFtQk87QUFDSEEsc0JBQVU7QUFDYjs7QUFDRG5CLGlCQUFPLENBQUNtQixVQUFELENBQVAsR0FBc0IsQ0FBdEI7QUFDQUYsaUJBQU8sR0FBRyxDQUFDQSxPQUFYO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLElBQVA7QUFDSDs7OytCQUVVQyxRLEVBQXVCO0FBQzlCLFVBQU1FLFdBQVcsR0FBR0YsUUFBUSxDQUFDcmpDLE1BQTdCO0FBQ0EsVUFBSW1vQyxjQUFjLEdBQUcsQ0FBckI7QUFDQSxVQUFJQyxXQUFXLEdBQUc3RSxXQUFsQjtBQUNBLFVBQUk4RSxZQUFZLEdBQUcsQ0FBbkI7O0FBRUEsYUFBT0QsV0FBVyxHQUFHLENBQXJCLEVBQXdCO0FBQ3BCRCxzQkFBYyxHQUFHLEtBQUtHLGNBQUwsQ0FBb0JqRixRQUFwQixFQUE4QjhFLGNBQTlCLENBQWpCO0FBQ0FDLG1CQUFXLEdBQUcsQ0FBZDtBQUNBLFlBQUkvVyxPQUFPLEdBQUcsQ0FBZDs7QUFDQSxhQUFLLElBQUl0eEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dqQyxXQUFwQixFQUFpQ3hqQyxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDLGNBQUlzakMsUUFBUSxDQUFDdGpDLENBQUQsQ0FBUixHQUFjb29DLGNBQWxCLEVBQWtDO0FBQzlCOVcsbUJBQU8sSUFBSSxLQUFNa1MsV0FBVyxHQUFHLENBQWQsR0FBa0J4akMsQ0FBbkM7QUFDQXFvQyx1QkFBVztBQUNYQyx3QkFBWSxJQUFJaEYsUUFBUSxDQUFDdGpDLENBQUQsQ0FBeEI7QUFDSDtBQUNKOztBQUVELFlBQUlxb0MsV0FBVyxLQUFLLENBQXBCLEVBQXVCO0FBQ25CLGVBQUssSUFBSXJvQyxFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxHQUFHd2pDLFdBQUosSUFBbUI2RSxXQUFXLEdBQUcsQ0FBakQsRUFBb0Ryb0MsRUFBQyxFQUFyRCxFQUF5RDtBQUNyRCxnQkFBSXNqQyxRQUFRLENBQUN0akMsRUFBRCxDQUFSLEdBQWNvb0MsY0FBbEIsRUFBa0M7QUFDOUJDLHlCQUFXOztBQUNYLGtCQUFLL0UsUUFBUSxDQUFDdGpDLEVBQUQsQ0FBUixHQUFjLENBQWYsSUFBcUJzb0MsWUFBekIsRUFBdUM7QUFDbkMsdUJBQU8sQ0FBQyxDQUFSO0FBQ0g7QUFDSjtBQUNKOztBQUNELGlCQUFPaFgsT0FBUDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxDQUFDLENBQVI7QUFDSDs7O21DQUVjZ1MsUSxFQUF1QjVzQixPLEVBQWlCO0FBQ25ELFVBQUk4eEIsUUFBUSxHQUFHaDhCLE1BQU0sQ0FBQ0MsU0FBdEI7O0FBRUEsV0FBSyxJQUFJek0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NqQyxRQUFRLENBQUNyakMsTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsWUFBSXNqQyxRQUFRLENBQUN0akMsQ0FBRCxDQUFSLEdBQWN3b0MsUUFBZCxJQUEwQmxGLFFBQVEsQ0FBQ3RqQyxDQUFELENBQVIsR0FBYzBXLE9BQTVDLEVBQXFEO0FBQ2pEOHhCLGtCQUFRLEdBQUdsRixRQUFRLENBQUN0akMsQ0FBRCxDQUFuQjtBQUNIO0FBQ0o7O0FBRUQsYUFBT3dvQyxRQUFQO0FBQ0g7OzttQ0FFY2xYLE8sRUFBaUI7QUFDNUIsV0FBSyxJQUFJdHhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4bkMsbUJBQW1CLENBQUM3bkMsTUFBeEMsRUFBZ0RELENBQUMsRUFBakQsRUFBcUQ7QUFDakQsWUFBSThuQyxtQkFBbUIsQ0FBQzluQyxDQUFELENBQW5CLEtBQTJCc3hCLE9BQS9CLEVBQXdDO0FBQ3BDLGlCQUFPK0UsTUFBTSxDQUFDaVAsWUFBUCxDQUFvQnFDLFFBQVEsQ0FBQzNuQyxDQUFELENBQTVCLENBQVA7QUFDSDtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7OENBRXlCeW9DLFMsRUFBbUJDLFMsRUFBbUJwRixRLEVBQXVCO0FBQ25GLFVBQU1xRixXQUFXLEdBQUduZ0MsK0JBQVcsQ0FBQ2pFLEdBQVosQ0FBZ0IrK0IsUUFBaEIsQ0FBcEI7QUFFQSxVQUFNb0MscUJBQXFCLEdBQUdnRCxTQUFTLEdBQUdELFNBQVosR0FBd0JFLFdBQXREOztBQUNBLFVBQUtqRCxxQkFBcUIsR0FBRyxDQUF6QixJQUErQmlELFdBQW5DLEVBQWdEO0FBQzVDLGVBQU8sSUFBUDtBQUNIOztBQUNELGFBQU8sS0FBUDtBQUNIOzs7NEJBRU92MEIsRyxFQUFxQmtVLEssRUFBeUQ7QUFDbEYsVUFBSWdiLFFBQVEsR0FBRyxJQUFJc0UsV0FBSixDQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLENBQWhCLENBQWY7QUFDQSxVQUFNLzlCLE1BQXFCLEdBQUcsRUFBOUI7QUFDQXllLFdBQUssR0FBRyxLQUFLa2MsVUFBTCxFQUFSOztBQUVBLFVBQUksQ0FBQ2xjLEtBQUwsRUFBWTtBQUNSLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQUlvZ0IsU0FBUyxHQUFHLEtBQUt0RSxRQUFMLENBQWMsS0FBS2pDLElBQW5CLEVBQXlCN1osS0FBSyxDQUFDemdCLEdBQS9CLENBQWhCOztBQUVBLFVBQUkrZ0MsV0FBSjtBQUNBLFVBQUlILFNBQUo7O0FBQ0EsU0FBRztBQUNDbkYsZ0JBQVEsR0FBRyxLQUFLdUYsV0FBTCxDQUFpQkgsU0FBakIsRUFBNEJwRixRQUE1QixDQUFYOztBQUNBLFlBQU1oUyxPQUFPLEdBQUcsS0FBSzRXLFVBQUwsQ0FBZ0I1RSxRQUFoQixDQUFoQjs7QUFDQSxZQUFJaFMsT0FBTyxHQUFHLENBQWQsRUFBaUI7QUFDYixpQkFBTyxJQUFQO0FBQ0g7O0FBQ0RzWCxtQkFBVyxHQUFHLEtBQUtFLGNBQUwsQ0FBb0J4WCxPQUFwQixDQUFkOztBQUNBLFlBQUlzWCxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDdEIsaUJBQU8sSUFBUDtBQUNIOztBQUNELytCLGNBQU0sQ0FBQ3hGLElBQVAsQ0FBWXVrQyxXQUFaO0FBQ0FILGlCQUFTLEdBQUdDLFNBQVo7QUFDQUEsaUJBQVMsSUFBSWxnQywrQkFBVyxDQUFDakUsR0FBWixDQUFnQisrQixRQUFoQixDQUFiO0FBQ0FvRixpQkFBUyxHQUFHLEtBQUt0RSxRQUFMLENBQWMsS0FBS2pDLElBQW5CLEVBQXlCdUcsU0FBekIsQ0FBWjtBQUNILE9BZEQsUUFjU0UsV0FBVyxLQUFLLEdBZHpCOztBQWVBLytCLFlBQU0sQ0FBQzZtQixHQUFQOztBQUVBLFVBQUksQ0FBQzdtQixNQUFNLENBQUM1SixNQUFaLEVBQW9CO0FBQ2hCLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQUksQ0FBQyxLQUFLdWxDLHlCQUFMLENBQStCaUQsU0FBL0IsRUFBMENDLFNBQTFDLEVBQXFEcEYsUUFBckQsQ0FBTCxFQUFxRTtBQUNqRSxlQUFPLElBQVA7QUFDSDs7QUFFRCxhQUFPO0FBQ0hqQixZQUFJLEVBQUV4NEIsTUFBTSxDQUFDd0ssSUFBUCxDQUFZLEVBQVosQ0FESDtBQUVIaVUsYUFBSyxFQUFFQSxLQUFLLENBQUNBLEtBRlY7QUFHSHpnQixXQUFHLEVBQUU2Z0MsU0FIRjtBQUlIbkUsaUJBQVMsRUFBRWpjLEtBSlI7QUFLSG1jLG9CQUFZLEVBQUU1NkIsTUFMWDtBQU1IcTVCLGNBQU0sRUFBRSxLQUFLQztBQU5WLE9BQVA7QUFTSDs7OztFQXpKc0JyQixjOztBQTRKWmtHLDhFQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4S0E7QUFHQSxJQUFNZSxRQUFRLEdBQUc7QUFDYkMsS0FBRyxFQUFFLFFBRFE7QUFFYkMsTUFBSSxFQUFFO0FBRk8sQ0FBakI7O0lBS01DLGtDOzs7Ozs7Ozs7Ozs7Ozs7OytFQUNPLGE7Ozs7Ozs7QUFFVDttQ0FDZTdHLEksRUFBYztBQUN6QixhQUFPLENBQUMsQ0FBQ0EsSUFBVDtBQUNILEssQ0FFRDtBQUNBOzs7OzRCQUNRanVCLEcsRUFBcUJrVSxLLEVBQXlDO0FBQ2xFLFVBQU16ZSxNQUFNLEdBQUcsK0ZBQWN1SyxHQUFqQixFQUFzQmtVLEtBQXRCLENBQVo7O0FBQ0EsVUFBSSxDQUFDemUsTUFBTCxFQUFhO0FBQ1QsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSXc0QixJQUFJLEdBQUd4NEIsTUFBTSxDQUFDdzRCLElBQWxCOztBQUVBLFVBQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1AsZUFBTyxJQUFQO0FBQ0g7O0FBRURBLFVBQUksR0FBR0EsSUFBSSxDQUFDaFIsT0FBTCxDQUFhMFgsUUFBUSxDQUFDQyxHQUF0QixFQUEyQixFQUEzQixDQUFQOztBQUVBLFVBQUksQ0FBQzNHLElBQUksQ0FBQzkzQixLQUFMLENBQVd3K0IsUUFBUSxDQUFDRSxJQUFwQixDQUFMLEVBQWdDO0FBQzVCLFlBQUl2dEIsSUFBSixFQUFxQjtBQUNqQjJFLGlCQUFPLENBQUNDLEdBQVIsQ0FBWSwyQkFBWixFQUF5QytoQixJQUF6QztBQUNIOztBQUNELGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQUksQ0FBQyxLQUFLOEcsY0FBTCxDQUFvQjlHLElBQXBCLENBQUwsRUFBZ0M7QUFDNUIsZUFBTyxJQUFQO0FBQ0g7O0FBRUR4NEIsWUFBTSxDQUFDdzRCLElBQVAsR0FBY0EsSUFBZDtBQUNBLGFBQU94NEIsTUFBUDtBQUNIOzs7O0VBckN5Qm0rQixjOztBQXdDZmtCLHlGQUFmLEU7Ozs7Ozs7Ozs7Ozs7O0NDOUNBOztBQUNBLElBQU12Qix1QkFBUSxHQUFHLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsRUFBYixFQUFpQixFQUFqQixFQUFxQixFQUFyQixFQUF5QixFQUF6QixFQUE2QixFQUE3QixFQUFpQyxFQUFqQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxFQUE2QyxFQUE3QyxFQUFpRCxFQUFqRCxFQUFxRCxFQUFyRCxFQUF5RCxFQUF6RCxFQUE2RCxFQUE3RCxFQUFpRSxFQUFqRSxFQUFxRSxFQUFyRSxFQUF5RSxFQUF6RSxFQUE2RSxFQUE3RSxDQUFqQjtBQUNBLElBQU1HLGtDQUFtQixHQUNyQixDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsS0FBZixFQUFzQixLQUF0QixFQUE2QixLQUE3QixFQUFvQyxLQUFwQyxFQUEyQyxLQUEzQyxFQUFrRCxLQUFsRCxFQUF5RCxLQUF6RCxFQUFnRSxLQUFoRSxFQUF1RSxLQUF2RSxFQUE4RSxLQUE5RSxFQUNJLEtBREosRUFDVyxLQURYLEVBQ2tCLEtBRGxCLEVBQ3lCLEtBRHpCLEVBQ2dDLEtBRGhDLEVBQ3VDLEtBRHZDLEVBQzhDLEtBRDlDLEVBQ3FELEtBRHJELENBREo7QUFHQSxJQUFNc0IsU0FBUyxHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLENBQWxCO0FBQ0EsSUFBTUMsaUJBQWlCLEdBQUcsQ0FBMUI7QUFDQSxJQUFNQyxjQUFjLEdBQUcsR0FBdkI7QUFDQSxJQUFNQyxPQUFPLEdBQUcsR0FBaEI7QUFPQztBQVdBOztJQUVLQywrQjs7Ozs7Ozs7Ozs7Ozs7OztrRkFDeUIsRTs7K0VBQ2xCLFM7Ozs7Ozs7aURBRW9CcDhCLE0sRUFBZ0J2RixHLEVBQWE7QUFDdEQsVUFBSTdGLEdBQUcsR0FBR3dLLE1BQU0sQ0FBQ0MsU0FBakI7QUFDQSxVQUFJeEssR0FBRyxHQUFHLENBQVY7QUFDQSxVQUFJbWdDLE9BQU8sR0FBRyxDQUFkOztBQUVBLFdBQUssSUFBSXBpQyxDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHNkgsR0FBekIsRUFBOEI3SCxDQUFDLElBQUksQ0FBbkMsRUFBc0M7QUFDbENvaUMsZUFBTyxHQUFHLEtBQUtxSCxTQUFMLENBQWV6cEMsQ0FBZixDQUFWOztBQUNBLFlBQUlvaUMsT0FBTyxHQUFHbmdDLEdBQWQsRUFBbUI7QUFDZkEsYUFBRyxHQUFHbWdDLE9BQU47QUFDSDs7QUFDRCxZQUFJQSxPQUFPLEdBQUdwZ0MsR0FBZCxFQUFtQjtBQUNmQSxhQUFHLEdBQUdvZ0MsT0FBTjtBQUNIO0FBQ0o7O0FBRUQsYUFBUSxDQUFDcGdDLEdBQUcsR0FBR0MsR0FBUCxJQUFjLEdBQWYsR0FBc0IsQ0FBN0I7QUFDSDs7OytCQUVVbUwsTSxFQUFnQjtBQUN2QixVQUFNbzJCLFdBQVcsR0FBRyxDQUFwQjtBQUNBLFVBQU0zN0IsR0FBRyxHQUFHdUYsTUFBTSxHQUFHbzJCLFdBQXJCOztBQUVBLFVBQUkzN0IsR0FBRyxHQUFHLEtBQUs0aEMsU0FBTCxDQUFleHBDLE1BQXpCLEVBQWlDO0FBQzdCLGVBQU8sQ0FBQyxDQUFSO0FBQ0g7O0FBRUQsVUFBTXlwQyxZQUFZLEdBQUcsS0FBS0MsNEJBQUwsQ0FBa0N2OEIsTUFBbEMsRUFBMEN2RixHQUExQyxDQUFyQjs7QUFDQSxVQUFNK2hDLGNBQWMsR0FBRyxLQUFLRCw0QkFBTCxDQUFrQ3Y4QixNQUFNLEdBQUcsQ0FBM0MsRUFBOEN2RixHQUE5QyxDQUF2Qjs7QUFFQSxVQUFJZ2lDLE9BQU8sR0FBRyxLQUFNckcsV0FBVyxHQUFHLENBQWxDO0FBQ0EsVUFBSTMvQixTQUFTLEdBQUcsQ0FBaEI7QUFDQSxVQUFJeXRCLE9BQU8sR0FBRyxDQUFkOztBQUVBLFdBQUssSUFBSXR4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHd2pDLFdBQXBCLEVBQWlDeGpDLENBQUMsRUFBbEMsRUFBc0M7QUFDbEM2RCxpQkFBUyxHQUFHLENBQUM3RCxDQUFDLEdBQUcsQ0FBTCxNQUFZLENBQVosR0FBZ0IwcEMsWUFBaEIsR0FBK0JFLGNBQTNDOztBQUNBLFlBQUksS0FBS0gsU0FBTCxDQUFlcjhCLE1BQU0sR0FBR3BOLENBQXhCLElBQTZCNkQsU0FBakMsRUFBNEM7QUFDeEN5dEIsaUJBQU8sSUFBSXVZLE9BQVg7QUFDSDs7QUFDREEsZUFBTyxLQUFLLENBQVo7QUFDSDs7QUFFRCxhQUFPdlksT0FBUDtBQUNIOzs7Z0NBRVdBLE8sRUFBaUI7QUFDekIsV0FBSyxJQUFJdHhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvcEMsU0FBUyxDQUFDbnBDLE1BQTlCLEVBQXNDRCxDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLFlBQUlvcEMsU0FBUyxDQUFDcHBDLENBQUQsQ0FBVCxLQUFpQnN4QixPQUFyQixFQUE4QjtBQUMxQixpQkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLEtBQVA7QUFDSDs7O2lDQUVZaEosSyxFQUFlemdCLEcsRUFBYTtBQUNyQyxVQUFJdEQsR0FBRyxHQUFHLENBQVY7O0FBRUEsV0FBSyxJQUFJdkUsQ0FBQyxHQUFHc29CLEtBQWIsRUFBb0J0b0IsQ0FBQyxHQUFHNkgsR0FBeEIsRUFBNkI3SCxDQUFDLEVBQTlCLEVBQWtDO0FBQzlCdUUsV0FBRyxJQUFJLEtBQUtrbEMsU0FBTCxDQUFlenBDLENBQWYsQ0FBUDtBQUNIOztBQUNELGFBQU91RSxHQUFQO0FBQ0g7OztpQ0FFb0M7QUFDakMsVUFBSStqQixLQUFLLEdBQUcsS0FBSzhhLFVBQUwsQ0FBZ0IsS0FBS2pCLElBQXJCLENBQVo7O0FBQ0EsVUFBSXQ2QixHQUFHLEdBQUd5Z0IsS0FBVjs7QUFFQSxXQUFLLElBQUl0b0IsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLeXBDLFNBQUwsQ0FBZXhwQyxNQUFuQyxFQUEyQ0QsQ0FBQyxFQUE1QyxFQUFnRDtBQUM1QyxZQUFNc3hCLE9BQU8sR0FBRyxLQUFLNFcsVUFBTCxDQUFnQmxvQyxDQUFoQixDQUFoQjs7QUFDQSxZQUFJc3hCLE9BQU8sS0FBSyxDQUFDLENBQWIsSUFBa0IsS0FBS3dZLFdBQUwsQ0FBaUJ4WSxPQUFqQixDQUF0QixFQUFpRDtBQUM3QztBQUNBaEosZUFBSyxJQUFJLEtBQUt5aEIsWUFBTCxDQUFrQixDQUFsQixFQUFxQi9wQyxDQUFyQixDQUFUO0FBQ0E2SCxhQUFHLEdBQUd5Z0IsS0FBSyxHQUFHLEtBQUt5aEIsWUFBTCxDQUFrQi9wQyxDQUFsQixFQUFxQkEsQ0FBQyxHQUFHLENBQXpCLENBQWQ7QUFDQSxpQkFBTztBQUNIc29CLGlCQUFLLEVBQUVBLEtBREo7QUFFSHpnQixlQUFHLEVBQUVBLEdBRkY7QUFHSG1pQyx3QkFBWSxFQUFFaHFDLENBSFg7QUFJSGlxQyxzQkFBVSxFQUFFanFDLENBQUMsR0FBRztBQUpiLFdBQVA7QUFNSDtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7bUNBRWNzeEIsTyxFQUFpQjtBQUM1QixXQUFLLElBQUl0eEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhuQyxrQ0FBbUIsQ0FBQzduQyxNQUF4QyxFQUFnREQsQ0FBQyxFQUFqRCxFQUFxRDtBQUNqRCxZQUFJOG5DLGtDQUFtQixDQUFDOW5DLENBQUQsQ0FBbkIsS0FBMkJzeEIsT0FBL0IsRUFBd0M7QUFDcEMsaUJBQU8rRSxNQUFNLENBQUNpUCxZQUFQLENBQW9CcUMsdUJBQVEsQ0FBQzNuQyxDQUFELENBQTVCLENBQVA7QUFDSDtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7NENBRXVCb04sTSxFQUFnQjtBQUNwQyxVQUFJN0ksR0FBRyxHQUFHLENBQVY7O0FBRUEsV0FBSyxJQUFJdkUsQ0FBQyxHQUFHb04sTUFBYixFQUFxQnBOLENBQUMsR0FBR29OLE1BQU0sR0FBRyxDQUFsQyxFQUFxQ3BOLENBQUMsRUFBdEMsRUFBMEM7QUFDdEN1RSxXQUFHLElBQUksS0FBS2tsQyxTQUFMLENBQWV6cEMsQ0FBZixDQUFQO0FBQ0g7O0FBRUQsYUFBT3VFLEdBQVA7QUFDSDs7O3NDQUVpQnlsQyxZLEVBQXNCQyxVLEVBQW9CO0FBQ3hELFVBQUtELFlBQVksR0FBRyxDQUFmLElBQW9CLENBQXJCLElBQ0csS0FBS1AsU0FBTCxDQUFlTyxZQUFZLEdBQUcsQ0FBOUIsS0FBcUMsS0FBS0UsdUJBQUwsQ0FBNkJGLFlBQTdCLElBQTZDLEdBRHpGLEVBQytGO0FBQzNGLFlBQUtDLFVBQVUsR0FBRyxDQUFiLElBQWtCLEtBQUtSLFNBQUwsQ0FBZXhwQyxNQUFsQyxJQUNHLEtBQUt3cEMsU0FBTCxDQUFlUSxVQUFVLEdBQUcsQ0FBNUIsS0FBbUMsS0FBS0MsdUJBQUwsQ0FBNkJELFVBQTdCLElBQTJDLEdBRHJGLEVBQzJGO0FBQ3ZGLGlCQUFPLElBQVA7QUFDSDtBQUNKOztBQUNELGFBQU8sS0FBUDtBQUNIOzs7bUNBRWNwQyxLLEVBQWM7QUFDekIsVUFBTXNDLFFBQVEsR0FBR3RDLEtBQUksQ0FBQzNKLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBakI7O0FBRUEsV0FBSyxJQUFJbCtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcybkMsdUJBQVEsQ0FBQzFuQyxNQUE3QixFQUFxQ0QsQ0FBQyxFQUF0QyxFQUEwQztBQUN0QyxZQUFJMm5DLHVCQUFRLENBQUMzbkMsQ0FBRCxDQUFSLEtBQWdCbXFDLFFBQXBCLEVBQThCO0FBQzFCLGlCQUFPckMsa0NBQW1CLENBQUM5bkMsQ0FBRCxDQUExQjtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxHQUFQO0FBQ0g7Ozs0Q0FFdUI2SixNLEVBQStCbWdDLFksRUFBc0I7QUFDekUsVUFBTUksY0FBeUIsR0FBRztBQUMxQnpHLGFBQUssRUFBRTtBQUNIMEcsZ0JBQU0sRUFBRTtBQUFFamtDLGdCQUFJLEVBQUUsQ0FBUjtBQUFXa2tDLGtCQUFNLEVBQUUsQ0FBbkI7QUFBc0J0b0MsZUFBRyxFQUFFLENBQTNCO0FBQThCQyxlQUFHLEVBQUV1SyxNQUFNLENBQUNDO0FBQTFDLFdBREw7QUFFSDg5QixjQUFJLEVBQUU7QUFBRW5rQyxnQkFBSSxFQUFFLENBQVI7QUFBV2trQyxrQkFBTSxFQUFFLENBQW5CO0FBQXNCdG9DLGVBQUcsRUFBRSxDQUEzQjtBQUE4QkMsZUFBRyxFQUFFdUssTUFBTSxDQUFDQztBQUExQztBQUZILFNBRG1CO0FBSzFCaTNCLFdBQUcsRUFBRTtBQUNEMkcsZ0JBQU0sRUFBRTtBQUFFamtDLGdCQUFJLEVBQUUsQ0FBUjtBQUFXa2tDLGtCQUFNLEVBQUUsQ0FBbkI7QUFBc0J0b0MsZUFBRyxFQUFFLENBQTNCO0FBQThCQyxlQUFHLEVBQUV1SyxNQUFNLENBQUNDO0FBQTFDLFdBRFA7QUFFRDg5QixjQUFJLEVBQUU7QUFBRW5rQyxnQkFBSSxFQUFFLENBQVI7QUFBV2trQyxrQkFBTSxFQUFFLENBQW5CO0FBQXNCdG9DLGVBQUcsRUFBRSxDQUEzQjtBQUE4QkMsZUFBRyxFQUFFdUssTUFBTSxDQUFDQztBQUExQztBQUZMO0FBTHFCLE9BQWxDO0FBVUEsVUFBSWpDLEdBQUcsR0FBR3cvQixZQUFWO0FBQ0EsVUFBSTFZLE9BQUo7O0FBRUEsV0FBSyxJQUFJdHhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2SixNQUFNLENBQUM1SixNQUEzQixFQUFtQ0QsQ0FBQyxFQUFwQyxFQUF3QztBQUNwQ3N4QixlQUFPLEdBQUcsS0FBS2taLGNBQUwsQ0FBb0IzZ0MsTUFBTSxDQUFDN0osQ0FBRCxDQUExQixDQUFWOztBQUNBLGFBQUssSUFBSXFRLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLElBQUksQ0FBckIsRUFBd0JBLENBQUMsRUFBekIsRUFBNkI7QUFDekIsY0FBTW82QixJQUFJLEdBQUcsQ0FBQ3A2QixDQUFDLEdBQUcsQ0FBTCxNQUFZLENBQVosR0FBZ0IrNUIsY0FBYyxDQUFDMUcsR0FBL0IsR0FBcUMwRyxjQUFjLENBQUN6RyxLQUFqRTtBQUNBLGNBQU0rRyxHQUFHLEdBQUcsQ0FBQ3BaLE9BQU8sR0FBRyxDQUFYLE1BQWtCLENBQWxCLEdBQXNCbVosSUFBSSxDQUFDRixJQUEzQixHQUFrQ0UsSUFBSSxDQUFDSixNQUFuRDtBQUNBSyxhQUFHLENBQUN0a0MsSUFBSixJQUFZLEtBQUtxakMsU0FBTCxDQUFlai9CLEdBQUcsR0FBRzZGLENBQXJCLENBQVo7QUFDQXE2QixhQUFHLENBQUNKLE1BQUo7QUFDQWhaLGlCQUFPLEtBQUssQ0FBWjtBQUNIOztBQUNEOW1CLFdBQUcsSUFBSSxDQUFQO0FBQ0g7O0FBRUEsT0FBQyxPQUFELEVBQVUsS0FBVixDQUFELENBQTRCL0csT0FBNUIsQ0FBb0MsVUFBVWpGLEdBQVYsRUFBZTtBQUMvQyxZQUFNbXNDLE9BQU8sR0FBR1AsY0FBYyxDQUFDNXJDLEdBQUQsQ0FBOUI7QUFDQW1zQyxlQUFPLENBQUNKLElBQVIsQ0FBYXZvQyxHQUFiLEdBQ0l3QyxJQUFJLENBQUNyQyxLQUFMLENBQVcsQ0FBQ3dvQyxPQUFPLENBQUNOLE1BQVIsQ0FBZWprQyxJQUFmLEdBQXNCdWtDLE9BQU8sQ0FBQ04sTUFBUixDQUFlQyxNQUFyQyxHQUE4Q0ssT0FBTyxDQUFDSixJQUFSLENBQWFua0MsSUFBYixHQUFvQnVrQyxPQUFPLENBQUNKLElBQVIsQ0FBYUQsTUFBaEYsSUFBMEYsQ0FBckcsQ0FESjtBQUVBSyxlQUFPLENBQUNOLE1BQVIsQ0FBZXBvQyxHQUFmLEdBQXFCdUMsSUFBSSxDQUFDcEMsSUFBTCxDQUFVdW9DLE9BQU8sQ0FBQ0osSUFBUixDQUFhdm9DLEdBQXZCLENBQXJCO0FBQ0Eyb0MsZUFBTyxDQUFDSixJQUFSLENBQWF0b0MsR0FBYixHQUFtQnVDLElBQUksQ0FBQ3BDLElBQUwsQ0FBVSxDQUFDdW9DLE9BQU8sQ0FBQ0osSUFBUixDQUFhbmtDLElBQWIsR0FBb0JrakMsY0FBcEIsR0FBcUNDLE9BQXRDLElBQWlEb0IsT0FBTyxDQUFDSixJQUFSLENBQWFELE1BQXhFLENBQW5CO0FBQ0gsT0FORDtBQVFBLGFBQU9GLGNBQVA7QUFDSDs7O29DQUVldmdDLE0sRUFBK0JtZ0MsWSxFQUFzQjtBQUNqRSxVQUFNWSxVQUFVLEdBQUcsS0FBS0MsdUJBQUwsQ0FBNkJoaEMsTUFBN0IsRUFBcUNtZ0MsWUFBckMsQ0FBbkI7O0FBQ0EsVUFBSXgvQixHQUFHLEdBQUd3L0IsWUFBVjtBQUNBLFVBQUkxWSxPQUFKOztBQUVBLFdBQUssSUFBSXR4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNkosTUFBTSxDQUFDNUosTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDcENzeEIsZUFBTyxHQUFHLEtBQUtrWixjQUFMLENBQW9CM2dDLE1BQU0sQ0FBQzdKLENBQUQsQ0FBMUIsQ0FBVjs7QUFDQSxhQUFLLElBQUlxUSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxJQUFJLENBQXJCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO0FBQ3pCLGNBQU1vNkIsSUFBSSxHQUFHLENBQUNwNkIsQ0FBQyxHQUFHLENBQUwsTUFBWSxDQUFaLEdBQWdCdTZCLFVBQVUsQ0FBQ2xILEdBQTNCLEdBQWlDa0gsVUFBVSxDQUFDakgsS0FBekQ7QUFDQSxjQUFNK0csR0FBRyxHQUFHLENBQUNwWixPQUFPLEdBQUcsQ0FBWCxNQUFrQixDQUFsQixHQUFzQm1aLElBQUksQ0FBQ0YsSUFBM0IsR0FBa0NFLElBQUksQ0FBQ0osTUFBbkQ7QUFDQSxjQUFNamtDLElBQUksR0FBRyxLQUFLcWpDLFNBQUwsQ0FBZWovQixHQUFHLEdBQUc2RixDQUFyQixDQUFiOztBQUNBLGNBQUlqSyxJQUFJLEdBQUdza0MsR0FBRyxDQUFDMW9DLEdBQVgsSUFBa0JvRSxJQUFJLEdBQUdza0MsR0FBRyxDQUFDem9DLEdBQWpDLEVBQXNDO0FBQ2xDLG1CQUFPLEtBQVA7QUFDSDs7QUFDRHF2QixpQkFBTyxLQUFLLENBQVo7QUFDSDs7QUFDRDltQixXQUFHLElBQUksQ0FBUDtBQUNIOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7NEJBRU80SixHLEVBQXFCa1UsSyxFQUF5RDtBQUVsRixXQUFLbWhCLFNBQUwsR0FBaUIsS0FBS3FCLGFBQUwsRUFBakI7QUFDQXhpQixXQUFLLEdBQUcsS0FBS2tjLFVBQUwsRUFBUjs7QUFDQSxVQUFJLENBQUNsYyxLQUFMLEVBQVk7QUFDUixlQUFPLElBQVA7QUFDSDs7QUFDRCxVQUFJb2dCLFNBQVMsR0FBR3BnQixLQUFLLENBQUMwaEIsWUFBdEI7QUFFQSxVQUFNbmdDLE1BQXFCLEdBQUcsRUFBOUI7QUFDQSxVQUFJeW5CLE9BQUo7O0FBQ0EsU0FBRztBQUNDQSxlQUFPLEdBQUcsS0FBSzRXLFVBQUwsQ0FBZ0JRLFNBQWhCLENBQVY7O0FBQ0EsWUFBSXBYLE9BQU8sR0FBRyxDQUFkLEVBQWlCO0FBQ2IsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQU1zWCxXQUFXLEdBQUcsS0FBS0UsY0FBTCxDQUFvQnhYLE9BQXBCLENBQXBCOztBQUNBLFlBQUlzWCxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDdEIsaUJBQU8sSUFBUDtBQUNIOztBQUNELytCLGNBQU0sQ0FBQ3hGLElBQVAsQ0FBWXVrQyxXQUFaO0FBQ0FGLGlCQUFTLElBQUksQ0FBYjs7QUFDQSxZQUFJNytCLE1BQU0sQ0FBQzVKLE1BQVAsR0FBZ0IsQ0FBaEIsSUFBcUIsS0FBSzZwQyxXQUFMLENBQWlCeFksT0FBakIsQ0FBekIsRUFBb0Q7QUFDaEQ7QUFDSDtBQUNKLE9BZEQsUUFjU29YLFNBQVMsR0FBRyxLQUFLZSxTQUFMLENBQWV4cEMsTUFkcEMsRUFYa0YsQ0EyQmxGOzs7QUFDQSxVQUFLNEosTUFBTSxDQUFDNUosTUFBUCxHQUFnQixDQUFqQixHQUFzQm9wQyxpQkFBdEIsSUFBMkMsQ0FBQyxLQUFLUyxXQUFMLENBQWlCeFksT0FBakIsQ0FBaEQsRUFBMkU7QUFDdkUsZUFBTyxJQUFQO0FBQ0gsT0E5QmlGLENBZ0NsRjs7O0FBQ0EsVUFBSSxDQUFDLEtBQUt5WixpQkFBTCxDQUF1QnppQixLQUFLLENBQUMwaEIsWUFBN0IsRUFBcUR0QixTQUFTLEdBQUcsQ0FBakUsQ0FBTCxFQUEwRTtBQUN0RSxlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFJLENBQUMsS0FBS3NDLGVBQUwsQ0FBcUJuaEMsTUFBckIsRUFBNkJ5ZSxLQUFLLENBQUMwaEIsWUFBbkMsQ0FBTCxFQUFpRTtBQUM3RCxlQUFPLElBQVA7QUFDSDs7QUFFRHRCLGVBQVMsR0FBR0EsU0FBUyxHQUFHLEtBQUtlLFNBQUwsQ0FBZXhwQyxNQUEzQixHQUFvQyxLQUFLd3BDLFNBQUwsQ0FBZXhwQyxNQUFuRCxHQUE0RHlvQyxTQUF4RTs7QUFDQSxVQUFNN2dDLEdBQUcsR0FBR3lnQixLQUFLLENBQUNBLEtBQU4sR0FBYyxLQUFLeWhCLFlBQUwsQ0FBa0J6aEIsS0FBSyxDQUFDMGhCLFlBQXhCLEVBQWdEdEIsU0FBUyxHQUFHLENBQTVELENBQTFCOztBQUVBLGFBQU87QUFDSHJHLFlBQUksRUFBRXg0QixNQUFNLENBQUN3SyxJQUFQLENBQVksRUFBWixDQURIO0FBRUhpVSxhQUFLLEVBQUVBLEtBQUssQ0FBQ0EsS0FGVjtBQUdIemdCLFdBQUcsRUFBRUEsR0FIRjtBQUlIMDhCLGlCQUFTLEVBQUVqYyxLQUpSO0FBS0htYyxvQkFBWSxFQUFFNTZCLE1BTFg7QUFNSHE1QixjQUFNLEVBQUUsS0FBS0MsTUFOVixDQU1rQjs7QUFObEIsT0FBUDtBQVFIOzs7O0VBOU8wQnJCLGM7O0FBaVBoQjBILGtGQUFmLEU7Ozs7Ozs7Ozs7Ozs7O0FDL1FBOztJQUdNeUIsb0I7Ozs7Ozs7Ozs7Ozs7Ozs7K0VBQ08sTzs7Ozs7Ozs0QkFDRDcyQixHLEVBQXFCa1UsSyxFQUFrRDtBQUMzRSxVQUFNemUsTUFBTSxHQUFHdzhCLFVBQVMsQ0FBQy9sQyxTQUFWLENBQW9Cd2lDLE9BQXBCLENBQTRCbmlDLElBQTVCLENBQWlDLElBQWpDLENBQWY7O0FBRUEsVUFBSWtKLE1BQU0sSUFBSUEsTUFBTSxDQUFDdzRCLElBQWpCLElBQXlCeDRCLE1BQU0sQ0FBQ3c0QixJQUFQLENBQVlwaUMsTUFBWixLQUF1QixFQUFoRCxJQUFzRDRKLE1BQU0sQ0FBQ3c0QixJQUFQLENBQVkvRixNQUFaLENBQW1CLENBQW5CLE1BQTBCLEdBQXBGLEVBQXlGO0FBQ3JGenlCLGNBQU0sQ0FBQ3c0QixJQUFQLEdBQWN4NEIsTUFBTSxDQUFDdzRCLElBQVAsQ0FBWTZJLFNBQVosQ0FBc0IsQ0FBdEIsQ0FBZDtBQUNBLGVBQU9yaEMsTUFBUDtBQUNIOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7O0VBVm1CdzhCLFU7O0FBYVQ0RSxtRUFBZixFOzs7Ozs7Ozs7Ozs7OztBQ2hCQTs7SUFHTUUsdUI7Ozs7Ozs7Ozs7Ozs7Ozs7K0VBQ08sTzs7Ozs7OzttQ0FDZ0J0RSxNLEVBQXlCaDlCLE0sRUFBdUI0NkIsWSxFQUEwRDtBQUMvSCxVQUFJcEMsSUFBMEMsR0FBR3dFLE1BQWpEOztBQUVBLFdBQUssSUFBSTdtQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0FBQ3hCcWlDLFlBQUksR0FBRyxLQUFLK0MsV0FBTCxDQUFpQi9DLElBQUksQ0FBQ3g2QixHQUF0QixFQUEyQm0rQixZQUEzQixDQUFQOztBQUNBLFlBQUksQ0FBQzNELElBQUwsRUFBVztBQUNQLGlCQUFPLElBQVA7QUFDSDs7QUFDRHg0QixjQUFNLENBQUN4RixJQUFQLENBQWFnK0IsSUFBRCxDQUFzQkEsSUFBbEM7QUFDQW9DLG9CQUFZLENBQUNwZ0MsSUFBYixDQUFrQmcrQixJQUFsQjtBQUNIOztBQUVEQSxVQUFJLEdBQUcsS0FBS3FFLFlBQUwsQ0FBa0JSLGNBQWxCLEVBQWtDN0QsSUFBSSxDQUFDeDZCLEdBQXZDLEVBQTRDLElBQTVDLEVBQWtELEtBQWxELENBQVA7O0FBQ0EsVUFBSXc2QixJQUFJLEtBQUssSUFBYixFQUFtQjtBQUNmLGVBQU8sSUFBUDtBQUNIOztBQUNEb0Msa0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCZytCLElBQWxCOztBQUVBLFdBQUssSUFBSXJpQyxFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxHQUFHLENBQXBCLEVBQXVCQSxFQUFDLEVBQXhCLEVBQTRCO0FBQ3hCcWlDLFlBQUksR0FBRyxLQUFLK0MsV0FBTCxDQUFpQi9DLElBQUksQ0FBQ3g2QixHQUF0QixFQUEyQm0rQixZQUEzQixDQUFQOztBQUNBLFlBQUksQ0FBQzNELElBQUwsRUFBVztBQUNQLGlCQUFPLElBQVA7QUFDSDs7QUFDRG9DLG9CQUFZLENBQUNwZ0MsSUFBYixDQUFrQmcrQixJQUFsQjtBQUNBeDRCLGNBQU0sQ0FBQ3hGLElBQVAsQ0FBYWcrQixJQUFELENBQXNCQSxJQUFsQztBQUNIOztBQUVELGFBQU9BLElBQVA7QUFDSDs7OztFQTlCb0JnRSxVOztBQWlDVjhFLHdFQUFmLEU7Ozs7Ozs7Ozs7Ozs7O0FDcENBOztJQUlNQyx1Qjs7Ozs7Ozs7Ozs7Ozs7OzsrRUFDTyxPOzs7Ozs7OzRCQUNEaDNCLEcsRUFBcUJrVSxLLEVBQWdDO0FBQ3pELFVBQUlsVSxHQUFKLEVBQVM7QUFDTCxhQUFLK3RCLElBQUwsR0FBWS90QixHQUFaO0FBQ0g7O0FBRUQsVUFBSXd5QixhQUFhLEdBQUcsQ0FBcEI7QUFDQSxVQUFJeDVCLE1BQU0sR0FBR2tiLEtBQWI7QUFDQSxVQUFNemdCLEdBQUcsR0FBRyxLQUFLczZCLElBQUwsQ0FBVWxpQyxNQUF0QjtBQUNBLFVBQU00SixNQUFNLEdBQUcsRUFBZjtBQUNBLFVBQU00NkIsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsVUFBSXBDLElBQXdCLEdBQUcsSUFBL0I7O0FBRUEsVUFBSWoxQixNQUFNLEtBQUsyTSxTQUFmLEVBQXlCO0FBQ3JCLGVBQU8sSUFBUDtBQUNIOztBQUVELFdBQUssSUFBSS9aLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBSixJQUFTb04sTUFBTSxHQUFHdkYsR0FBbEMsRUFBdUM3SCxDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDcWlDLFlBQUksR0FBRyxLQUFLK0MsV0FBTCxDQUFpQmg0QixNQUFqQixDQUFQOztBQUNBLFlBQUksQ0FBQ2kxQixJQUFMLEVBQVc7QUFDUCxpQkFBTyxJQUFQO0FBQ0g7O0FBQ0RvQyxvQkFBWSxDQUFDcGdDLElBQWIsQ0FBa0JnK0IsSUFBbEI7QUFDQXg0QixjQUFNLENBQUN4RixJQUFQLENBQVlnK0IsSUFBSSxDQUFDQSxJQUFMLEdBQVksRUFBeEI7O0FBQ0EsWUFBSUEsSUFBSSxDQUFDQSxJQUFMLElBQWEyRCxZQUFqQixFQUErQjtBQUMzQlksdUJBQWEsSUFBSSxLQUFNLElBQUk1bUMsQ0FBM0I7QUFDSDs7QUFDRCxZQUFJQSxDQUFDLEtBQUssQ0FBVixFQUFhO0FBQ1RvTixnQkFBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixFQUF5QkUsSUFBSSxDQUFDeDZCLEdBQTlCLENBQVQ7QUFDQXVGLGdCQUFNLEdBQUcsS0FBS2cyQixVQUFMLENBQWdCLEtBQUtqQixJQUFyQixFQUEyQi8wQixNQUEzQixDQUFUO0FBQ0g7QUFDSjs7QUFFRCxVQUFJdkQsTUFBTSxDQUFDNUosTUFBUCxLQUFrQixDQUFsQixJQUF3Qm9yQyxRQUFRLENBQUN4aEMsTUFBTSxDQUFDd0ssSUFBUCxDQUFZLEVBQVosQ0FBRCxDQUFSLEdBQTRCLENBQTdCLEtBQW9DdXlCLGFBQS9ELEVBQThFO0FBQzFFLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQU1yQyxTQUFTLEdBQUcsS0FBS0MsVUFBTCxFQUFsQjs7QUFFQSxhQUFPO0FBQ0huQyxZQUFJLEVBQUV4NEIsTUFBTSxDQUFDd0ssSUFBUCxDQUFZLEVBQVosQ0FESDtBQUVIb3dCLG9CQUFZLEVBQVpBLFlBRkc7QUFHSDU4QixXQUFHLEVBQUd3NkIsSUFBRCxDQUFzQng2QixHQUh4QjtBQUlIcTdCLGNBQU0sRUFBRSxLQUFLQyxNQUpWO0FBS0hvQixpQkFBUyxFQUFFQSxTQUxSO0FBTUhqYyxhQUFLLEVBQUdpYyxTQUFELENBQStCamM7QUFObkMsT0FBUDtBQVFIOzs7O0VBaERvQitkLFU7O0FBaUR4QjtBQUVjK0Usd0VBQWYsRTs7Ozs7Ozs7Ozs7Ozs7QUN2REE7QUFHQSxJQUFNRSxxQkFBcUIsR0FBRyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUIsRUFBakIsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkIsRUFBM0IsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FBOUI7O0FBRUEsU0FBU0MsbUJBQVQsQ0FBNkIzRSxhQUE3QixFQUFvRDtBQUNoRCxPQUFLLElBQUk1bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QixFQUE2QjtBQUN6QixRQUFJNG1DLGFBQWEsS0FBSzBFLHFCQUFxQixDQUFDdHJDLENBQUQsQ0FBM0MsRUFBZ0Q7QUFDNUMsYUFBT0EsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsU0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBU3dyQyxpQkFBVCxDQUEyQjNoQyxNQUEzQixFQUFrRDtBQUM5QyxNQUFNNUosTUFBTSxHQUFHNEosTUFBTSxDQUFDNUosTUFBdEI7QUFDQSxNQUFJc0UsR0FBRyxHQUFHLENBQVY7O0FBRUEsT0FBSyxJQUFJdkUsQ0FBQyxHQUFHQyxNQUFNLEdBQUcsQ0FBdEIsRUFBeUJELENBQUMsSUFBSSxDQUE5QixFQUFpQ0EsQ0FBQyxJQUFJLENBQXRDLEVBQXlDO0FBQ3JDdUUsT0FBRyxJQUFJc0YsTUFBTSxDQUFDN0osQ0FBRCxDQUFiO0FBQ0g7O0FBQ0R1RSxLQUFHLElBQUksQ0FBUDs7QUFDQSxPQUFLLElBQUl2RSxFQUFDLEdBQUdDLE1BQU0sR0FBRyxDQUF0QixFQUF5QkQsRUFBQyxJQUFJLENBQTlCLEVBQWlDQSxFQUFDLElBQUksQ0FBdEMsRUFBeUM7QUFDckN1RSxPQUFHLElBQUlzRixNQUFNLENBQUM3SixFQUFELENBQWI7QUFDSDs7QUFDRHVFLEtBQUcsSUFBSSxDQUFQO0FBQ0EsU0FBT0EsR0FBRyxHQUFHLEVBQWI7QUFDSDs7SUFFS2tuQyx1Qjs7Ozs7Ozs7Ozs7Ozs7OzsrRUFDTyxPOzs7Ozs7OzRCQUNEcjNCLEcsRUFBcUJrVSxLLEVBQWdDO0FBQ3pELFVBQUlBLEtBQUssS0FBS3ZPLFNBQWQsRUFBeUI7QUFDckIsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSTNGLEdBQUosRUFBUztBQUNMLGFBQUsrdEIsSUFBTCxHQUFZL3RCLEdBQVo7QUFDSDs7QUFFRCxVQUFJd3lCLGFBQWEsR0FBRyxDQUFwQjtBQUNBLFVBQUl4NUIsTUFBTSxHQUFHa2IsS0FBYjtBQUNBLFVBQU16Z0IsR0FBRyxHQUFHLEtBQUtzNkIsSUFBTCxDQUFVbGlDLE1BQXRCO0FBQ0EsVUFBSW9pQyxJQUF3QixHQUFHLElBQS9CO0FBQ0EsVUFBTXg0QixNQUFNLEdBQUcsRUFBZjtBQUNBLFVBQU00NkIsWUFBWSxHQUFHLEVBQXJCOztBQUVBLFdBQUssSUFBSXprQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQUosSUFBU29OLE1BQU0sR0FBR3ZGLEdBQWxDLEVBQXVDN0gsQ0FBQyxFQUF4QyxFQUE0QztBQUN4Q3FpQyxZQUFJLEdBQUcsS0FBSytDLFdBQUwsQ0FBaUJoNEIsTUFBakIsQ0FBUDs7QUFDQSxZQUFJLENBQUNpMUIsSUFBTCxFQUFXO0FBQ1AsaUJBQU8sSUFBUDtBQUNIOztBQUNEb0Msb0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCZytCLElBQWxCO0FBQ0F4NEIsY0FBTSxDQUFDeEYsSUFBUCxDQUFZZytCLElBQUksQ0FBQ0EsSUFBTCxHQUFZLEVBQXhCOztBQUNBLFlBQUlBLElBQUksQ0FBQ0EsSUFBTCxJQUFhMkQsWUFBakIsRUFBK0I7QUFDM0JZLHVCQUFhLElBQUksS0FBTSxJQUFJNW1DLENBQTNCO0FBQ0g7O0FBQ0QsWUFBSUEsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNUb04sZ0JBQU0sR0FBRyxLQUFLZzNCLFFBQUwsQ0FBYyxLQUFLakMsSUFBbkIsRUFBeUJFLElBQUksQ0FBQ3g2QixHQUE5QixDQUFUO0FBQ0F1RixnQkFBTSxHQUFHLEtBQUtnMkIsVUFBTCxDQUFnQixLQUFLakIsSUFBckIsRUFBMkIvMEIsTUFBM0IsQ0FBVDtBQUNIO0FBQ0o7O0FBRUQsVUFBSXZELE1BQU0sQ0FBQzVKLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSXVyQyxpQkFBaUIsQ0FBQzNoQyxNQUFELENBQWpCLEtBQThCMGhDLG1CQUFtQixDQUFDM0UsYUFBRCxDQUFyRCxFQUFzRTtBQUNsRSxlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFNckMsU0FBUyxHQUFHLEtBQUtDLFVBQUwsRUFBbEI7O0FBRUEsYUFBTztBQUNIbkMsWUFBSSxFQUFFeDRCLE1BQU0sQ0FBQ3dLLElBQVAsQ0FBWSxFQUFaLENBREg7QUFFSG93QixvQkFBWSxFQUFaQSxZQUZHO0FBR0g1OEIsV0FBRyxFQUFHdzZCLElBQUQsQ0FBc0J4NkIsR0FIeEI7QUFJSHE3QixjQUFNLEVBQUUsS0FBS0MsTUFKVjtBQUtIb0IsaUJBQVMsRUFBRUEsU0FMUjtBQU1IamMsYUFBSyxFQUFHaWMsU0FBRCxDQUErQmpjO0FBTm5DLE9BQVA7QUFRSDs7OztFQXBEb0IrZCxVOztBQXFEeEI7QUFFY29GLHdFQUFmLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRkE7O0lBR01DLHVCOzs7Ozs7Ozs7Ozs7Ozs7O3VGQUNlLENBQ2IsQ0FBRSxFQUFGLEVBQU0sRUFBTixFQUFVLEVBQVYsRUFBYyxFQUFkLEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLEVBQTBCLEVBQTFCLEVBQThCLEVBQTlCLEVBQWtDLEVBQWxDLEVBQXNDLEVBQXRDLENBRGEsRUFFYixDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLEVBQVosRUFBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsRUFBd0IsRUFBeEIsRUFBNEIsRUFBNUIsRUFBZ0MsRUFBaEMsRUFBb0MsRUFBcEMsQ0FGYSxDOztxRkFHRixDQUFDLElBQUksQ0FBSixHQUFRLENBQVQsRUFBWSxJQUFJLENBQUosR0FBUSxDQUFwQixFQUF1QixJQUFJLENBQUosR0FBUSxDQUEvQixFQUFrQyxJQUFJLENBQUosR0FBUSxDQUExQyxFQUE2QyxJQUFJLENBQUosR0FBUSxDQUFyRCxFQUF3RCxJQUFJLENBQUosR0FBUSxDQUFoRSxDOzsrRUFDTixPOzs7Ozs7O21DQUNnQjdFLE0sRUFBeUJoOUIsTSxFQUF1QjQ2QixZLEVBQTBEO0FBQy9ILFVBQUlxQyxPQUE2QyxHQUFHLDhCQUFLRCxNQUFSLENBQWpEOztBQUNBLFVBQUlELGFBQWEsR0FBRyxHQUFwQjs7QUFFQSxXQUFLLElBQUk1bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFwQixFQUF1QkEsQ0FBQyxFQUF4QixFQUE0QjtBQUN4QjhtQyxlQUFPLEdBQUcsS0FBSzFCLFdBQUwsQ0FBaUIwQixPQUFPLENBQUNqL0IsR0FBekIsQ0FBVjs7QUFDQSxZQUFJLENBQUNpL0IsT0FBTCxFQUFjO0FBQ1YsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQUtBLE9BQUQsQ0FBeUJ6RSxJQUF6QixJQUFpQzJELFlBQXJDLEVBQW1EO0FBQzlDYyxpQkFBRCxDQUF5QnpFLElBQXpCLEdBQWlDeUUsT0FBRCxDQUF5QnpFLElBQXpCLEdBQWdDMkQsWUFBaEU7QUFDQVksdUJBQWEsSUFBSyxLQUFNLElBQUk1bUMsQ0FBNUI7QUFDSDs7QUFDRDZKLGNBQU0sQ0FBQ3hGLElBQVAsQ0FBYXlpQyxPQUFELENBQXlCekUsSUFBckM7QUFDQW9DLG9CQUFZLENBQUNwZ0MsSUFBYixDQUFrQnlpQyxPQUFsQjtBQUNIOztBQUNELFVBQUksQ0FBQyxLQUFLNkUsZ0JBQUwsQ0FBc0IvRSxhQUF0QixFQUFxQy84QixNQUFyQyxDQUFMLEVBQW1EO0FBQy9DLGVBQU8sSUFBUDtBQUNIOztBQUNELGFBQU9pOUIsT0FBUDtBQUNIOzs7cUNBRWdCRixhLEVBQXVCLzhCLE0sRUFBdUI7QUFDM0QsV0FBSyxJQUFJK2hDLFFBQVEsR0FBRyxDQUFwQixFQUF1QkEsUUFBUSxHQUFHLEtBQUt4RixjQUFMLENBQW9Cbm1DLE1BQXRELEVBQThEMnJDLFFBQVEsRUFBdEUsRUFBeUU7QUFDckUsYUFBSyxJQUFJNXJDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS29tQyxjQUFMLENBQW9Cd0YsUUFBcEIsRUFBOEIzckMsTUFBbEQsRUFBMERELENBQUMsRUFBM0QsRUFBK0Q7QUFDM0QsY0FBSTRtQyxhQUFhLEtBQUssS0FBS1IsY0FBTCxDQUFvQndGLFFBQXBCLEVBQThCNXJDLENBQTlCLENBQXRCLEVBQXdEO0FBQ3BENkosa0JBQU0sQ0FBQ21HLE9BQVAsQ0FBZTQ3QixRQUFmO0FBQ0EvaEMsa0JBQU0sQ0FBQ3hGLElBQVAsQ0FBWXJFLENBQVo7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUNELGFBQU8sS0FBUDtBQUNIOzs7bUNBRWM2SixNLEVBQXVCO0FBQ2xDLFVBQUlnaUMsSUFBSSxHQUFHLENBQUNoaUMsTUFBTSxDQUFDLENBQUQsQ0FBUCxDQUFYO0FBQ0EsVUFBTWlpQyxTQUFTLEdBQUdqaUMsTUFBTSxDQUFDQSxNQUFNLENBQUM1SixNQUFQLEdBQWdCLENBQWpCLENBQXhCOztBQUVBLFVBQUk2ckMsU0FBUyxJQUFJLENBQWpCLEVBQW9CO0FBQ2hCRCxZQUFJLEdBQUdBLElBQUksQ0FBQzU3QixNQUFMLENBQVlwRyxNQUFNLENBQUNnYyxLQUFQLENBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFaLEVBQ0Y1VixNQURFLENBQ0ssQ0FBQzY3QixTQUFELEVBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsQ0FETCxFQUVGNzdCLE1BRkUsQ0FFS3BHLE1BQU0sQ0FBQ2djLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBRkwsQ0FBUDtBQUdILE9BSkQsTUFJTyxJQUFJaW1CLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUN4QkQsWUFBSSxHQUFHQSxJQUFJLENBQUM1N0IsTUFBTCxDQUFZcEcsTUFBTSxDQUFDZ2MsS0FBUCxDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBWixFQUNGNVYsTUFERSxDQUNLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsQ0FETCxFQUVGQSxNQUZFLENBRUtwRyxNQUFNLENBQUNnYyxLQUFQLENBQWEsQ0FBYixFQUFnQixDQUFoQixDQUZMLENBQVA7QUFHSCxPQUpNLE1BSUEsSUFBSWltQixTQUFTLEtBQUssQ0FBbEIsRUFBcUI7QUFDeEJELFlBQUksR0FBR0EsSUFBSSxDQUFDNTdCLE1BQUwsQ0FBWXBHLE1BQU0sQ0FBQ2djLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBQVosRUFDRjVWLE1BREUsQ0FDSyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCcEcsTUFBTSxDQUFDLENBQUQsQ0FBdEIsQ0FETCxDQUFQO0FBRUgsT0FITSxNQUdBO0FBQ0hnaUMsWUFBSSxHQUFHQSxJQUFJLENBQUM1N0IsTUFBTCxDQUFZcEcsTUFBTSxDQUFDZ2MsS0FBUCxDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBWixFQUNGNVYsTUFERSxDQUNLLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhNjdCLFNBQWIsQ0FETCxDQUFQO0FBRUg7O0FBRURELFVBQUksQ0FBQ3huQyxJQUFMLENBQVV3RixNQUFNLENBQUNBLE1BQU0sQ0FBQzVKLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBaEI7QUFDQSxhQUFPNHJDLElBQVA7QUFDSDs7OzhCQUVtQmhpQyxNLEVBQWdDO0FBQ2hELHlHQUF1QixLQUFLa2lDLGNBQUwsQ0FBb0JsaUMsTUFBcEIsQ0FBdkI7QUFDSDs7OzZCQUVrQnVELE0sRUFBZ0JpMkIsTyxFQUEwQztBQUN6RSx3R0FBc0JqMkIsTUFBdEIsRUFBOEIsSUFBOUI7QUFDSDs7OzhDQUVtQ3E0QixPLEVBQWtEO0FBQ2xGLFVBQU1DLHFCQUFxQixHQUFHRCxPQUFPLENBQUM1OUIsR0FBUixHQUFlLENBQUM0OUIsT0FBTyxDQUFDNTlCLEdBQVIsR0FBYzQ5QixPQUFPLENBQUNuZCxLQUF2QixJQUFnQyxDQUE3RTs7QUFDQSxVQUFJb2QscUJBQXFCLEdBQUcsS0FBS3ZELElBQUwsQ0FBVWxpQyxNQUF0QyxFQUE4QztBQUMxQyxZQUFJLEtBQUswbEMsV0FBTCxDQUFpQkYsT0FBTyxDQUFDNTlCLEdBQXpCLEVBQThCNjlCLHFCQUE5QixFQUFxRCxDQUFyRCxDQUFKLEVBQTZEO0FBQ3pELGlCQUFPRCxPQUFQO0FBQ0g7QUFDSjs7QUFDRCxhQUFPLElBQVA7QUFDSDs7OztFQWpGb0JZLFU7O0FBb0ZWcUYsd0VBQWYsRTs7Ozs7Ozs7Ozs7Ozs7QUN2RkE7QUFFQTtBQUNBO0FBRUEsSUFBTU0sQ0FBQyxHQUFHLENBQVY7QUFDQSxJQUFNQyxDQUFDLEdBQUcsQ0FBVjs7SUFFTUMsd0I7Ozs7O0FBc0JGLHVCQUFZQyxJQUFaLEVBQXVDO0FBQUE7O0FBQUE7O0FBQ25DLDhCQUFNejBCLGVBQUssQ0FBQztBQUFFMDBCLDRCQUFzQixFQUFFO0FBQTFCLEtBQUQsRUFBb0NELElBQXBDLENBQVg7O0FBRG1DLHNGQXJCdkIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQXFCdUI7O0FBQUEsMEZBcEJuQixJQW9CbUI7O0FBQUEsdUZBbkJ0QixJQW1Cc0I7O0FBQUEsc0ZBakJ2QixDQUFDSCxDQUFELEVBQUlBLENBQUosRUFBT0EsQ0FBUCxFQUFVQSxDQUFWLENBaUJ1Qjs7QUFBQSxxRkFoQnhCLENBQUNBLENBQUQsRUFBSUEsQ0FBSixFQUFPQyxDQUFQLENBZ0J3Qjs7QUFBQSxxRkFmeEIsQ0FDWCxDQUFDRCxDQUFELEVBQUlBLENBQUosRUFBT0MsQ0FBUCxFQUFVQSxDQUFWLEVBQWFELENBQWIsQ0FEVyxFQUVYLENBQUNDLENBQUQsRUFBSUQsQ0FBSixFQUFPQSxDQUFQLEVBQVVBLENBQVYsRUFBYUMsQ0FBYixDQUZXLEVBR1gsQ0FBQ0QsQ0FBRCxFQUFJQyxDQUFKLEVBQU9ELENBQVAsRUFBVUEsQ0FBVixFQUFhQyxDQUFiLENBSFcsRUFJWCxDQUFDQSxDQUFELEVBQUlBLENBQUosRUFBT0QsQ0FBUCxFQUFVQSxDQUFWLEVBQWFBLENBQWIsQ0FKVyxFQUtYLENBQUNBLENBQUQsRUFBSUEsQ0FBSixFQUFPQyxDQUFQLEVBQVVELENBQVYsRUFBYUMsQ0FBYixDQUxXLEVBTVgsQ0FBQ0EsQ0FBRCxFQUFJRCxDQUFKLEVBQU9DLENBQVAsRUFBVUQsQ0FBVixFQUFhQSxDQUFiLENBTlcsRUFPWCxDQUFDQSxDQUFELEVBQUlDLENBQUosRUFBT0EsQ0FBUCxFQUFVRCxDQUFWLEVBQWFBLENBQWIsQ0FQVyxFQVFYLENBQUNBLENBQUQsRUFBSUEsQ0FBSixFQUFPQSxDQUFQLEVBQVVDLENBQVYsRUFBYUEsQ0FBYixDQVJXLEVBU1gsQ0FBQ0EsQ0FBRCxFQUFJRCxDQUFKLEVBQU9BLENBQVAsRUFBVUMsQ0FBVixFQUFhRCxDQUFiLENBVFcsRUFVWCxDQUFDQSxDQUFELEVBQUlDLENBQUosRUFBT0QsQ0FBUCxFQUFVQyxDQUFWLEVBQWFELENBQWIsQ0FWVyxDQWV3Qjs7QUFBQSw4RkFIZixDQUdlOztBQUFBLCtFQUY5QixPQUU4Qjs7QUFFbkMsUUFBSUcsSUFBSSxDQUFDQyxzQkFBVCxFQUFpQztBQUM3QixZQUFLekosaUJBQUwsR0FBeUIsSUFBekI7QUFDQSxZQUFLcUIsY0FBTCxHQUFzQixJQUF0QjtBQUNIOztBQUNELFVBQUtsMkIsTUFBTCxHQUFjcStCLElBQWQ7QUFDQTtBQUNIOzs7O2tDQUVhL0osTyxFQUF3QkMsSSxFQUE2QjtBQUMvRCxVQUFJLEtBQUt2MEIsTUFBTCxDQUFZcytCLHNCQUFoQixFQUF3QztBQUNwQyxZQUFNQyxVQUFVLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFuQjtBQUNBLFlBQU1DLE9BQU8sR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWhCO0FBQ0EsWUFBTTFKLFVBQVUsR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQW5CO0FBQ0EsWUFBTTJKLGVBQWUsR0FBRyxLQUFLQyxxQkFBN0I7QUFDQSxZQUFNQyxzQkFBc0IsR0FBRyxJQUFJRixlQUFuQzs7QUFFQSxhQUFLLElBQUl2c0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29pQyxPQUFPLENBQUNuaUMsTUFBNUIsRUFBb0NELENBQUMsRUFBckMsRUFBeUM7QUFDckNxc0Msb0JBQVUsQ0FBQ3JzQyxDQUFDLEdBQUcsQ0FBTCxDQUFWLElBQXFCb2lDLE9BQU8sQ0FBQ3BpQyxDQUFELENBQTVCO0FBQ0Fzc0MsaUJBQU8sQ0FBQ3RzQyxDQUFDLEdBQUcsQ0FBTCxDQUFQLElBQWtCcWlDLElBQUksQ0FBQ3JpQyxDQUFELENBQXRCO0FBQ0g7O0FBQ0Q0aUMsa0JBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0IwSixPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFELFVBQVUsQ0FBQyxDQUFELENBQXZDO0FBQ0F6SixrQkFBVSxDQUFDLENBQUQsQ0FBVixHQUFnQjBKLE9BQU8sQ0FBQyxDQUFELENBQVAsR0FBYUQsVUFBVSxDQUFDLENBQUQsQ0FBdkM7QUFFQXpKLGtCQUFVLENBQUMsQ0FBRCxDQUFWLEdBQWdCcCtCLElBQUksQ0FBQ3ZDLEdBQUwsQ0FBU3VDLElBQUksQ0FBQ3hDLEdBQUwsQ0FBUzRnQyxVQUFVLENBQUMsQ0FBRCxDQUFuQixFQUF3QjJKLGVBQXhCLENBQVQsRUFBbURFLHNCQUFuRCxDQUFoQjtBQUNBN0osa0JBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0JwK0IsSUFBSSxDQUFDdkMsR0FBTCxDQUFTdUMsSUFBSSxDQUFDeEMsR0FBTCxDQUFTNGdDLFVBQVUsQ0FBQyxDQUFELENBQW5CLEVBQXdCMkosZUFBeEIsQ0FBVCxFQUFtREUsc0JBQW5ELENBQWhCO0FBQ0EsYUFBS0MsYUFBTCxHQUFxQjlKLFVBQXJCOztBQUNBLGFBQUssSUFBSTVpQyxFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxHQUFHb2lDLE9BQU8sQ0FBQ25pQyxNQUE1QixFQUFvQ0QsRUFBQyxFQUFyQyxFQUF5QztBQUNyQ29pQyxpQkFBTyxDQUFDcGlDLEVBQUQsQ0FBUCxJQUFjLEtBQUswc0MsYUFBTCxDQUFtQjFzQyxFQUFDLEdBQUcsQ0FBdkIsQ0FBZDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTzhoQyxjQUFhLENBQUN4aEMsU0FBZCxDQUF3QnlqQyxhQUF4QixDQUFzQ3BqQyxJQUF0QyxDQUEyQyxJQUEzQyxFQUFpRHloQyxPQUFqRCxFQUEwREMsSUFBMUQsQ0FBUDtBQUNIOzs7aUNBRVkvUSxPLEVBQWdDbGtCLE0sRUFBMkY7QUFBQSxVQUExRWkyQixPQUEwRSx1RUFBdkQsS0FBdUQ7QUFBQSxVQUFoRGlELFNBQWdELHVFQUEzQixLQUEyQjtBQUNwSSxVQUFNbEUsT0FBTyxHQUFHLElBQUk3cUIsS0FBSixDQUFrQitaLE9BQU8sQ0FBQ3J4QixNQUExQixFQUFrQ3NtQyxJQUFsQyxDQUF1QyxDQUF2QyxDQUFoQjtBQUNBLFVBQUloRCxVQUFVLEdBQUcsQ0FBakI7QUFDQSxVQUFNSyxTQUFTLEdBQUc7QUFDZHBnQixhQUFLLEVBQUVoWCxNQUFNLENBQUNDLFNBREE7QUFFZDQxQixZQUFJLEVBQUUsQ0FBQyxDQUZPO0FBR2QvWixhQUFLLEVBQUUsQ0FITztBQUlkemdCLFdBQUcsRUFBRTtBQUpTLE9BQWxCO0FBT0EsVUFBTTIrQixPQUFPLEdBQUcsS0FBS3hDLGNBQXJCO0FBRUFYLGFBQU8sR0FBR0EsT0FBTyxJQUFJLEtBQXJCO0FBQ0FpRCxlQUFTLEdBQUdBLFNBQVMsSUFBSSxLQUF6Qjs7QUFFQSxVQUFJLENBQUNsNUIsTUFBTCxFQUFhO0FBQ1RBLGNBQU0sR0FBRyxLQUFLZzNCLFFBQUwsQ0FBYyxLQUFLakMsSUFBbkIsQ0FBVDtBQUNIOztBQUVELFdBQUssSUFBSW5pQyxDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUksS0FBS21pQyxJQUFMLENBQVVuaUMsQ0FBVixLQUFnQnFqQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQTlCLENBQUosRUFBc0M7QUFDbENqQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSUEsVUFBVSxLQUFLbkIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBcEMsRUFBdUM7QUFDbkMsZ0JBQU1zRSxHQUFHLEdBQUc2OUIsT0FBTyxDQUFDL3ZCLE1BQVIsQ0FBZSxVQUFDaUMsSUFBRCxFQUFPQyxJQUFQO0FBQUEscUJBQWdCRCxJQUFJLEdBQUdDLElBQXZCO0FBQUEsYUFBZixFQUE0QyxDQUE1QyxDQUFaOztBQUNBLGdCQUFNaVAsS0FBSyxHQUFHLEtBQUt1Z0IsYUFBTCxDQUFtQjNCLE9BQW5CLEVBQTRCOVEsT0FBNUIsQ0FBZDs7QUFDQSxnQkFBSTlOLEtBQUssR0FBR2dqQixPQUFaLEVBQXFCO0FBQ2pCNUMsdUJBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCQSxLQUFsQjtBQUNBb2dCLHVCQUFTLENBQUN0YixLQUFWLEdBQWtCdG9CLENBQUMsR0FBR3VFLEdBQXRCO0FBQ0FxL0IsdUJBQVMsQ0FBQy83QixHQUFWLEdBQWdCN0gsQ0FBaEI7QUFDQSxxQkFBTzRqQyxTQUFQO0FBQ0g7O0FBQ0QsZ0JBQUkwQyxTQUFKLEVBQWU7QUFDWCxtQkFBSyxJQUFJajJCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcreEIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBckMsRUFBd0NvUSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDK3hCLHVCQUFPLENBQUMveEIsQ0FBRCxDQUFQLEdBQWEreEIsT0FBTyxDQUFDL3hCLENBQUMsR0FBRyxDQUFMLENBQXBCO0FBQ0g7O0FBQ0QreEIscUJBQU8sQ0FBQ0EsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUCxHQUE4QixDQUE5QjtBQUNBbWlDLHFCQUFPLENBQUNBLE9BQU8sQ0FBQ25pQyxNQUFSLEdBQWlCLENBQWxCLENBQVAsR0FBOEIsQ0FBOUI7QUFDQXNqQyx3QkFBVTtBQUNiLGFBUEQsTUFPTztBQUNILHFCQUFPLElBQVA7QUFDSDtBQUNKLFdBbkJELE1BbUJPO0FBQ0hBLHNCQUFVO0FBQ2I7O0FBQ0RuQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQLEdBQXNCLENBQXRCO0FBQ0FGLGlCQUFPLEdBQUcsQ0FBQ0EsT0FBWDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OztpQ0FFWTtBQUNULFVBQUlzRCxzQkFBc0IsR0FBRyxDQUE3Qjs7QUFDQSxVQUFJdjVCLE1BQU0sR0FBRyxLQUFLZzNCLFFBQUwsQ0FBYyxLQUFLakMsSUFBbkIsQ0FBYjs7QUFDQSxVQUFJb0MsU0FBaUMsR0FBRyxJQUF4QztBQUNBLFVBQUlvSSxjQUFjLEdBQUcsQ0FBckI7O0FBRUEsYUFBTyxDQUFDcEksU0FBUixFQUFtQjtBQUNmQSxpQkFBUyxHQUFHLEtBQUttQyxZQUFMLENBQWtCLEtBQUtULGFBQXZCLEVBQXNDNzRCLE1BQXRDLEVBQThDLEtBQTlDLEVBQXFELElBQXJELENBQVo7O0FBQ0EsWUFBSSxDQUFDbTNCLFNBQUwsRUFBZ0I7QUFDWixpQkFBTyxJQUFQO0FBQ0g7O0FBQ0RvSSxzQkFBYyxHQUFHbm9DLElBQUksQ0FBQ3JDLEtBQUwsQ0FBVyxDQUFDb2lDLFNBQVMsQ0FBQzE4QixHQUFWLEdBQWdCMDhCLFNBQVMsQ0FBQ2pjLEtBQTNCLElBQW9DLENBQS9DLENBQWpCO0FBQ0FxZSw4QkFBc0IsR0FBR3BDLFNBQVMsQ0FBQ2pjLEtBQVYsR0FBa0Jxa0IsY0FBYyxHQUFHLEVBQTVEOztBQUNBLFlBQUloRyxzQkFBc0IsSUFBSSxDQUE5QixFQUFpQztBQUM3QixjQUFJLEtBQUtoQixXQUFMLENBQWlCZ0Isc0JBQWpCLEVBQXlDcEMsU0FBUyxDQUFDamMsS0FBbkQsRUFBMEQsQ0FBMUQsQ0FBSixFQUFrRTtBQUM5RCxtQkFBT2ljLFNBQVA7QUFDSDtBQUNKOztBQUNEbjNCLGNBQU0sR0FBR20zQixTQUFTLENBQUMxOEIsR0FBbkI7QUFDQTA4QixpQkFBUyxHQUFHLElBQVo7QUFDSDs7QUFDRCxhQUFPLElBQVA7QUFDSDs7OzhDQUV5QmtCLE8sRUFBMEI7QUFDaEQsVUFBTUMscUJBQXFCLEdBQUdELE9BQU8sQ0FBQzU5QixHQUFSLEdBQWUsQ0FBQzQ5QixPQUFPLENBQUM1OUIsR0FBUixHQUFjNDlCLE9BQU8sQ0FBQ25kLEtBQXZCLElBQWdDLENBQTdFOztBQUNBLFVBQUlvZCxxQkFBcUIsR0FBRyxLQUFLdkQsSUFBTCxDQUFVbGlDLE1BQXRDLEVBQThDO0FBQzFDLFlBQUksS0FBSzBsQyxXQUFMLENBQWlCRixPQUFPLENBQUM1OUIsR0FBekIsRUFBOEI2OUIscUJBQTlCLEVBQXFELENBQXJELENBQUosRUFBNkQ7QUFDekQsaUJBQU9ELE9BQVA7QUFDSDtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7K0JBRVU7QUFDUCxXQUFLdEQsSUFBTCxDQUFVaEcsT0FBVjs7QUFDQSxVQUFNc0osT0FBTyxHQUFHLEtBQUtpQixZQUFMLENBQWtCLEtBQUtRLFlBQXZCLENBQWhCOztBQUNBLFdBQUsvRSxJQUFMLENBQVVoRyxPQUFWOztBQUVBLFVBQUlzSixPQUFPLEtBQUssSUFBaEIsRUFBc0I7QUFDbEIsZUFBTyxJQUFQO0FBQ0gsT0FQTSxDQVNQOzs7QUFDQSxVQUFNOXZCLEdBQUcsR0FBRzh2QixPQUFPLENBQUNuZCxLQUFwQjtBQUNBbWQsYUFBTyxDQUFDbmQsS0FBUixHQUFnQixLQUFLNlosSUFBTCxDQUFVbGlDLE1BQVYsR0FBbUJ3bEMsT0FBTyxDQUFDNTlCLEdBQTNDO0FBQ0E0OUIsYUFBTyxDQUFDNTlCLEdBQVIsR0FBYyxLQUFLczZCLElBQUwsQ0FBVWxpQyxNQUFWLEdBQW1CMFYsR0FBakM7QUFFQSxhQUFPOHZCLE9BQU8sS0FBSyxJQUFaLEdBQW1CLEtBQUtELHlCQUFMLENBQStCQyxPQUEvQixDQUFuQixHQUE2RCxJQUFwRTtBQUNIOzs7Z0NBRVdtSCxXLEVBQW1DO0FBQzNDLFVBQU1DLEtBQXlCLEdBQUcsRUFBbEM7O0FBRUEsV0FBSyxJQUFJN3NDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0c0MsV0FBVyxDQUFDM3NDLE1BQWhDLEVBQXdDRCxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDLFlBQU1xaUMsSUFBSSxHQUFHLEtBQUsrQyxXQUFMLENBQWlCd0gsV0FBVyxDQUFDNXNDLENBQUQsQ0FBNUIsQ0FBYjs7QUFDQSxZQUFJLENBQUNxaUMsSUFBTCxFQUFXO0FBQ1AsaUJBQU8sSUFBUDtBQUNIOztBQUNEd0ssYUFBSyxDQUFDeG9DLElBQU4sQ0FBV2crQixJQUFYO0FBQ0g7O0FBQ0QsYUFBT3dLLEtBQVA7QUFDSDs7O2dDQUVXekssTyxFQUE0QztBQUNwRCxVQUFNb0UsT0FBTyxHQUFHLEtBQUt4QyxjQUFyQjtBQUVBLFVBQU1KLFNBQVMsR0FBRztBQUNkcGdCLGFBQUssRUFBRWhYLE1BQU0sQ0FBQ0MsU0FEQTtBQUVkNDFCLFlBQUksRUFBRSxDQUFDLENBRk87QUFHZC9aLGFBQUssRUFBRSxDQUhPO0FBSWR6Z0IsV0FBRyxFQUFFO0FBSlMsT0FBbEI7O0FBT0EsV0FBSyxJQUFJdzZCLElBQUksR0FBRyxDQUFoQixFQUFtQkEsSUFBSSxHQUFHLEtBQUt5QixZQUFMLENBQWtCN2pDLE1BQTVDLEVBQW9Eb2lDLElBQUksRUFBeEQsRUFBNEQ7QUFDeEQsWUFBTTdlLEtBQUssR0FBRyxLQUFLdWdCLGFBQUwsQ0FBbUIzQixPQUFuQixFQUE0QixLQUFLMEIsWUFBTCxDQUFrQnpCLElBQWxCLENBQTVCLENBQWQ7O0FBQ0EsWUFBSTdlLEtBQUssR0FBR29nQixTQUFTLENBQUNwZ0IsS0FBdEIsRUFBNkI7QUFDekJvZ0IsbUJBQVMsQ0FBQ3ZCLElBQVYsR0FBaUJBLElBQWpCO0FBQ0F1QixtQkFBUyxDQUFDcGdCLEtBQVYsR0FBa0JBLEtBQWxCO0FBQ0g7QUFDSjs7QUFDRCxVQUFJb2dCLFNBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCZ2pCLE9BQXRCLEVBQStCO0FBQzNCLGVBQU81QyxTQUFQO0FBQ0g7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OzttQ0FFY04sUSxFQUFpQ3o1QixNLEVBQXVCNDZCLFksRUFBb0Q7QUFDdkgsVUFBSWo2QixHQUFHLEdBQUcsQ0FBVjtBQUNBLFVBQU1zaUMsYUFBYSxHQUFHeEosUUFBUSxDQUFDcmpDLE1BQS9CO0FBQ0EsVUFBTTJzQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLENBQUQsRUFBa0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixDQUFsQixDQUFwQjtBQUNBLFVBQUlDLEtBQTJCLEdBQUcsSUFBbEM7O0FBRUEsYUFBT3JpQyxHQUFHLEdBQUdzaUMsYUFBYixFQUE0QjtBQUN4QixhQUFLLElBQUk5c0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFwQixFQUF1QkEsQ0FBQyxFQUF4QixFQUE0QjtBQUN4QjRzQyxxQkFBVyxDQUFDLENBQUQsQ0FBWCxDQUFlNXNDLENBQWYsSUFBb0JzakMsUUFBUSxDQUFDOTRCLEdBQUQsQ0FBUixHQUFnQixLQUFLa2lDLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBcEM7QUFDQUUscUJBQVcsQ0FBQyxDQUFELENBQVgsQ0FBZTVzQyxDQUFmLElBQW9Cc2pDLFFBQVEsQ0FBQzk0QixHQUFHLEdBQUcsQ0FBUCxDQUFSLEdBQW9CLEtBQUtraUMsYUFBTCxDQUFtQixDQUFuQixDQUF4QztBQUNBbGlDLGFBQUcsSUFBSSxDQUFQO0FBQ0g7O0FBQ0RxaUMsYUFBSyxHQUFHLEtBQUtFLFdBQUwsQ0FBaUJILFdBQWpCLENBQVI7O0FBQ0EsWUFBSSxDQUFDQyxLQUFMLEVBQVk7QUFDUixpQkFBTyxJQUFQO0FBQ0g7O0FBQ0QsYUFBSyxJQUFJN3NDLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUc2c0MsS0FBSyxDQUFDNXNDLE1BQTFCLEVBQWtDRCxHQUFDLEVBQW5DLEVBQXVDO0FBQ25DNkosZ0JBQU0sQ0FBQ3hGLElBQVAsQ0FBWXdvQyxLQUFLLENBQUM3c0MsR0FBRCxDQUFMLENBQVNxaUMsSUFBVCxHQUFnQixFQUE1QjtBQUNBb0Msc0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCd29DLEtBQUssQ0FBQzdzQyxHQUFELENBQXZCO0FBQ0g7QUFDSjs7QUFDRCxhQUFPNnNDLEtBQVA7QUFDSDs7O3lDQUVvQnZKLFEsRUFBeUI7QUFDMUMsYUFBUUEsUUFBUSxDQUFDcmpDLE1BQVQsR0FBa0IsRUFBbEIsS0FBeUIsQ0FBakM7QUFDSDs7OzRCQUVPbVUsRyxFQUFxQmtVLEssRUFBa0Q7QUFDM0UsVUFBSXplLE1BQU0sR0FBRyxJQUFJME4sS0FBSixFQUFiO0FBQ0EsVUFBSWt0QixZQUFZLEdBQUcsSUFBSWx0QixLQUFKLEVBQW5COztBQUVBLFVBQU1ndEIsU0FBUyxHQUFHLEtBQUtDLFVBQUwsRUFBbEI7O0FBQ0EsVUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ1osZUFBTyxJQUFQO0FBQ0g7O0FBQ0RFLGtCQUFZLENBQUNwZ0MsSUFBYixDQUFrQmtnQyxTQUFsQjs7QUFFQSxVQUFNa0IsT0FBTyxHQUFHLEtBQUs0QixRQUFMLEVBQWhCOztBQUNBLFVBQUksQ0FBQzVCLE9BQUwsRUFBYztBQUNWLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQU1uQyxRQUFRLEdBQUcsS0FBS3dILGFBQUwsQ0FBbUJ2RyxTQUFTLENBQUMxOEIsR0FBN0IsRUFBa0M0OUIsT0FBTyxDQUFDbmQsS0FBMUMsRUFBaUQsS0FBakQsQ0FBakI7O0FBQ0EsVUFBSSxDQUFDLEtBQUswa0Isb0JBQUwsQ0FBMEIxSixRQUExQixDQUFMLEVBQTBDO0FBQ3RDLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQU1qQixJQUFJLEdBQUcsS0FBSytFLGNBQUwsQ0FBb0I5RCxRQUFwQixFQUE4Qno1QixNQUE5QixFQUFzQzQ2QixZQUF0QyxDQUFiOztBQUNBLFVBQUksQ0FBQ3BDLElBQUwsRUFBVztBQUNQLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQUl4NEIsTUFBTSxDQUFDNUosTUFBUCxHQUFnQixDQUFoQixLQUFzQixDQUF0QixJQUNJNEosTUFBTSxDQUFDNUosTUFBUCxHQUFnQixDQUR4QixFQUMyQjtBQUN2QixlQUFPLElBQVA7QUFDSDs7QUFFRHdrQyxrQkFBWSxDQUFDcGdDLElBQWIsQ0FBa0JvaEMsT0FBbEI7QUFDQSxhQUFPO0FBQ0hwRCxZQUFJLEVBQUV4NEIsTUFBTSxDQUFDd0ssSUFBUCxDQUFZLEVBQVosQ0FESDtBQUVIaVUsYUFBSyxFQUFFaWMsU0FBUyxDQUFDamMsS0FGZDtBQUdIemdCLFdBQUcsRUFBRTQ5QixPQUFPLENBQUM1OUIsR0FIVjtBQUlIMDhCLGlCQUFTLEVBQUVBLFNBSlI7QUFLSEUsb0JBQVksRUFBRUEsWUFMWDtBQU1IdkIsY0FBTSxFQUFFLEtBQUtDO0FBTlYsT0FBUDtBQVFIOzs7O0VBclFxQnJCLGM7O0FBd1FYb0sseUVBQWYsRTs7Ozs7Ozs7Ozs7Ozs7QUNoUkE7QUFFQSxJQUFNRixjQUFDLEdBQUcsQ0FBVjtBQUNBLElBQU1DLGNBQUMsR0FBRyxDQUFWO0FBQ0EsSUFBTWhHLDBCQUFhLEdBQUcsQ0FBQ2dHLGNBQUQsRUFBSUQsY0FBSixFQUFPQyxjQUFQLEVBQVVELGNBQVYsRUFBYUEsY0FBYixFQUFnQkEsY0FBaEIsQ0FBdEI7QUFDQSxJQUFNOUUsWUFBWSxHQUFHLENBQUMrRSxjQUFELEVBQUlELGNBQUosRUFBT0EsY0FBUCxFQUFVQSxjQUFWLEVBQWFDLGNBQWIsQ0FBckI7QUFDQSxJQUFNbkkseUJBQVksR0FBRyxDQUNqQixDQUFDa0ksY0FBRCxFQUFJQSxjQUFKLEVBQU9DLGNBQVAsRUFBVUEsY0FBVixFQUFhRCxjQUFiLENBRGlCLEVBRWpCLENBQUNDLGNBQUQsRUFBSUQsY0FBSixFQUFPQSxjQUFQLEVBQVVBLGNBQVYsRUFBYUMsY0FBYixDQUZpQixFQUdqQixDQUFDRCxjQUFELEVBQUlDLGNBQUosRUFBT0QsY0FBUCxFQUFVQSxjQUFWLEVBQWFDLGNBQWIsQ0FIaUIsRUFJakIsQ0FBQ0EsY0FBRCxFQUFJQSxjQUFKLEVBQU9ELGNBQVAsRUFBVUEsY0FBVixFQUFhQSxjQUFiLENBSmlCLEVBS2pCLENBQUNBLGNBQUQsRUFBSUEsY0FBSixFQUFPQyxjQUFQLEVBQVVELGNBQVYsRUFBYUMsY0FBYixDQUxpQixFQU1qQixDQUFDQSxjQUFELEVBQUlELGNBQUosRUFBT0MsY0FBUCxFQUFVRCxjQUFWLEVBQWFBLGNBQWIsQ0FOaUIsRUFPakIsQ0FBQ0EsY0FBRCxFQUFJQyxjQUFKLEVBQU9BLGNBQVAsRUFBVUQsY0FBVixFQUFhQSxjQUFiLENBUGlCLEVBUWpCLENBQUNBLGNBQUQsRUFBSUEsY0FBSixFQUFPQSxjQUFQLEVBQVVDLGNBQVYsRUFBYUEsY0FBYixDQVJpQixFQVNqQixDQUFDQSxjQUFELEVBQUlELGNBQUosRUFBT0EsY0FBUCxFQUFVQyxjQUFWLEVBQWFELGNBQWIsQ0FUaUIsRUFVakIsQ0FBQ0EsY0FBRCxFQUFJQyxjQUFKLEVBQU9ELGNBQVAsRUFBVUMsY0FBVixFQUFhRCxjQUFiLENBVmlCLENBQXJCO0FBWUEsSUFBTWlCLG9CQUFvQixHQUFHaEgsMEJBQWEsQ0FBQzV6QixNQUFkLENBQXFCLFVBQUM5TixHQUFELEVBQU13UCxHQUFOO0FBQUEsU0FBY3hQLEdBQUcsR0FBR3dQLEdBQXBCO0FBQUEsQ0FBckIsRUFBOEMsQ0FBOUMsQ0FBN0I7O0lBRU1tNUIsNEI7Ozs7Ozs7Ozs7Ozs7Ozs7c0ZBQ2MsQ0FBQyxDQUFELEVBQUksQ0FBSixDOzsrRUFFUCxNOzswRkFFVyxJOzt1RkFFSCxJOzs7Ozs7O2lDQUVKNWIsTyxFQUFnQ2xrQixNLEVBQXdFO0FBQUEsVUFBeERpMkIsT0FBd0QsdUVBQTlDLEtBQThDO0FBQUEsVUFBdkNpRCxTQUF1Qyx1RUFBM0IsS0FBMkI7QUFDakgsVUFBTWxFLE9BQU8sR0FBRyxFQUFoQjtBQUNBLFVBQUltQixVQUFVLEdBQUcsQ0FBakI7QUFDQSxVQUFNSyxTQUFTLEdBQUc7QUFDZHBnQixhQUFLLEVBQUVoWCxNQUFNLENBQUNDLFNBREE7QUFFZDQxQixZQUFJLEVBQUUsQ0FBQyxDQUZPO0FBR2QvWixhQUFLLEVBQUUsQ0FITztBQUlkemdCLFdBQUcsRUFBRTtBQUpTLE9BQWxCO0FBTUEsVUFBSXRELEdBQUcsR0FBRyxDQUFWO0FBQ0EsVUFBSWlmLEtBQUssR0FBRyxDQUFaO0FBQ0EsVUFBTWdqQixPQUFPLEdBQUcsS0FBS3hDLGNBQXJCOztBQUVBLFVBQUksQ0FBQzUyQixNQUFMLEVBQWE7QUFDVEEsY0FBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixDQUFUO0FBQ0g7O0FBRUQsV0FBSyxJQUFJbmlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzeEIsT0FBTyxDQUFDcnhCLE1BQTVCLEVBQW9DRCxDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDb2lDLGVBQU8sQ0FBQ3BpQyxDQUFELENBQVAsR0FBYSxDQUFiO0FBQ0g7O0FBRUQsV0FBSyxJQUFJQSxFQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sRUFBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxFQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUksS0FBS21pQyxJQUFMLENBQVVuaUMsRUFBVixLQUFnQnFqQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQTlCLENBQUosRUFBc0M7QUFDbENqQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSUEsVUFBVSxLQUFLbkIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBcEMsRUFBdUM7QUFDbkNzRSxlQUFHLEdBQUcsQ0FBTjs7QUFDQSxpQkFBSyxJQUFJOEwsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyt4QixPQUFPLENBQUNuaUMsTUFBNUIsRUFBb0NvUSxDQUFDLEVBQXJDLEVBQXlDO0FBQ3JDOUwsaUJBQUcsSUFBSTY5QixPQUFPLENBQUMveEIsQ0FBRCxDQUFkO0FBQ0g7O0FBQ0RtVCxpQkFBSyxHQUFHLEtBQUt1Z0IsYUFBTCxDQUFtQjNCLE9BQW5CLEVBQTRCOVEsT0FBNUIsQ0FBUjs7QUFDQSxnQkFBSTlOLEtBQUssR0FBR2dqQixPQUFaLEVBQXFCO0FBQ2pCNUMsdUJBQVMsQ0FBQ3BnQixLQUFWLEdBQWtCQSxLQUFsQjtBQUNBb2dCLHVCQUFTLENBQUN0YixLQUFWLEdBQWtCdG9CLEVBQUMsR0FBR3VFLEdBQXRCO0FBQ0FxL0IsdUJBQVMsQ0FBQy83QixHQUFWLEdBQWdCN0gsRUFBaEI7QUFDQSxxQkFBTzRqQyxTQUFQO0FBQ0g7O0FBQ0QsZ0JBQUkwQyxTQUFKLEVBQWU7QUFDWCxtQkFBSyxJQUFJajJCLEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUcreEIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBckMsRUFBd0NvUSxFQUFDLEVBQXpDLEVBQTZDO0FBQ3pDK3hCLHVCQUFPLENBQUMveEIsRUFBRCxDQUFQLEdBQWEreEIsT0FBTyxDQUFDL3hCLEVBQUMsR0FBRyxDQUFMLENBQXBCO0FBQ0g7O0FBQ0QreEIscUJBQU8sQ0FBQ0EsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUCxHQUE4QixDQUE5QjtBQUNBbWlDLHFCQUFPLENBQUNBLE9BQU8sQ0FBQ25pQyxNQUFSLEdBQWlCLENBQWxCLENBQVAsR0FBOEIsQ0FBOUI7QUFDQXNqQyx3QkFBVTtBQUNiLGFBUEQsTUFPTztBQUNILHFCQUFPLElBQVA7QUFDSDtBQUNKLFdBdEJELE1Bc0JPO0FBQ0hBLHNCQUFVO0FBQ2I7O0FBQ0RuQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQLEdBQXNCLENBQXRCO0FBQ0FGLGlCQUFPLEdBQUcsQ0FBQ0EsT0FBWDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OztpQ0FFWTtBQUNULFVBQUlrQixTQUFTLEdBQUcsSUFBaEI7O0FBQ0EsVUFBSW4zQixNQUFNLEdBQUcsS0FBS2czQixRQUFMLENBQWMsS0FBS2pDLElBQW5CLENBQWI7O0FBQ0EsVUFBSXdLLGNBQWMsR0FBRyxDQUFyQjtBQUNBLFVBQUloRyxzQkFBc0IsR0FBRyxDQUE3Qjs7QUFFQSxhQUFPLENBQUNwQyxTQUFSLEVBQW1CO0FBQ2ZBLGlCQUFTLEdBQUcsS0FBS21DLFlBQUwsQ0FBa0JULDBCQUFsQixFQUFpQzc0QixNQUFqQyxFQUF5QyxLQUF6QyxFQUFnRCxJQUFoRCxDQUFaOztBQUNBLFlBQUksQ0FBQ20zQixTQUFMLEVBQWdCO0FBQ1osaUJBQU8sSUFBUDtBQUNIOztBQUNEb0ksc0JBQWMsR0FBR25vQyxJQUFJLENBQUNyQyxLQUFMLENBQVcsQ0FBQ29pQyxTQUFTLENBQUMxOEIsR0FBVixHQUFnQjA4QixTQUFTLENBQUNqYyxLQUEzQixJQUFvQzJrQixvQkFBL0MsQ0FBakI7QUFDQXRHLDhCQUFzQixHQUFHcEMsU0FBUyxDQUFDamMsS0FBVixHQUFrQnFrQixjQUFjLEdBQUcsQ0FBNUQ7O0FBQ0EsWUFBSWhHLHNCQUFzQixJQUFJLENBQTlCLEVBQWlDO0FBQzdCLGNBQUksS0FBS2hCLFdBQUwsQ0FBaUJnQixzQkFBakIsRUFBeUNwQyxTQUFTLENBQUNqYyxLQUFuRCxFQUEwRCxDQUExRCxDQUFKLEVBQWtFO0FBQzlELG1CQUFPaWMsU0FBUDtBQUNIO0FBQ0o7O0FBQ0RuM0IsY0FBTSxHQUFHbTNCLFNBQVMsQ0FBQzE4QixHQUFuQjtBQUNBMDhCLGlCQUFTLEdBQUcsSUFBWjtBQUNIOztBQUNELGFBQU9BLFNBQVA7QUFDSDs7OzhDQUV5QmtCLE8sRUFBc0I7QUFDNUMsVUFBTUMscUJBQXFCLEdBQUdELE9BQU8sQ0FBQzU5QixHQUFSLEdBQWUsQ0FBQzQ5QixPQUFPLENBQUM1OUIsR0FBUixHQUFjNDlCLE9BQU8sQ0FBQ25kLEtBQXZCLElBQWdDLENBQTdFOztBQUNBLFVBQUlvZCxxQkFBcUIsR0FBRyxLQUFLdkQsSUFBTCxDQUFVbGlDLE1BQXRDLEVBQThDO0FBQzFDLFlBQUksS0FBSzBsQyxXQUFMLENBQWlCRixPQUFPLENBQUM1OUIsR0FBekIsRUFBOEI2OUIscUJBQTlCLEVBQXFELENBQXJELENBQUosRUFBNkQ7QUFDekQsaUJBQU9ELE9BQVA7QUFDSDtBQUNKOztBQUNELGFBQU8sSUFBUDtBQUNIOzs7K0JBRVU7QUFDUDtBQUNBLFdBQUt0RCxJQUFMLENBQVVoRyxPQUFWOztBQUNBLFVBQU0vdUIsTUFBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixDQUFmOztBQUNBLFVBQU1zRCxPQUFPLEdBQUcsS0FBS2lCLFlBQUwsQ0FBa0JRLFlBQWxCLEVBQWdDOTVCLE1BQWhDLEVBQXdDLEtBQXhDLEVBQStDLElBQS9DLENBQWhCOztBQUNBLFdBQUsrMEIsSUFBTCxDQUFVaEcsT0FBVjs7QUFFQSxVQUFJc0osT0FBTyxLQUFLLElBQWhCLEVBQXNCO0FBQ2xCLGVBQU8sSUFBUDtBQUNILE9BVE0sQ0FXUDs7O0FBQ0EsVUFBTTl2QixHQUFHLEdBQUc4dkIsT0FBTyxDQUFDbmQsS0FBcEI7QUFDQW1kLGFBQU8sQ0FBQ25kLEtBQVIsR0FBZ0IsS0FBSzZaLElBQUwsQ0FBVWxpQyxNQUFWLEdBQW1Cd2xDLE9BQU8sQ0FBQzU5QixHQUEzQztBQUNBNDlCLGFBQU8sQ0FBQzU5QixHQUFSLEdBQWMsS0FBS3M2QixJQUFMLENBQVVsaUMsTUFBVixHQUFtQjBWLEdBQWpDO0FBRUEsYUFBTzh2QixPQUFPLEtBQUssSUFBWixHQUFtQixLQUFLRCx5QkFBTCxDQUErQkMsT0FBL0IsQ0FBbkIsR0FBNkQsSUFBcEU7QUFDSDs7O3lDQUVvQm5DLFEsRUFBeUI7QUFDMUMsYUFBUUEsUUFBUSxDQUFDcmpDLE1BQVQsR0FBa0IsRUFBbEIsS0FBeUIsQ0FBakM7QUFDSDs7O2dDQUVXbWlDLE8sRUFBZ0M7QUFDeEMsVUFBTW9FLE9BQU8sR0FBRyxLQUFLeEMsY0FBckI7QUFDQSxVQUFNSixTQUFTLEdBQUc7QUFDZHBnQixhQUFLLEVBQUVoWCxNQUFNLENBQUNDLFNBREE7QUFFZDQxQixZQUFJLEVBQUUsQ0FBQyxDQUZPO0FBR2QvWixhQUFLLEVBQUUsQ0FITztBQUlkemdCLFdBQUcsRUFBRTtBQUpTLE9BQWxCOztBQU9BLFdBQUssSUFBSXc2QixJQUFJLEdBQUcsQ0FBaEIsRUFBbUJBLElBQUksR0FBR3lCLHlCQUFZLENBQUM3akMsTUFBdkMsRUFBK0NvaUMsSUFBSSxFQUFuRCxFQUF1RDtBQUNuRCxZQUFNN2UsS0FBSyxHQUFHLEtBQUt1Z0IsYUFBTCxDQUFtQjNCLE9BQW5CLEVBQTRCMEIseUJBQVksQ0FBQ3pCLElBQUQsQ0FBeEMsQ0FBZDs7QUFDQSxZQUFJN2UsS0FBSyxHQUFHb2dCLFNBQVMsQ0FBQ3BnQixLQUF0QixFQUE2QjtBQUN6Qm9nQixtQkFBUyxDQUFDdkIsSUFBVixHQUFpQkEsSUFBakI7QUFDQXVCLG1CQUFTLENBQUNwZ0IsS0FBVixHQUFrQkEsS0FBbEI7QUFDSDtBQUNKOztBQUNELFVBQUlvZ0IsU0FBUyxDQUFDcGdCLEtBQVYsR0FBa0JnakIsT0FBdEIsRUFBK0I7QUFDM0IsZUFBTzVDLFNBQVA7QUFDSDs7QUFDRCxhQUFPLElBQVA7QUFDSDs7O21DQUVjTixRLEVBQWlDejVCLE0sRUFBdUI0NkIsWSxFQUFrQztBQUNyRyxVQUFJajZCLEdBQUcsR0FBRyxDQUFWO0FBQ0EsVUFBTXNpQyxhQUFhLEdBQUd4SixRQUFRLENBQUNyakMsTUFBL0I7QUFDQSxVQUFNbWlDLE9BQU8sR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLENBQWhCO0FBQ0EsVUFBSUMsSUFBd0IsR0FBRyxJQUEvQjs7QUFFQSxhQUFPNzNCLEdBQUcsR0FBR3NpQyxhQUFiLEVBQTRCO0FBQ3hCLGFBQUssSUFBSTlzQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO0FBQ3hCb2lDLGlCQUFPLENBQUNwaUMsQ0FBRCxDQUFQLEdBQWFzakMsUUFBUSxDQUFDOTRCLEdBQUQsQ0FBUixHQUFnQixLQUFLa2lDLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBN0I7QUFDQWxpQyxhQUFHLElBQUksQ0FBUDtBQUNIOztBQUNENjNCLFlBQUksR0FBRyxLQUFLK0MsV0FBTCxDQUFpQmhELE9BQWpCLENBQVA7O0FBQ0EsWUFBSSxDQUFDQyxJQUFMLEVBQVc7QUFDUCxpQkFBTyxJQUFQO0FBQ0g7O0FBQ0R4NEIsY0FBTSxDQUFDeEYsSUFBUCxXQUFlZytCLElBQUksQ0FBQ0EsSUFBcEI7QUFDQW9DLG9CQUFZLENBQUNwZ0MsSUFBYixDQUFrQmcrQixJQUFsQjtBQUNIOztBQUNELGFBQU9BLElBQVA7QUFDSDs7OzRCQUdPanVCLEcsRUFBcUJrVSxLLEVBQXlDO0FBQ2xFLFVBQU1pYyxTQUFTLEdBQUcsS0FBS0MsVUFBTCxFQUFsQjs7QUFDQSxVQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDWixlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFNa0IsT0FBTyxHQUFHLEtBQUs0QixRQUFMLEVBQWhCOztBQUNBLFVBQUksQ0FBQzVCLE9BQUwsRUFBYztBQUNWLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQU1uQyxRQUFRLEdBQUcsS0FBS3dILGFBQUwsQ0FBbUJ2RyxTQUFTLENBQUMxOEIsR0FBN0IsRUFBa0M0OUIsT0FBTyxDQUFDbmQsS0FBMUMsRUFBaUQsS0FBakQsQ0FBakI7O0FBQ0EsVUFBSSxDQUFDLEtBQUswa0Isb0JBQUwsQ0FBMEIxSixRQUExQixDQUFMLEVBQTBDO0FBQ3RDLGVBQU8sSUFBUDtBQUNIOztBQUNELFVBQU1tQixZQUFZLEdBQUcsRUFBckI7QUFDQUEsa0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCa2dDLFNBQWxCO0FBRUEsVUFBTTE2QixNQUFxQixHQUFHLEVBQTlCOztBQUNBLFVBQU13NEIsSUFBSSxHQUFHLEtBQUsrRSxjQUFMLENBQW9COUQsUUFBcEIsRUFBOEJ6NUIsTUFBOUIsRUFBc0M0NkIsWUFBdEMsQ0FBYjs7QUFDQSxVQUFJLENBQUNwQyxJQUFMLEVBQVc7QUFDUCxlQUFPLElBQVA7QUFDSDs7QUFDRCxVQUFJeDRCLE1BQU0sQ0FBQzVKLE1BQVAsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsZUFBTyxJQUFQO0FBQ0g7O0FBRUR3a0Msa0JBQVksQ0FBQ3BnQyxJQUFiLENBQWtCb2hDLE9BQWxCO0FBQ0EsYUFBTztBQUNIcEQsWUFBSSxFQUFFeDRCLE1BQU0sQ0FBQ3dLLElBQVAsQ0FBWSxFQUFaLENBREg7QUFFSGlVLGFBQUssRUFBRWljLFNBQVMsQ0FBQ2pjLEtBRmQ7QUFHSHpnQixXQUFHLEVBQUU0OUIsT0FBTyxDQUFDNTlCLEdBSFY7QUFJSDA4QixpQkFBUyxFQUFUQSxTQUpHO0FBS0hFLG9CQUFZLEVBQVpBLFlBTEc7QUFNSHZCLGNBQU0sRUFBRSxLQUFLQztBQU5WLE9BQVA7QUFRSDs7OztFQTNNeUJyQixjOztBQThNZm9MLDZFQUFmLEU7Ozs7Ozs7Ozs7Ozs7OztBQ2xPQTtBQUNBO0FBRUEsSUFBTXhGLCtCQUFnQixHQUFHLGtEQUF6QjtBQUNBLElBQU1DLHVCQUFRLEdBQUcsSUFBSUMsV0FBSixDQUFnQiw0QkFBSUYsK0JBQUosRUFBc0J2cEIsR0FBdEIsQ0FBMEIsVUFBQTBwQixLQUFJO0FBQUEsU0FBSUEsS0FBSSxDQUFDM0osVUFBTCxDQUFnQixDQUFoQixDQUFKO0FBQUEsQ0FBOUIsQ0FBaEIsQ0FBakI7QUFDQSxJQUFNNEosa0NBQW1CLEdBQUcsSUFBSUYsV0FBSixDQUFnQixDQUN4QyxLQUR3QyxFQUNqQyxLQURpQyxFQUMxQixLQUQwQixFQUNuQixLQURtQixFQUNaLEtBRFksRUFDTCxLQURLLEVBQ0UsS0FERixFQUNTLEtBRFQsRUFDZ0IsS0FEaEIsRUFDdUIsS0FEdkIsRUFFeEMsS0FGd0MsRUFFakMsS0FGaUMsRUFFMUIsS0FGMEIsRUFFbkIsS0FGbUIsRUFFWixLQUZZLEVBRUwsS0FGSyxFQUVFLEtBRkYsRUFFUyxLQUZULEVBRWdCLEtBRmhCLEVBRXVCLEtBRnZCLEVBR3hDLEtBSHdDLEVBR2pDLEtBSGlDLEVBRzFCLEtBSDBCLEVBR25CLEtBSG1CLEVBR1osS0FIWSxFQUdMLEtBSEssRUFHRSxLQUhGLEVBR1MsS0FIVCxFQUdnQixLQUhoQixFQUd1QixLQUh2QixFQUl4QyxLQUp3QyxFQUlqQyxLQUppQyxFQUkxQixLQUowQixFQUluQixLQUptQixFQUlaLEtBSlksRUFJTCxLQUpLLEVBSUUsS0FKRixFQUlTLEtBSlQsRUFJZ0IsS0FKaEIsRUFJdUIsS0FKdkIsRUFLeEMsS0FMd0MsRUFLakMsS0FMaUMsRUFLMUIsS0FMMEIsRUFLbkIsS0FMbUIsRUFLWixLQUxZLEVBS0wsS0FMSyxFQUtFLEtBTEYsRUFLUyxLQUxULENBQWhCLENBQTVCO0FBT0EsSUFBTUcsdUJBQVEsR0FBRyxLQUFqQjs7SUFFTW9GLDJCOzs7Ozs7Ozs7Ozs7Ozs7OytFQUNPLFM7Ozs7Ozs7bUNBQ003YixPLEVBQWlCO0FBQzVCLFdBQUssSUFBSXR4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOG5DLGtDQUFtQixDQUFDN25DLE1BQXhDLEVBQWdERCxDQUFDLEVBQWpELEVBQXFEO0FBQ2pELFlBQUk4bkMsa0NBQW1CLENBQUM5bkMsQ0FBRCxDQUFuQixLQUEyQnN4QixPQUEvQixFQUF3QztBQUNwQyxpQkFBTytFLE1BQU0sQ0FBQ2lQLFlBQVAsQ0FBb0JxQyx1QkFBUSxDQUFDM25DLENBQUQsQ0FBNUIsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OzsrQkFFVXNqQyxRLEVBQXVCO0FBQzlCLFVBQU1FLFdBQVcsR0FBR0YsUUFBUSxDQUFDcmpDLE1BQTdCO0FBQ0EsVUFBTXNFLEdBQUcsR0FBRysrQixRQUFRLENBQUNqeEIsTUFBVCxDQUFnQixVQUFDaUMsSUFBRCxFQUFPQyxJQUFQO0FBQUEsZUFBZ0JELElBQUksR0FBR0MsSUFBdkI7QUFBQSxPQUFoQixFQUE2QyxDQUE3QyxDQUFaO0FBQ0EsVUFBSStjLE9BQU8sR0FBRyxDQUFkOztBQUVBLFdBQUssSUFBSXR4QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHd2pDLFdBQXBCLEVBQWlDeGpDLENBQUMsRUFBbEMsRUFBc0M7QUFDbEMsWUFBSTZsQyxVQUFVLEdBQUdyaEMsSUFBSSxDQUFDbkMsS0FBTCxDQUFXaWhDLFFBQVEsQ0FBQ3RqQyxDQUFELENBQVIsR0FBYyxDQUFkLEdBQWtCdUUsR0FBN0IsQ0FBakI7O0FBQ0EsWUFBSXNoQyxVQUFVLEdBQUcsQ0FBYixJQUFrQkEsVUFBVSxHQUFHLENBQW5DLEVBQXNDO0FBQ2xDLGlCQUFPLENBQUMsQ0FBUjtBQUNIOztBQUNELFlBQUksQ0FBQzdsQyxDQUFDLEdBQUcsQ0FBTCxNQUFZLENBQWhCLEVBQW1CO0FBQ2YsZUFBSyxJQUFJcVEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3cxQixVQUFwQixFQUFnQ3gxQixDQUFDLEVBQWpDLEVBQXFDO0FBQ2pDaWhCLG1CQUFPLEdBQUlBLE9BQU8sSUFBSSxDQUFaLEdBQWlCLENBQTNCO0FBQ0g7QUFDSixTQUpELE1BSU87QUFDSEEsaUJBQU8sS0FBS3VVLFVBQVo7QUFDSDtBQUNKOztBQUNELGFBQU92VSxPQUFQO0FBQ0g7OztpQ0FFWTtBQUNULFVBQU1sa0IsTUFBTSxHQUFHLEtBQUtnM0IsUUFBTCxDQUFjLEtBQUtqQyxJQUFuQixDQUFmOztBQUNBLFVBQUk4RixZQUFZLEdBQUc3NkIsTUFBbkI7QUFDQSxVQUFNZzFCLE9BQU8sR0FBRyxJQUFJd0YsV0FBSixDQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBQWhCLENBQWhCO0FBQ0EsVUFBSXJFLFVBQVUsR0FBRyxDQUFqQjtBQUNBLFVBQUlGLE9BQU8sR0FBRyxLQUFkOztBQUVBLFdBQUssSUFBSXJqQyxDQUFDLEdBQUdvTixNQUFiLEVBQXFCcE4sQ0FBQyxHQUFHLEtBQUttaUMsSUFBTCxDQUFVbGlDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDLFlBQUksS0FBS21pQyxJQUFMLENBQVVuaUMsQ0FBVixLQUFnQnFqQyxPQUFPLEdBQUcsQ0FBSCxHQUFPLENBQTlCLENBQUosRUFBc0M7QUFDbENqQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsY0FBSUEsVUFBVSxLQUFLbkIsT0FBTyxDQUFDbmlDLE1BQVIsR0FBaUIsQ0FBcEMsRUFBdUM7QUFDbkM7QUFDQSxnQkFBSSxLQUFLaW9DLFVBQUwsQ0FBZ0I5RixPQUFoQixNQUE2QjJGLHVCQUFqQyxFQUEyQztBQUN2QyxrQkFBTUksbUJBQW1CLEdBQUczakMsSUFBSSxDQUFDckMsS0FBTCxDQUFXcUMsSUFBSSxDQUFDdkMsR0FBTCxDQUFTLENBQVQsRUFBWWdtQyxZQUFZLEdBQUksQ0FBQ2pvQyxDQUFDLEdBQUdpb0MsWUFBTCxJQUFxQixDQUFqRCxDQUFYLENBQTVCOztBQUNBLGtCQUFJLEtBQUt0QyxXQUFMLENBQWlCd0MsbUJBQWpCLEVBQXNDRixZQUF0QyxFQUFvRCxDQUFwRCxDQUFKLEVBQTREO0FBQ3hELHVCQUFPO0FBQ0gzZix1QkFBSyxFQUFFMmYsWUFESjtBQUVIcGdDLHFCQUFHLEVBQUU3SDtBQUZGLGlCQUFQO0FBSUg7QUFDSjs7QUFFRGlvQyx3QkFBWSxJQUFJN0YsT0FBTyxDQUFDLENBQUQsQ0FBUCxHQUFhQSxPQUFPLENBQUMsQ0FBRCxDQUFwQzs7QUFDQSxpQkFBSyxJQUFJL3hCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDeEIreEIscUJBQU8sQ0FBQy94QixDQUFELENBQVAsR0FBYSt4QixPQUFPLENBQUMveEIsQ0FBQyxHQUFHLENBQUwsQ0FBcEI7QUFDSDs7QUFDRCt4QixtQkFBTyxDQUFDLENBQUQsQ0FBUCxHQUFhLENBQWI7QUFDQUEsbUJBQU8sQ0FBQyxDQUFELENBQVAsR0FBYSxDQUFiO0FBQ0FtQixzQkFBVTtBQUNiLFdBbkJELE1BbUJPO0FBQ0hBLHNCQUFVO0FBQ2I7O0FBQ0RuQixpQkFBTyxDQUFDbUIsVUFBRCxDQUFQLEdBQXNCLENBQXRCO0FBQ0FGLGlCQUFPLEdBQUcsQ0FBQ0EsT0FBWDtBQUNIO0FBQ0o7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OzsrQkFFVW9GLFMsRUFBbUJDLFMsRUFBbUI7QUFDN0MsVUFBSUQsU0FBUyxLQUFLQyxTQUFkLElBQTJCLENBQUMsS0FBS3ZHLElBQUwsQ0FBVXVHLFNBQVYsQ0FBaEMsRUFBc0Q7QUFDbEQsZUFBTyxLQUFQO0FBQ0g7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7OztvQ0FFZTBFLFMsRUFBMEI7QUFDdEMsVUFBTW50QyxNQUFNLEdBQUdtdEMsU0FBUyxDQUFDbnRDLE1BQXpCO0FBQ0EsVUFBTTRKLE1BQXFCLEdBQUcsRUFBOUI7O0FBQ0EsV0FBSyxJQUFJN0osQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0MsTUFBcEIsRUFBNEJELENBQUMsRUFBN0IsRUFBaUM7QUFDN0IsWUFBTTZuQyxNQUFJLEdBQUd1RixTQUFTLENBQUNwdEMsQ0FBRCxDQUF0Qjs7QUFDQSxZQUFJNm5DLE1BQUksSUFBSSxHQUFSLElBQWVBLE1BQUksSUFBSSxHQUEzQixFQUFnQztBQUM1QixjQUFJN25DLENBQUMsR0FBSUMsTUFBTSxHQUFHLENBQWxCLEVBQXNCO0FBQ2xCLG1CQUFPLElBQVA7QUFDSDs7QUFDRCxjQUFNb3RDLFFBQVEsR0FBR0QsU0FBUyxDQUFDLEVBQUVwdEMsQ0FBSCxDQUExQjtBQUNBLGNBQU1zdEMsWUFBWSxHQUFHRCxRQUFRLENBQUNuUCxVQUFULENBQW9CLENBQXBCLENBQXJCO0FBQ0EsY0FBSTBLLFdBQVcsU0FBZjs7QUFDQSxrQkFBUWYsTUFBUjtBQUNJLGlCQUFLLEdBQUw7QUFDSSxrQkFBSXdGLFFBQVEsSUFBSSxHQUFaLElBQW1CQSxRQUFRLElBQUksR0FBbkMsRUFBd0M7QUFDcEN6RSwyQkFBVyxHQUFHdlMsTUFBTSxDQUFDaVAsWUFBUCxDQUFvQmdJLFlBQVksR0FBRyxFQUFuQyxDQUFkO0FBQ0gsZUFGRCxNQUVPO0FBQ0gsdUJBQU8sSUFBUDtBQUNIOztBQUNEOztBQUNKLGlCQUFLLEdBQUw7QUFDSSxrQkFBSUQsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUNwQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CZ0ksWUFBWSxHQUFHLEVBQW5DLENBQWQ7QUFDSCxlQUZELE1BRU8sSUFBSUQsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUMzQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CZ0ksWUFBWSxHQUFHLEVBQW5DLENBQWQ7QUFDSCxlQUZNLE1BRUEsSUFBSUQsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUMzQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CZ0ksWUFBWSxHQUFHLEVBQW5DLENBQWQ7QUFDSCxlQUZNLE1BRUEsSUFBSUQsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUMzQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CZ0ksWUFBWSxHQUFHLEVBQW5DLENBQWQ7QUFDSCxlQUZNLE1BRUEsSUFBSUQsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUMzQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CLEdBQXBCLENBQWQ7QUFDSCxlQUZNLE1BRUE7QUFDSCx1QkFBTyxJQUFQO0FBQ0g7O0FBQ0Q7O0FBQ0osaUJBQUssR0FBTDtBQUNJLGtCQUFJK0gsUUFBUSxJQUFJLEdBQVosSUFBbUJBLFFBQVEsSUFBSSxHQUFuQyxFQUF3QztBQUNwQ3pFLDJCQUFXLEdBQUd2UyxNQUFNLENBQUNpUCxZQUFQLENBQW9CZ0ksWUFBWSxHQUFHLEVBQW5DLENBQWQ7QUFDSCxlQUZELE1BRU8sSUFBSUQsUUFBUSxLQUFLLEdBQWpCLEVBQXNCO0FBQ3pCekUsMkJBQVcsR0FBRyxHQUFkO0FBQ0gsZUFGTSxNQUVBO0FBQ0gsdUJBQU8sSUFBUDtBQUNIOztBQUNEOztBQUNKLGlCQUFLLEdBQUw7QUFDSSxrQkFBSXlFLFFBQVEsSUFBSSxHQUFaLElBQW1CQSxRQUFRLElBQUksR0FBbkMsRUFBd0M7QUFDcEN6RSwyQkFBVyxHQUFHdlMsTUFBTSxDQUFDaVAsWUFBUCxDQUFvQmdJLFlBQVksR0FBRyxFQUFuQyxDQUFkO0FBQ0gsZUFGRCxNQUVPO0FBQ0gsdUJBQU8sSUFBUDtBQUNIOztBQUNEOztBQUNKO0FBQ0lqdEIscUJBQU8sQ0FBQ2t0QixJQUFSLENBQWEseUVBQWIsRUFBd0YzRSxXQUF4RjtBQUNBLHFCQUFPLElBQVA7QUF6Q1I7O0FBMkNBLytCLGdCQUFNLENBQUN4RixJQUFQLENBQVl1a0MsV0FBWjtBQUNILFNBbkRELE1BbURPO0FBQ0gvK0IsZ0JBQU0sQ0FBQ3hGLElBQVAsQ0FBWXdqQyxNQUFaO0FBQ0g7QUFDSjs7QUFDRCxhQUFPaCtCLE1BQVA7QUFDSDs7O29DQUVldWpDLFMsRUFBMEJodUIsSyxFQUFlb3VCLFMsRUFBbUI7QUFDeEUsVUFBTUMsWUFBWSxHQUFHTCxTQUFTLENBQUN2bkIsS0FBVixDQUFnQixDQUFoQixFQUFtQnpHLEtBQW5CLENBQXJCO0FBQ0EsVUFBTW5mLE1BQU0sR0FBR3d0QyxZQUFZLENBQUN4dEMsTUFBNUI7QUFDQSxVQUFNeXRDLFlBQVksR0FBR0QsWUFBWSxDQUFDcDdCLE1BQWIsQ0FBb0IsVUFBQzlOLEdBQUQsRUFBTXNqQyxNQUFOLEVBQVk3bkMsQ0FBWixFQUFrQjtBQUN2RCxZQUFNMnRDLE1BQU0sR0FBSSxDQUFFM3RDLENBQUMsR0FBRyxDQUFDLENBQU4sSUFBWUMsTUFBTSxHQUFHLENBQXJCLENBQUQsSUFBNEJ1dEMsU0FBN0IsR0FBMEMsQ0FBekQ7QUFDQSxZQUFNL3VDLEtBQUssR0FBR2twQyx1QkFBUSxDQUFDaDJCLE9BQVQsQ0FBaUJrMkIsTUFBSSxDQUFDM0osVUFBTCxDQUFnQixDQUFoQixDQUFqQixDQUFkO0FBQ0EsZUFBTzM1QixHQUFHLEdBQUlvcEMsTUFBTSxHQUFHbHZDLEtBQXZCO0FBQ0gsT0FKb0IsRUFJbEIsQ0FKa0IsQ0FBckI7QUFNQSxVQUFNbXZDLFNBQVMsR0FBR2pHLHVCQUFRLENBQUUrRixZQUFZLEdBQUcsRUFBakIsQ0FBMUI7QUFDQSxhQUFPRSxTQUFTLEtBQUtSLFNBQVMsQ0FBQ2h1QixLQUFELENBQVQsQ0FBaUI4ZSxVQUFqQixDQUE0QixDQUE1QixDQUFyQjtBQUNIOzs7cUNBRWdCa1AsUyxFQUEwQjtBQUN2QyxhQUFPLEtBQUtTLGVBQUwsQ0FBcUJULFNBQXJCLEVBQWdDQSxTQUFTLENBQUNudEMsTUFBVixHQUFtQixDQUFuRCxFQUFzRCxFQUF0RCxLQUNBLEtBQUs0dEMsZUFBTCxDQUFxQlQsU0FBckIsRUFBZ0NBLFNBQVMsQ0FBQ250QyxNQUFWLEdBQW1CLENBQW5ELEVBQXNELEVBQXRELENBRFA7QUFFSDs7OzRCQUVPbVUsRyxFQUFxQmtVLEssRUFBeUQ7QUFDbEZBLFdBQUssR0FBRyxLQUFLa2MsVUFBTCxFQUFSOztBQUNBLFVBQUksQ0FBQ2xjLEtBQUwsRUFBWTtBQUNSLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQUlnYixRQUFRLEdBQUcsSUFBSXNFLFdBQUosQ0FBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUFoQixDQUFmO0FBQ0EsVUFBSS85QixNQUE0QixHQUFHLEVBQW5DOztBQUNBLFVBQUk2K0IsU0FBUyxHQUFHLEtBQUt0RSxRQUFMLENBQWMsS0FBS2pDLElBQW5CLEVBQXlCN1osS0FBSyxDQUFDemdCLEdBQS9CLENBQWhCOztBQUNBLFVBQUk0Z0MsU0FBSjtBQUNBLFVBQUlHLFdBQUo7O0FBQ0EsU0FBRztBQUNDdEYsZ0JBQVEsR0FBRyxLQUFLdUYsV0FBTCxDQUFpQkgsU0FBakIsRUFBNEJwRixRQUE1QixDQUFYOztBQUNBLFlBQU1oUyxPQUFPLEdBQUcsS0FBSzRXLFVBQUwsQ0FBZ0I1RSxRQUFoQixDQUFoQjs7QUFDQSxZQUFJaFMsT0FBTyxHQUFHLENBQWQsRUFBaUI7QUFDYixpQkFBTyxJQUFQO0FBQ0g7O0FBQ0RzWCxtQkFBVyxHQUFHLEtBQUtFLGNBQUwsQ0FBb0J4WCxPQUFwQixDQUFkOztBQUNBLFlBQUlzWCxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDdEIsaUJBQU8sSUFBUDtBQUNIOztBQUNELytCLGNBQU0sQ0FBQ3hGLElBQVAsQ0FBWXVrQyxXQUFaO0FBQ0FILGlCQUFTLEdBQUdDLFNBQVo7QUFDQUEsaUJBQVMsSUFBSWxnQywrQkFBVyxDQUFDakUsR0FBWixDQUFnQisrQixRQUFoQixDQUFiO0FBQ0FvRixpQkFBUyxHQUFHLEtBQUt0RSxRQUFMLENBQWMsS0FBS2pDLElBQW5CLEVBQXlCdUcsU0FBekIsQ0FBWjtBQUNILE9BZEQsUUFjU0UsV0FBVyxLQUFLLEdBZHpCOztBQWVBLytCLFlBQU0sQ0FBQzZtQixHQUFQOztBQUVBLFVBQUksQ0FBQzdtQixNQUFNLENBQUM1SixNQUFaLEVBQW9CO0FBQ2hCLGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQUksQ0FBQyxLQUFLNnRDLFVBQUwsQ0FBZ0JyRixTQUFoQixFQUEyQkMsU0FBM0IsQ0FBTCxFQUE0QztBQUN4QyxlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFJLENBQUMsS0FBS3FGLGdCQUFMLENBQXNCbGtDLE1BQXRCLENBQUwsRUFBb0M7QUFDaEMsZUFBTyxJQUFQO0FBQ0g7O0FBRURBLFlBQU0sR0FBR0EsTUFBTSxDQUFDZ2MsS0FBUCxDQUFhLENBQWIsRUFBZ0JoYyxNQUFNLENBQUM1SixNQUFQLEdBQWdCLENBQWhDLENBQVQsQ0F4Q2tGLENBeUNsRjs7QUFDQSxVQUFJLENBQUM0SixNQUFNLEdBQUcsS0FBS21rQyxlQUFMLENBQXFCbmtDLE1BQXJCLENBQVYsTUFBNEMsSUFBaEQsRUFBc0Q7QUFDbEQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsYUFBTztBQUNIdzRCLFlBQUksRUFBRXg0QixNQUFNLENBQUN3SyxJQUFQLENBQVksRUFBWixDQURIO0FBRUhpVSxhQUFLLEVBQUVBLEtBQUssQ0FBQ0EsS0FGVjtBQUdIemdCLFdBQUcsRUFBRTZnQyxTQUhGO0FBSUhuRSxpQkFBUyxFQUFFamMsS0FKUjtBQUtIbWMsb0JBQVksRUFBRTU2QixNQUxYO0FBTUhxNUIsY0FBTSxFQUFFLEtBQUtDO0FBTlYsT0FBUDtBQVNIOzs7O0VBdk5zQnJCLGM7O0FBME5acUwsOEVBQWYsRTs7Ozs7Ozs7Ozs7Ozs7O0FDeE9BO0FBR0EsSUFBTXBFLHVCQUFRLEdBQUc7QUFDYmtGLE1BQUksRUFBRSxTQURPO0FBRWJoRixNQUFJLEVBQUU7QUFGTyxDQUFqQjtBQUtBLElBQU1pRixTQUFTLEdBQUcsa0NBQWxCOztJQUVNQywyQjs7Ozs7Ozs7Ozs7Ozs7OzsrRUFDTyxnQjs7Ozs7OztrQ0FFSzlMLEksRUFBYztBQUN4QixVQUFJLCtCQUErQi9mLElBQS9CLENBQW9DK2YsSUFBcEMsQ0FBSixFQUErQztBQUMzQyxlQUFPLElBQVA7QUFDSDs7QUFDRCxVQUFJK0wsR0FBRyxHQUFHLENBQVY7O0FBQ0EsV0FBSyxJQUFJcHVDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxaUMsSUFBSSxDQUFDcGlDLE1BQXpCLEVBQWlDRCxDQUFDLEVBQWxDLEVBQXNDO0FBQ2xDb3VDLFdBQUcsR0FBR0EsR0FBRyxHQUFHLEVBQU4sR0FBV0YsU0FBUyxDQUFDdjhCLE9BQVYsQ0FBa0Iwd0IsSUFBSSxDQUFDcmlDLENBQUQsQ0FBdEIsQ0FBakI7QUFDSDs7QUFDRCxVQUFJcXVDLE1BQU0sR0FBRyxLQUFLRCxHQUFsQjs7QUFDQSxVQUFJQyxNQUFNLENBQUNwdUMsTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNuQm91QyxjQUFNLEdBQUcsQ0FBQyxjQUFjQSxNQUFmLEVBQXVCeG9CLEtBQXZCLENBQTZCLENBQUMsQ0FBOUIsQ0FBVDtBQUNIOztBQUNELGFBQU8sTUFBTXdvQixNQUFiO0FBQ0gsSyxDQUVEOzs7O21DQUNlaE0sSSxFQUFjO0FBQ3pCLGFBQU8sQ0FBQyxDQUFDQSxJQUFUO0FBQ0g7Ozs0QkFFT2p1QixHLEVBQXFCa1UsSyxFQUF5QztBQUNsRSxVQUFNemUsTUFBTSxHQUFHLDRGQUFjdUssR0FBakIsRUFBc0JrVSxLQUF0QixDQUFaOztBQUNBLFVBQUksQ0FBQ3plLE1BQUwsRUFBYTtBQUNULGVBQU8sSUFBUDtBQUNIOztBQUVELFVBQUl3NEIsSUFBSSxHQUFHeDRCLE1BQU0sQ0FBQ3c0QixJQUFsQjs7QUFFQSxVQUFJLENBQUNBLElBQUwsRUFBVztBQUNQLGVBQU8sSUFBUDtBQUNIOztBQUVEQSxVQUFJLEdBQUdBLElBQUksQ0FBQ2hSLE9BQUwsQ0FBYTBYLHVCQUFRLENBQUNrRixJQUF0QixFQUE0QixFQUE1QixDQUFQOztBQUVBLFVBQUksQ0FBQyxLQUFLOUUsY0FBTCxDQUFvQjlHLElBQXBCLENBQUwsRUFBZ0M7QUFDNUIsZUFBTyxJQUFQO0FBQ0g7O0FBRUQsVUFBSWdNLE1BQU0sR0FBRyxLQUFLQyxhQUFMLENBQW1Cak0sSUFBbkIsQ0FBYjs7QUFFQSxVQUFJLENBQUNnTSxNQUFMLEVBQWE7QUFDVCxlQUFPLElBQVA7QUFDSDs7QUFFRHhrQyxZQUFNLENBQUN3NEIsSUFBUCxHQUFjZ00sTUFBZDtBQUNBLGFBQU94a0MsTUFBUDtBQUVIOzs7O0VBbERzQm0rQixjOztBQXFEWm1HLDhFQUFmLEU7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLElBQU1JLE9BQU8sR0FBRztBQUNaQyxpQkFBZSxFQUFFL0ssZUFETDtBQUVaZ0wsWUFBVSxFQUFFcEksVUFGQTtBQUdacUksY0FBWSxFQUFFakQsWUFIRjtBQUlaa0QsY0FBWSxFQUFFdkQsWUFKRjtBQUtad0QsY0FBWSxFQUFFekQsWUFMRjtBQU1aMEQsZ0JBQWMsRUFBRTdHLGNBTko7QUFPWjhHLG9CQUFrQixFQUFFNUYsa0JBUFI7QUFRWjZGLGdCQUFjLEVBQUVDLGNBUko7QUFTWkMsWUFBVSxFQUFFaEUsVUFUQTtBQVVaaUUsY0FBWSxFQUFFeEQsWUFWRjtBQVdaeUQsY0FBWSxFQUFFakQsWUFYRjtBQVlaLGlCQUFlZ0IsWUFaSDtBQWFaa0MsZ0JBQWMsRUFBRWpDLGNBYko7QUFjWmtDLGdCQUFjLEVBQUVsQixjQUFZQTtBQWRoQixDQUFoQjtBQWlCZTtBQUNYbUIsZ0JBQWMsRUFBRSx3QkFBQ3hwQixJQUFELEVBQU95cEIsTUFBUCxFQUFrQjtBQUM5QmhCLFdBQU8sQ0FBQ3pvQixJQUFELENBQVAsR0FBZ0J5cEIsTUFBaEI7QUFDSCxHQUhVO0FBSVh4dUMsUUFKVyxrQkFJSitNLE1BSkksRUFJSTZSLGlCQUpKLEVBSXVCO0FBQzlCLFFBQU02dkIsT0FBTyxHQUFHO0FBQ1ozaUMsU0FBRyxFQUFFO0FBQ0Q0aUMsaUJBQVMsRUFBRSxJQURWO0FBRURuZSxlQUFPLEVBQUUsSUFGUjtBQUdEM1QsZUFBTyxFQUFFO0FBSFIsT0FETztBQU1aOUMsU0FBRyxFQUFFO0FBQ0Q0MEIsaUJBQVMsRUFBRSxJQURWO0FBRURuZSxlQUFPLEVBQUUsSUFGUjtBQUdEM1QsZUFBTyxFQUFFO0FBSFI7QUFOTyxLQUFoQjtBQVlBLFFBQU0reEIsZUFBZSxHQUFHLEVBQXhCO0FBRUFuMEIsY0FBVTtBQUNWbzBCLGVBQVc7QUFDWEMsY0FBVTs7QUFFVixhQUFTcjBCLFVBQVQsR0FBc0I7QUFDbEIsVUFBSUcsS0FBQSxJQUFtQixPQUFPck4sUUFBUCxLQUFvQixXQUEzQyxFQUF3RDtBQUNwRCxZQUFNd2hDLE1BQU0sR0FBR3hoQyxRQUFRLENBQUN3TixhQUFULENBQXVCLGtCQUF2QixDQUFmO0FBQ0EyekIsZUFBTyxDQUFDMzBCLEdBQVIsQ0FBWTQwQixTQUFaLEdBQXdCcGhDLFFBQVEsQ0FBQ3dOLGFBQVQsQ0FBdUIsa0JBQXZCLENBQXhCOztBQUNBLFlBQUksQ0FBQzJ6QixPQUFPLENBQUMzMEIsR0FBUixDQUFZNDBCLFNBQWpCLEVBQTRCO0FBQ3hCRCxpQkFBTyxDQUFDMzBCLEdBQVIsQ0FBWTQwQixTQUFaLEdBQXdCcGhDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUF4QjtBQUNBa2hDLGlCQUFPLENBQUMzMEIsR0FBUixDQUFZNDBCLFNBQVosQ0FBc0JoMEIsU0FBdEIsR0FBa0MsV0FBbEM7O0FBQ0EsY0FBSW8wQixNQUFKLEVBQVk7QUFDUkEsa0JBQU0sQ0FBQy96QixXQUFQLENBQW1CMHpCLE9BQU8sQ0FBQzMwQixHQUFSLENBQVk0MEIsU0FBL0I7QUFDSDtBQUNKOztBQUNERCxlQUFPLENBQUMzaUMsR0FBUixDQUFZNGlDLFNBQVosR0FBd0JELE9BQU8sQ0FBQzMwQixHQUFSLENBQVk0MEIsU0FBWixDQUFzQi9nQyxVQUF0QixDQUFpQyxJQUFqQyxDQUF4QjtBQUVBOGdDLGVBQU8sQ0FBQzMwQixHQUFSLENBQVl5VyxPQUFaLEdBQXNCampCLFFBQVEsQ0FBQ3dOLGFBQVQsQ0FBdUIsc0JBQXZCLENBQXRCOztBQUNBLFlBQUksQ0FBQzJ6QixPQUFPLENBQUMzMEIsR0FBUixDQUFZeVcsT0FBakIsRUFBMEI7QUFDdEJrZSxpQkFBTyxDQUFDMzBCLEdBQVIsQ0FBWXlXLE9BQVosR0FBc0JqakIsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQXRCO0FBQ0FraEMsaUJBQU8sQ0FBQzMwQixHQUFSLENBQVl5VyxPQUFaLENBQW9CN1YsU0FBcEIsR0FBZ0MsZUFBaEM7O0FBQ0EsY0FBSW8wQixNQUFKLEVBQVk7QUFDUkEsa0JBQU0sQ0FBQy96QixXQUFQLENBQW1CMHpCLE9BQU8sQ0FBQzMwQixHQUFSLENBQVl5VyxPQUEvQjtBQUNIO0FBQ0o7O0FBQ0RrZSxlQUFPLENBQUMzaUMsR0FBUixDQUFZeWtCLE9BQVosR0FBc0JrZSxPQUFPLENBQUMzMEIsR0FBUixDQUFZeVcsT0FBWixDQUFvQjVpQixVQUFwQixDQUErQixJQUEvQixDQUF0QjtBQUVBOGdDLGVBQU8sQ0FBQzMwQixHQUFSLENBQVk4QyxPQUFaLEdBQXNCdFAsUUFBUSxDQUFDd04sYUFBVCxDQUF1QixzQkFBdkIsQ0FBdEI7O0FBQ0EsWUFBSTJ6QixPQUFPLENBQUMzMEIsR0FBUixDQUFZOEMsT0FBaEIsRUFBeUI7QUFDckI2eEIsaUJBQU8sQ0FBQzNpQyxHQUFSLENBQVk4USxPQUFaLEdBQXNCNnhCLE9BQU8sQ0FBQzMwQixHQUFSLENBQVk4QyxPQUFaLENBQW9CalAsVUFBcEIsQ0FBK0IsSUFBL0IsQ0FBdEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsYUFBU2loQyxXQUFULEdBQXVCO0FBQ25CN2hDLFlBQU0sQ0FBQ2dpQyxPQUFQLENBQWVyc0MsT0FBZixDQUF1QixVQUFDc3NDLFlBQUQsRUFBa0I7QUFDckMsWUFBSVIsTUFBSjtBQUNBLFlBQUlTLGFBQWEsR0FBRyxFQUFwQjtBQUNBLFlBQUk5TixXQUFXLEdBQUcsRUFBbEI7O0FBRUEsWUFBSSxpQkFBTzZOLFlBQVAsTUFBd0IsUUFBNUIsRUFBc0M7QUFDbENSLGdCQUFNLEdBQUdRLFlBQVksQ0FBQzdNLE1BQXRCO0FBQ0E4TSx1QkFBYSxHQUFHRCxZQUFZLENBQUNqaUMsTUFBN0I7QUFDSCxTQUhELE1BR08sSUFBSSxPQUFPaWlDLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDekNSLGdCQUFNLEdBQUdRLFlBQVQ7QUFDSDs7QUFDRCxZQUFJcjBCLElBQUosRUFBcUI7QUFDakIyRSxpQkFBTyxDQUFDQyxHQUFSLENBQVksNkJBQVosRUFBMkNpdkIsTUFBM0M7QUFDSDs7QUFDRCxZQUFJUyxhQUFhLENBQUM5TixXQUFsQixFQUErQjtBQUMzQkEscUJBQVcsR0FBRzhOLGFBQWEsQ0FDdEI5TixXQURTLENBQ0cvakIsR0FESCxDQUNPLFVBQUNvcEIsVUFBRDtBQUFBLG1CQUFnQixJQUFJZ0gsT0FBTyxDQUFDaEgsVUFBRCxDQUFYLEVBQWhCO0FBQUEsV0FEUCxDQUFkO0FBRUg7O0FBQ0QsWUFBSTtBQUNBLGNBQU0wSSxTQUFTLEdBQUcsSUFBSTFCLE9BQU8sQ0FBQ2dCLE1BQUQsQ0FBWCxDQUFvQlMsYUFBcEIsRUFBbUM5TixXQUFuQyxDQUFsQjs7QUFDQXdOLHlCQUFlLENBQUNyckMsSUFBaEIsQ0FBcUI0ckMsU0FBckI7QUFDSCxTQUhELENBR0UsT0FBT2xzQixHQUFQLEVBQVk7QUFDVjFELGlCQUFPLENBQUNtRCxLQUFSLENBQWMsOEJBQWQsRUFBOEMrckIsTUFBOUMsRUFBc0R4ckIsR0FBdEQ7QUFDQSxnQkFBTUEsR0FBTjtBQUNIO0FBQ0osT0F6QkQ7O0FBMEJBLFVBQUlySSxJQUFKLEVBQXFCO0FBQ2pCMkUsZUFBTyxDQUFDQyxHQUFSLCtCQUFtQ292QixlQUFlLENBQzdDdnhCLEdBRDhCLENBQzFCLFVBQUNveEIsTUFBRDtBQUFBLGlCQUFZaHZCLElBQUksQ0FBQ0MsU0FBTCxDQUFlO0FBQUUwaUIsa0JBQU0sRUFBRXFNLE1BQU0sQ0FBQ3BNLE1BQWpCO0FBQXlCcjFCLGtCQUFNLEVBQUV5aEMsTUFBTSxDQUFDemhDO0FBQXhDLFdBQWYsQ0FBWjtBQUFBLFNBRDBCLEVBRTlCdUcsSUFGOEIsQ0FFekIsSUFGeUIsQ0FBbkM7QUFHSDtBQUNKOztBQUVELGFBQVN1N0IsVUFBVCxHQUFzQjtBQUNsQixVQUFJbDBCLEtBQUEsSUFBbUIsT0FBT3JOLFFBQVAsS0FBb0IsV0FBM0MsRUFBd0Q7QUFDcEQsWUFBSXJPLENBQUo7QUFDQSxZQUFNa3dDLEdBQUcsR0FBRyxDQUFDO0FBQ1RDLGNBQUksRUFBRVgsT0FBTyxDQUFDMzBCLEdBQVIsQ0FBWTQwQixTQURUO0FBRVRXLGNBQUksRUFBRXRpQyxNQUFNLENBQUM2TixLQUFQLENBQWEwMEI7QUFGVixTQUFELEVBR1Q7QUFDQ0YsY0FBSSxFQUFFWCxPQUFPLENBQUMzMEIsR0FBUixDQUFZeVcsT0FEbkI7QUFFQzhlLGNBQUksRUFBRXRpQyxNQUFNLENBQUM2TixLQUFQLENBQWEyMEI7QUFGcEIsU0FIUyxDQUFaOztBQVFBLGFBQUt0d0MsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHa3dDLEdBQUcsQ0FBQ2p3QyxNQUFwQixFQUE0QkQsQ0FBQyxFQUE3QixFQUFpQztBQUM3QixjQUFJa3dDLEdBQUcsQ0FBQ2x3QyxDQUFELENBQUgsQ0FBT293QyxJQUFQLEtBQWdCLElBQXBCLEVBQTBCO0FBQ3RCRixlQUFHLENBQUNsd0MsQ0FBRCxDQUFILENBQU9td0MsSUFBUCxDQUFZdDlCLEtBQVosQ0FBa0IwOUIsT0FBbEIsR0FBNEIsT0FBNUI7QUFDSCxXQUZELE1BRU87QUFDSEwsZUFBRyxDQUFDbHdDLENBQUQsQ0FBSCxDQUFPbXdDLElBQVAsQ0FBWXQ5QixLQUFaLENBQWtCMDlCLE9BQWxCLEdBQTRCLE1BQTVCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFFRDs7Ozs7OztBQUtBLGFBQVNDLGVBQVQsQ0FBeUJocEMsSUFBekIsRUFBK0J3aEIsS0FBL0IsRUFBc0N5bkIsR0FBdEMsRUFBMkM7QUFDdkMsZUFBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDeEIsWUFBTUMsU0FBUyxHQUFHO0FBQ2RsckMsV0FBQyxFQUFFaXJDLE1BQU0sR0FBR25zQyxJQUFJLENBQUNFLEdBQUwsQ0FBU3NrQixLQUFULENBREU7QUFFZHZqQixXQUFDLEVBQUVrckMsTUFBTSxHQUFHbnNDLElBQUksQ0FBQ0MsR0FBTCxDQUFTdWtCLEtBQVQ7QUFGRSxTQUFsQjtBQUlBOztBQUNBeGhCLFlBQUksQ0FBQyxDQUFELENBQUosQ0FBUTlCLENBQVIsSUFBYWtyQyxTQUFTLENBQUNsckMsQ0FBdkI7QUFDQThCLFlBQUksQ0FBQyxDQUFELENBQUosQ0FBUS9CLENBQVIsSUFBYW1yQyxTQUFTLENBQUNuckMsQ0FBdkI7QUFDQStCLFlBQUksQ0FBQyxDQUFELENBQUosQ0FBUTlCLENBQVIsSUFBYWtyQyxTQUFTLENBQUNsckMsQ0FBdkI7QUFDQThCLFlBQUksQ0FBQyxDQUFELENBQUosQ0FBUS9CLENBQVIsSUFBYW1yQyxTQUFTLENBQUNuckMsQ0FBdkI7QUFDQTtBQUNILE9BWnNDLENBY3ZDOzs7QUFDQWlyQyxnQkFBVSxDQUFDRCxHQUFELENBQVY7O0FBQ0EsYUFBT0EsR0FBRyxHQUFHLENBQU4sS0FBWSxDQUFDOXdCLGlCQUFpQixDQUFDa3hCLGlCQUFsQixDQUFvQ3JwQyxJQUFJLENBQUMsQ0FBRCxDQUF4QyxDQUFELElBQ1IsQ0FBQ21ZLGlCQUFpQixDQUFDa3hCLGlCQUFsQixDQUFvQ3JwQyxJQUFJLENBQUMsQ0FBRCxDQUF4QyxDQURMLENBQVAsRUFDMkQ7QUFDdkQ7QUFDQWlwQyxXQUFHLElBQUlqc0MsSUFBSSxDQUFDcEMsSUFBTCxDQUFVcXVDLEdBQUcsR0FBRyxDQUFoQixDQUFQO0FBQ0FDLGtCQUFVLENBQUMsQ0FBQ0QsR0FBRixDQUFWO0FBQ0g7O0FBQ0QsYUFBT2pwQyxJQUFQO0FBQ0g7O0FBRUQsYUFBU3NwQyxPQUFULENBQWlCdDBCLEdBQWpCLEVBQXNCO0FBQ2xCLGFBQU8sQ0FBQztBQUNKL1csU0FBQyxFQUFFLENBQUMrVyxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUCxJQUFZQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUCxDQUFiLElBQTBCLENBQTFCLEdBQThCQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUCxDQUQ3QjtBQUVKOVcsU0FBQyxFQUFFLENBQUM4VyxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUCxJQUFZQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUCxDQUFiLElBQTBCLENBQTFCLEdBQThCQSxHQUFHLENBQUMsQ0FBRCxDQUFILENBQU8sQ0FBUDtBQUY3QixPQUFELEVBR0o7QUFDQy9XLFNBQUMsRUFBRSxDQUFDK1csR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsSUFBWUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsQ0FBYixJQUEwQixDQUExQixHQUE4QkEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsQ0FEbEM7QUFFQzlXLFNBQUMsRUFBRSxDQUFDOFcsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsSUFBWUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsQ0FBYixJQUEwQixDQUExQixHQUE4QkEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVA7QUFGbEMsT0FISSxDQUFQO0FBT0g7O0FBRUQsYUFBU3UwQixTQUFULENBQW1CdnBDLElBQW5CLEVBQXlCO0FBQ3JCLFVBQUlxQyxNQUFNLEdBQUcsSUFBYjtBQUNBLFVBQUk3SixDQUFKO0FBQ0EsVUFBTWd4QyxXQUFXLEdBQUczUSxTQUFTLENBQUNJLGNBQVYsQ0FBeUI5Z0IsaUJBQXpCLEVBQTRDblksSUFBSSxDQUFDLENBQUQsQ0FBaEQsRUFBcURBLElBQUksQ0FBQyxDQUFELENBQXpELENBQXBCOztBQUVBLFVBQUlrVSxLQUFBLElBQW1CNU4sTUFBTSxDQUFDNk4sS0FBUCxDQUFhMDBCLGFBQXBDLEVBQW1EO0FBQy9DM3pCLHNDQUFVLENBQUN0SixRQUFYLENBQW9CNUwsSUFBcEIsRUFBMEI7QUFBRS9CLFdBQUMsRUFBRSxHQUFMO0FBQVVDLFdBQUMsRUFBRTtBQUFiLFNBQTFCLEVBQThDOHBDLE9BQU8sQ0FBQzNpQyxHQUFSLENBQVk4USxPQUExRCxFQUFtRTtBQUFFNUssZUFBSyxFQUFFLEtBQVQ7QUFBZ0JFLG1CQUFTLEVBQUU7QUFBM0IsU0FBbkU7QUFDQW90QixpQkFBUyxDQUFDMWtCLEtBQVYsQ0FBZ0I4bEIsY0FBaEIsQ0FBK0J1UCxXQUFXLENBQUN4cEMsSUFBM0MsRUFBaURnb0MsT0FBTyxDQUFDMzBCLEdBQVIsQ0FBWTQwQixTQUE3RDtBQUNIOztBQUVEcFAsZUFBUyxDQUFDYyxZQUFWLENBQXVCNlAsV0FBdkI7O0FBRUEsVUFBSXQxQixLQUFBLElBQW1CNU4sTUFBTSxDQUFDNk4sS0FBUCxDQUFhMjBCLFdBQXBDLEVBQWlEO0FBQzdDalEsaUJBQVMsQ0FBQzFrQixLQUFWLENBQWdCK2xCLFlBQWhCLENBQTZCc1AsV0FBVyxDQUFDeHBDLElBQXpDLEVBQStDZ29DLE9BQU8sQ0FBQzMwQixHQUFSLENBQVl5VyxPQUEzRDtBQUNIOztBQUVELFdBQUt0eEIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHMHZDLGVBQWUsQ0FBQ3p2QyxNQUFwQixJQUE4QjRKLE1BQU0sS0FBSyxJQUFyRCxFQUEyRDdKLENBQUMsRUFBNUQsRUFBZ0U7QUFDNUQ2SixjQUFNLEdBQUc2bEMsZUFBZSxDQUFDMXZDLENBQUQsQ0FBZixDQUFtQml4QyxhQUFuQixDQUFpQ0QsV0FBVyxDQUFDeHBDLElBQTdDLENBQVQ7QUFDSDs7QUFDRCxVQUFJcUMsTUFBTSxLQUFLLElBQWYsRUFBcUI7QUFDakIsZUFBTyxJQUFQO0FBQ0g7O0FBQ0QsYUFBTztBQUNIcW5DLGtCQUFVLEVBQUVybkMsTUFEVDtBQUVIbW5DLG1CQUFXLEVBQVhBO0FBRkcsT0FBUDtBQUlIO0FBRUQ7Ozs7Ozs7OztBQU9BLGFBQVNHLG1CQUFULENBQTZCMzBCLEdBQTdCLEVBQWtDaFYsSUFBbEMsRUFBd0M0cEMsU0FBeEMsRUFBbUQ7QUFDL0MsVUFBTUMsVUFBVSxHQUFHN3NDLElBQUksQ0FBQ3VMLElBQUwsQ0FBVXZMLElBQUksQ0FBQzA3QixHQUFMLENBQVMxakIsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsSUFBWUEsR0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFPLENBQVAsQ0FBckIsRUFBZ0MsQ0FBaEMsSUFBcUNoWSxJQUFJLENBQUMwN0IsR0FBTCxDQUFVMWpCLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBTyxDQUFQLElBQVlBLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBTyxDQUFQLENBQXRCLEVBQWtDLENBQWxDLENBQS9DLENBQW5CO0FBQ0EsVUFBSXhjLENBQUo7QUFDQSxVQUFNc3hDLE1BQU0sR0FBRyxFQUFmO0FBQ0EsVUFBSXpuQyxNQUFNLEdBQUcsSUFBYjtBQUNBLFVBQUlvUCxHQUFKO0FBQ0EsVUFBSTIzQixTQUFKO0FBQ0EsVUFBTVcsSUFBSSxHQUFHL3NDLElBQUksQ0FBQ0UsR0FBTCxDQUFTMHNDLFNBQVQsQ0FBYjtBQUNBLFVBQU1JLElBQUksR0FBR2h0QyxJQUFJLENBQUNDLEdBQUwsQ0FBUzJzQyxTQUFULENBQWI7O0FBRUEsV0FBS3B4QyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdzeEMsTUFBSixJQUFjem5DLE1BQU0sS0FBSyxJQUFyQyxFQUEyQzdKLENBQUMsRUFBNUMsRUFBZ0Q7QUFDNUM7QUFDQTtBQUNBaVosV0FBRyxHQUFHbzRCLFVBQVUsR0FBR0MsTUFBYixHQUFzQnR4QyxDQUF0QixJQUEyQkEsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFWLEdBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQTlDLENBQU47QUFDQTR3QyxpQkFBUyxHQUFHO0FBQ1JsckMsV0FBQyxFQUFFdVQsR0FBRyxHQUFHczRCLElBREQ7QUFFUjlyQyxXQUFDLEVBQUV3VCxHQUFHLEdBQUd1NEI7QUFGRCxTQUFaO0FBSUE7O0FBQ0FocUMsWUFBSSxDQUFDLENBQUQsQ0FBSixDQUFROUIsQ0FBUixJQUFha3JDLFNBQVMsQ0FBQ25yQyxDQUF2QjtBQUNBK0IsWUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRL0IsQ0FBUixJQUFhbXJDLFNBQVMsQ0FBQ2xyQyxDQUF2QjtBQUNBOEIsWUFBSSxDQUFDLENBQUQsQ0FBSixDQUFROUIsQ0FBUixJQUFha3JDLFNBQVMsQ0FBQ25yQyxDQUF2QjtBQUNBK0IsWUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRL0IsQ0FBUixJQUFhbXJDLFNBQVMsQ0FBQ2xyQyxDQUF2QjtBQUNBOztBQUVBbUUsY0FBTSxHQUFHa25DLFNBQVMsQ0FBQ3ZwQyxJQUFELENBQWxCO0FBQ0g7O0FBQ0QsYUFBT3FDLE1BQVA7QUFDSDs7QUFFRCxhQUFTNG5DLGFBQVQsQ0FBdUJqcUMsSUFBdkIsRUFBNkI7QUFDekIsYUFBT2hELElBQUksQ0FBQ3VMLElBQUwsQ0FDSHZMLElBQUksQ0FBQzA3QixHQUFMLENBQVMxN0IsSUFBSSxDQUFDTyxHQUFMLENBQVN5QyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5QixDQUFSLEdBQVk4QixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5QixDQUE3QixDQUFULEVBQTBDLENBQTFDLElBQ0VsQixJQUFJLENBQUMwN0IsR0FBTCxDQUFTMTdCLElBQUksQ0FBQ08sR0FBTCxDQUFTeUMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRL0IsQ0FBUixHQUFZK0IsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRL0IsQ0FBN0IsQ0FBVCxFQUEwQyxDQUExQyxDQUZDLENBQVA7QUFJSDs7QUFFRCxhQUFTaXNDLGdCQUFULENBQXlCM3JDLFlBQXpCLEVBQXVDO0FBQ25DLFVBQUk4RCxNQUFNLEdBQUcsSUFBYjs7QUFDQSxXQUFLLElBQUk3SixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMHZDLGVBQWUsQ0FBQ3p2QyxNQUFwQixJQUE4QjRKLE1BQU0sS0FBSyxJQUF6RCxFQUErRDdKLENBQUMsRUFBaEUsRUFBb0U7QUFDaEU2SixjQUFNLEdBQUc2bEMsZUFBZSxDQUFDMXZDLENBQUQsQ0FBZixDQUFtQjJ4QyxXQUFuQixHQUFpQ2pDLGVBQWUsQ0FBQzF2QyxDQUFELENBQWYsQ0FBbUIyeEMsV0FBbkIsQ0FBK0I1ckMsWUFBL0IsQ0FBakMsR0FBZ0YsSUFBekY7QUFDSDs7QUFDRCxhQUFPOEQsTUFBUDtBQUNIO0FBQ0Q7Ozs7Ozs7O0FBTUEsYUFBUytuQyxzQkFBVCxDQUErQnAxQixHQUEvQixFQUFvQztBQUNoQyxVQUFJaFYsSUFBSjtBQUNBLFVBQU1xRixHQUFHLEdBQUcyaUMsT0FBTyxDQUFDM2lDLEdBQVIsQ0FBWThRLE9BQXhCO0FBQ0EsVUFBSTlULE1BQUo7O0FBRUEsVUFBSTZSLElBQUosRUFBcUI7QUFDakIsWUFBSTVOLE1BQU0sQ0FBQzZOLEtBQVAsQ0FBYWsyQixlQUFiLElBQWdDaGxDLEdBQXBDLEVBQXlDO0FBQ3JDNlAsd0NBQVUsQ0FBQ3RKLFFBQVgsQ0FBb0JvSixHQUFwQixFQUF5QjtBQUFFL1csYUFBQyxFQUFFLENBQUw7QUFBUUMsYUFBQyxFQUFFO0FBQVgsV0FBekIsRUFBeUNtSCxHQUF6QyxFQUE4QztBQUFFa0csaUJBQUssRUFBRSxNQUFUO0FBQWlCRSxxQkFBUyxFQUFFO0FBQTVCLFdBQTlDO0FBQ0g7QUFDSjs7QUFFRHpMLFVBQUksR0FBR3NwQyxPQUFPLENBQUN0MEIsR0FBRCxDQUFkO0FBQ0EsVUFBTXMxQixVQUFVLEdBQUdMLGFBQWEsQ0FBQ2pxQyxJQUFELENBQWhDO0FBQ0EsVUFBTTRwQyxTQUFTLEdBQUc1c0MsSUFBSSxDQUFDdXRDLEtBQUwsQ0FBV3ZxQyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5QixDQUFSLEdBQVk4QixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5QixDQUEvQixFQUFrQzhCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUS9CLENBQVIsR0FBWStCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUS9CLENBQXRELENBQWxCO0FBQ0ErQixVQUFJLEdBQUdncEMsZUFBZSxDQUFDaHBDLElBQUQsRUFBTzRwQyxTQUFQLEVBQWtCNXNDLElBQUksQ0FBQ3JDLEtBQUwsQ0FBVzJ2QyxVQUFVLEdBQUcsR0FBeEIsQ0FBbEIsQ0FBdEI7O0FBQ0EsVUFBSXRxQyxJQUFJLEtBQUssSUFBYixFQUFtQjtBQUNmLGVBQU8sSUFBUDtBQUNIOztBQUVEcUMsWUFBTSxHQUFHa25DLFNBQVMsQ0FBQ3ZwQyxJQUFELENBQWxCOztBQUNBLFVBQUlxQyxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNqQkEsY0FBTSxHQUFHc25DLG1CQUFtQixDQUFDMzBCLEdBQUQsRUFBTWhWLElBQU4sRUFBWTRwQyxTQUFaLENBQTVCO0FBQ0g7O0FBRUQsVUFBSXZuQyxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNqQixlQUFPLElBQVA7QUFDSDs7QUFFRCxVQUFJNlIsS0FBQSxJQUFtQjdSLE1BQW5CLElBQTZCaUUsTUFBTSxDQUFDNk4sS0FBUCxDQUFhcTJCLFlBQTFDLElBQTBEbmxDLEdBQTlELEVBQW1FO0FBQy9ENlAsc0NBQVUsQ0FBQ3RKLFFBQVgsQ0FBb0I1TCxJQUFwQixFQUEwQjtBQUFFL0IsV0FBQyxFQUFFLEdBQUw7QUFBVUMsV0FBQyxFQUFFO0FBQWIsU0FBMUIsRUFBOENtSCxHQUE5QyxFQUFtRDtBQUFFa0csZUFBSyxFQUFFLEtBQVQ7QUFBZ0JFLG1CQUFTLEVBQUU7QUFBM0IsU0FBbkQ7QUFDSDs7QUFFRCxhQUFPO0FBQ0hpK0Isa0JBQVUsRUFBRXJuQyxNQUFNLENBQUNxbkMsVUFEaEI7QUFFSDFwQyxZQUFJLEVBQUpBLElBRkc7QUFHSHdoQixhQUFLLEVBQUVvb0IsU0FISjtBQUlIOWYsZUFBTyxFQUFFem5CLE1BQU0sQ0FBQ21uQyxXQUFQLENBQW1CeHBDLElBSnpCO0FBS0gzRCxpQkFBUyxFQUFFZ0csTUFBTSxDQUFDbW5DLFdBQVAsQ0FBbUJudEM7QUFMM0IsT0FBUDtBQU9IOztBQUVELFdBQU87QUFDSCt0QywyQkFERyxpQ0FDbUJwMUIsR0FEbkIsRUFDd0I7QUFDdkIsZUFBT28xQixzQkFBcUIsQ0FBQ3AxQixHQUFELENBQTVCO0FBQ0gsT0FIRTtBQUlIeTFCLDZCQUpHLG1DQUlxQnh6QixLQUpyQixFQUk0QjtBQUMzQixZQUFJemUsQ0FBSjtBQUFPLFlBQUk2SixNQUFKO0FBQ1AsWUFBTXFvQyxRQUFRLEdBQUcsRUFBakI7QUFGMkIsWUFHbkJDLFFBSG1CLEdBR05ya0MsTUFITSxDQUduQnFrQyxRQUhtQjs7QUFLM0IsYUFBS255QyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd5ZSxLQUFLLENBQUN4ZSxNQUF0QixFQUE4QkQsQ0FBQyxFQUEvQixFQUFtQztBQUMvQixjQUFNd2MsR0FBRyxHQUFHaUMsS0FBSyxDQUFDemUsQ0FBRCxDQUFqQjtBQUNBNkosZ0JBQU0sR0FBRytuQyxzQkFBcUIsQ0FBQ3AxQixHQUFELENBQXJCLElBQThCLEVBQXZDO0FBQ0EzUyxnQkFBTSxDQUFDMlMsR0FBUCxHQUFhQSxHQUFiOztBQUVBLGNBQUkyMUIsUUFBSixFQUFjO0FBQ1ZELG9CQUFRLENBQUM3dEMsSUFBVCxDQUFjd0YsTUFBZDtBQUNILFdBRkQsTUFFTyxJQUFJQSxNQUFNLENBQUNxbkMsVUFBWCxFQUF1QjtBQUMxQixtQkFBT3JuQyxNQUFQO0FBQ0g7QUFDSjs7QUFFRCxZQUFJc29DLFFBQUosRUFBYztBQUNWLGlCQUFPO0FBQ0hELG9CQUFRLEVBQVJBO0FBREcsV0FBUDtBQUdIO0FBQ0osT0ExQkU7QUEyQkhSLHFCQTNCRywyQkEyQmEveEIsaUJBM0JiLEVBMkJnQztBQUMvQixZQUFNOVYsTUFBTSxHQUFHNm5DLGdCQUFlLENBQUMveEIsaUJBQUQsQ0FBOUI7O0FBQ0EsZUFBTzlWLE1BQVA7QUFDSCxPQTlCRTtBQStCSHlsQyxvQkEvQkcsMEJBK0JZeHBCLElBL0JaLEVBK0JrQnlwQixNQS9CbEIsRUErQjBCO0FBQ3pCLFlBQUloQixPQUFPLENBQUN6b0IsSUFBRCxDQUFYLEVBQW1CO0FBQ2YsZ0JBQU0sSUFBSXJSLEtBQUosQ0FBVSxpQ0FBVixFQUE2Q3FSLElBQTdDLENBQU47QUFDSDs7QUFDRHlvQixlQUFPLENBQUN6b0IsSUFBRCxDQUFQLEdBQWdCeXBCLE1BQWhCO0FBQ0gsT0FwQ0U7QUFxQ0g2QyxnQkFyQ0csc0JBcUNRdEMsT0FyQ1IsRUFxQ2lCO0FBQ2hCO0FBQ0FoaUMsY0FBTSxDQUFDZ2lDLE9BQVAsR0FBaUJBLE9BQWpCO0FBQ0FKLHVCQUFlLENBQUN6dkMsTUFBaEIsR0FBeUIsQ0FBekI7QUFDQTB2QyxtQkFBVztBQUNkO0FBMUNFLEtBQVA7QUE0Q0g7QUE5VFUsQ0FBZixFOztBQ1hnQixxREFBUzBDLGNBQVQsR0FBMEM7QUFDdEQsTUFBSUMsTUFBYyxHQUFHLEVBQXJCOztBQUVBLFdBQVNDLFFBQVQsQ0FBa0JDLFNBQWxCLEVBQW1EO0FBQy9DLFFBQUksQ0FBQ0YsTUFBTSxDQUFDRSxTQUFELENBQVgsRUFBd0I7QUFDcEJGLFlBQU0sQ0FBQ0UsU0FBRCxDQUFOLEdBQW9CO0FBQ2hCQyxtQkFBVyxFQUFFO0FBREcsT0FBcEI7QUFHSDs7QUFDRCxXQUFPSCxNQUFNLENBQUNFLFNBQUQsQ0FBYjtBQUNIOztBQUVELFdBQVNFLFdBQVQsR0FBNkI7QUFDekJKLFVBQU0sR0FBRyxFQUFUO0FBQ0g7O0FBRUQsV0FBU0ssbUJBQVQsQ0FBNkJDLFlBQTdCLEVBQXlEMXNDLElBQXpELEVBQTRFO0FBQ3hFLFFBQUkwc0MsWUFBWSxDQUFDL1gsS0FBakIsRUFBd0I7QUFDcEJuTyxnQkFBVSxDQUFDLFlBQU07QUFDYmttQixvQkFBWSxDQUFDemtDLFFBQWIsQ0FBc0JqSSxJQUF0QjtBQUNILE9BRlMsRUFFUCxDQUZPLENBQVY7QUFHSCxLQUpELE1BSU87QUFDSDBzQyxrQkFBWSxDQUFDemtDLFFBQWIsQ0FBc0JqSSxJQUF0QjtBQUNIO0FBQ0o7O0FBRUQsV0FBUzJzQyxVQUFULENBQW9CQyxLQUFwQixFQUFzQzNrQyxRQUF0QyxFQUF5RTBzQixLQUF6RSxFQUFnRztBQUM1RixRQUFJK1gsWUFBSjs7QUFFQSxRQUFJLE9BQU96a0MsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNoQ3lrQyxrQkFBWSxHQUFHO0FBQ1h6a0MsZ0JBQVEsRUFBUkEsUUFEVztBQUVYMHNCLGFBQUssRUFBTEE7QUFGVyxPQUFmO0FBSUgsS0FMRCxNQUtPO0FBQ0grWCxrQkFBWSxHQUFHemtDLFFBQWY7O0FBQ0EsVUFBSSxDQUFDeWtDLFlBQVksQ0FBQ3prQyxRQUFsQixFQUE0QjtBQUN4QixjQUFNLElBQUlzRyxLQUFKLENBQVUsdUNBQVYsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQ4OUIsWUFBUSxDQUFDTyxLQUFELENBQVIsQ0FBZ0JMLFdBQWhCLENBQTRCcHVDLElBQTVCLENBQWlDdXVDLFlBQWpDO0FBQ0g7O0FBRUQsU0FBTztBQUNIRyxhQURHLHFCQUNPRCxLQURQLEVBQ3lCM2tDLFFBRHpCLEVBQzREMHNCLEtBRDVELEVBQ21GO0FBQ2xGLGFBQU9nWSxVQUFVLENBQUNDLEtBQUQsRUFBUTNrQyxRQUFSLEVBQWtCMHNCLEtBQWxCLENBQWpCO0FBQ0gsS0FIRTtBQUlIbVksV0FKRyxtQkFJS1IsU0FKTCxFQUkyQnRzQyxJQUozQixFQUkrQztBQUM5QyxVQUFNNHNDLEtBQUssR0FBR1AsUUFBUSxDQUFDQyxTQUFELENBQXRCO0FBRDhDLFVBRXRDQyxXQUZzQyxHQUV0QkssS0FGc0IsQ0FFdENMLFdBRnNDLEVBSTlDOztBQUNBQSxpQkFBVyxDQUFDbjBCLE1BQVosQ0FBbUIsVUFBQzIwQixVQUFEO0FBQUEsZUFBZ0IsQ0FBQyxDQUFDQSxVQUFVLENBQUNDLElBQTdCO0FBQUEsT0FBbkIsRUFBc0R6dkMsT0FBdEQsQ0FBOEQsVUFBQ3d2QyxVQUFELEVBQWdCO0FBQzFFTiwyQkFBbUIsQ0FBQ00sVUFBRCxFQUFhL3NDLElBQWIsQ0FBbkI7QUFDSCxPQUZELEVBTDhDLENBUzlDOztBQUNBNHNDLFdBQUssQ0FBQ0wsV0FBTixHQUFvQkEsV0FBVyxDQUFDbjBCLE1BQVosQ0FBbUIsVUFBQzIwQixVQUFEO0FBQUEsZUFBZ0IsQ0FBQ0EsVUFBVSxDQUFDQyxJQUE1QjtBQUFBLE9BQW5CLENBQXBCLENBVjhDLENBWTlDOztBQUNBSixXQUFLLENBQUNMLFdBQU4sQ0FBa0JodkMsT0FBbEIsQ0FBMEIsVUFBQ3d2QyxVQUFELEVBQWdCO0FBQ3RDTiwyQkFBbUIsQ0FBQ00sVUFBRCxFQUFhL3NDLElBQWIsQ0FBbkI7QUFDSCxPQUZEO0FBR0gsS0FwQkU7QUFxQkhndEMsUUFyQkcsZ0JBcUJFSixLQXJCRixFQXFCb0Iza0MsUUFyQnBCLEVBcUI2RDtBQUFBLFVBQXJCMHNCLEtBQXFCLHVFQUFiLEtBQWE7O0FBQzVEZ1ksZ0JBQVUsQ0FBQ0MsS0FBRCxFQUFRO0FBQ2Qza0MsZ0JBQVEsRUFBUkEsUUFEYztBQUVkMHNCLGFBQUssRUFBTEEsS0FGYztBQUdkcVksWUFBSSxFQUFFO0FBSFEsT0FBUixDQUFWO0FBS0gsS0EzQkU7QUE0QkhDLGVBNUJHLHVCQTRCU1gsU0E1QlQsRUE0QmdDcmtDLFFBNUJoQyxFQTRCMEU7QUFDekUsVUFBSXFrQyxTQUFKLEVBQWU7QUFDWCxZQUFNTSxNQUFLLEdBQUdQLFFBQVEsQ0FBQ0MsU0FBRCxDQUF0Qjs7QUFDQSxZQUFJTSxNQUFLLElBQUkza0MsUUFBYixFQUF1QjtBQUNuQjJrQyxnQkFBSyxDQUFDTCxXQUFOLEdBQW9CSyxNQUFLLENBQUNMLFdBQU4sQ0FBa0JuMEIsTUFBbEIsQ0FBeUIsVUFBQzIwQixVQUFEO0FBQUEsbUJBQWdCQSxVQUFVLENBQUM5a0MsUUFBWCxLQUF3QkEsUUFBeEM7QUFBQSxXQUF6QixDQUFwQjtBQUNILFNBRkQsTUFFTztBQUNIMmtDLGdCQUFLLENBQUNMLFdBQU4sR0FBb0IsRUFBcEI7QUFDSDtBQUNKLE9BUEQsTUFPTztBQUNIQyxtQkFBVztBQUNkO0FBQ0o7QUF2Q0UsR0FBUDtBQXlDSCxDQXJGZSxHQUFoQixFOzs7Ozs7Ozs7Ozs7OztBQ3ZCQSxJQUFNVSxVQUFVLEdBQUcscUpBQW5CO0FBU08sU0FBU0MsZ0JBQVQsR0FBNkQ7QUFDaEUsTUFBSTtBQUNBLFdBQU9DLFNBQVMsQ0FBQ0MsWUFBVixDQUF1QkYsZ0JBQXZCLEVBQVA7QUFDSCxHQUZELENBRUUsT0FBT3R2QixHQUFQLEVBQVk7QUFDVixRQUFNUCxLQUFZLEdBQUcsSUFBSS9PLEtBQUosNENBQThDMitCLFVBQTlDLEVBQXJCO0FBQ0E1dkIsU0FBSyxDQUFDNmUsSUFBTixHQUFhLENBQUMsQ0FBZDtBQUNBLFdBQU8zZSxPQUFPLENBQUNQLE1BQVIsQ0FBZUssS0FBZixDQUFQO0FBQ0g7QUFDSjtBQUVNLFNBQVNnd0IsWUFBVCxDQUFzQkMsV0FBdEIsRUFBaUY7QUFDcEYsTUFBSTtBQUNBLFdBQU9ILFNBQVMsQ0FBQ0MsWUFBVixDQUF1QkMsWUFBdkIsQ0FBb0NDLFdBQXBDLENBQVA7QUFDSCxHQUZELENBRUUsT0FBTzF2QixHQUFQLEVBQVk7QUFDVixRQUFNUCxLQUFZLEdBQUcsSUFBSS9PLEtBQUosd0NBQTBDMitCLFVBQTFDLEVBQXJCO0FBQ0E1dkIsU0FBSyxDQUFDNmUsSUFBTixHQUFhLENBQUMsQ0FBZDtBQUNBLFdBQU8zZSxPQUFPLENBQUNQLE1BQVIsQ0FBZUssS0FBZixDQUFQO0FBQ0g7QUFDSixDOzs7O0FDM0JEO0FBQ0E7QUFHQSxJQUFJa3dCLFNBQUo7O0FBRUEsU0FBU0MsWUFBVCxDQUFzQkMsS0FBdEIsRUFBOEQ7QUFDMUQsU0FBTyxJQUFJbHdCLE9BQUosQ0FBWSxVQUFDUixPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDcEMsUUFBSTB3QixRQUFRLEdBQUcsRUFBZjs7QUFFQSxhQUFTQyxVQUFULEdBQTRCO0FBQ3hCLFVBQUlELFFBQVEsR0FBRyxDQUFmLEVBQWtCO0FBQ2QsWUFBSUQsS0FBSyxDQUFDRyxVQUFOLEdBQW1CLEVBQW5CLElBQXlCSCxLQUFLLENBQUNJLFdBQU4sR0FBb0IsRUFBakQsRUFBcUQ7QUFDakQsY0FBSXQ0QixJQUFKLEVBQXFCO0FBQ2pCMkUsbUJBQU8sQ0FBQ0MsR0FBUixtQ0FBdUNzekIsS0FBSyxDQUFDRyxVQUE3QyxrQkFBK0RILEtBQUssQ0FBQ0ksV0FBckU7QUFDSDs7QUFDRDl3QixpQkFBTztBQUNWLFNBTEQsTUFLTztBQUNIN0gsZ0JBQU0sQ0FBQ3FSLFVBQVAsQ0FBa0JvbkIsVUFBbEIsRUFBOEIsR0FBOUI7QUFDSDtBQUNKLE9BVEQsTUFTTztBQUNIM3dCLGNBQU0sQ0FBQyxJQUFJMU8sS0FBSixDQUFVLGlEQUFWLENBQUQsQ0FBTjtBQUNIOztBQUNEby9CLGNBQVE7QUFDWDs7QUFDREMsY0FBVTtBQUNiLEdBbkJNLENBQVA7QUFvQkg7QUFFRDs7Ozs7Ozs7U0FNZUcsVTs7Ozs7b0ZBQWYsa0JBQTBCTCxLQUExQixFQUFtREgsV0FBbkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFDeUJELFlBQVksQ0FBQ0MsV0FBRCxDQURyQzs7QUFBQTtBQUNVUyxrQkFEVjtBQUVJUixxQkFBUyxHQUFHUSxNQUFaO0FBQ0FOLGlCQUFLLENBQUNPLFlBQU4sQ0FBbUIsVUFBbkIsRUFBK0IsTUFBL0I7QUFDQVAsaUJBQUssQ0FBQ08sWUFBTixDQUFtQixPQUFuQixFQUE0QixNQUE1QjtBQUNBUCxpQkFBSyxDQUFDTyxZQUFOLENBQW1CLGFBQW5CLEVBQWtDLE1BQWxDLEVBTEosQ0FLK0M7QUFDM0M7O0FBQ0FQLGlCQUFLLENBQUNRLFNBQU4sR0FBa0JGLE1BQWxCO0FBQ0FOLGlCQUFLLENBQUNTLGdCQUFOLENBQXVCLGdCQUF2QixFQUF5QyxZQUFNO0FBQzNDVCxtQkFBSyxDQUFDVSxJQUFOO0FBQ0gsYUFGRDtBQVJKLDhDQVdXWCxZQUFZLENBQUNDLEtBQUQsQ0FYdkI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQWNBLFNBQVNXLHFCQUFULENBQStCQyxnQkFBL0IsRUFBNkc7QUFDekcsTUFBTTNPLFVBQVUsR0FBR3RjLGNBQUksQ0FBQ2lyQixnQkFBRCxFQUFtQixDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLFlBQXBCLEVBQ3RDLGFBRHNDLEVBQ3ZCLFVBRHVCLENBQW5CLENBQXZCOztBQUdBLE1BQUksT0FBT0EsZ0JBQWdCLENBQUNDLGNBQXhCLEtBQTJDLFdBQTNDLElBQ09ELGdCQUFnQixDQUFDQyxjQUFqQixHQUFrQyxDQUQ3QyxFQUNnRDtBQUM1QzVPLGNBQVUsQ0FBQzZPLFdBQVgsR0FBeUJGLGdCQUFnQixDQUFDQyxjQUExQztBQUNBcDBCLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLG1GQUFaO0FBQ0g7O0FBQ0QsTUFBSSxPQUFPazBCLGdCQUFnQixDQUFDRyxNQUF4QixLQUFtQyxXQUF2QyxFQUFvRDtBQUNoRDlPLGNBQVUsQ0FBQytPLFVBQVgsR0FBd0JKLGdCQUFnQixDQUFDRyxNQUF6QztBQUNBdDBCLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLDRFQUFaO0FBQ0g7O0FBQ0QsU0FBT3VsQixVQUFQO0FBQ0gsQyxDQUVEO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU2dQLGVBQVQsR0FBc0g7QUFBQSxNQUE3RkwsZ0JBQTZGLHVFQUFyQyxFQUFxQztBQUN6SCxNQUFNWixLQUFLLEdBQUdXLHFCQUFxQixDQUFDQyxnQkFBRCxDQUFuQzs7QUFFQSxNQUFJWixLQUFLLElBQUlBLEtBQUssQ0FBQ2tCLFFBQWYsSUFBMkJsQixLQUFLLENBQUNnQixVQUFyQyxFQUFpRDtBQUM3QyxXQUFPaEIsS0FBSyxDQUFDZ0IsVUFBYjtBQUNIOztBQUNELFNBQU9seEIsT0FBTyxDQUFDUixPQUFSLENBQWdCO0FBQUU2eEIsU0FBSyxFQUFFLEtBQVQ7QUFBZ0JuQixTQUFLLEVBQUxBO0FBQWhCLEdBQWhCLENBQVA7QUFDSDs7U0FFY29CLHFCOzs7OzsrRkFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUUwQjNCLGdCQUFnQixFQUYxQzs7QUFBQTtBQUVVNEIsbUJBRlY7QUFBQSw4Q0FHV0EsT0FBTyxDQUFDMzJCLE1BQVIsQ0FBZSxVQUFDNDJCLE1BQUQ7QUFBQSxxQkFBNkJBLE1BQU0sQ0FBQ3pLLElBQVAsS0FBZ0IsWUFBN0M7QUFBQSxhQUFmLENBSFg7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQU1BLFNBQVMwSyxjQUFULEdBQW1EO0FBQy9DLE1BQUksQ0FBQ3pCLFNBQUwsRUFBZ0I7QUFDWixXQUFPLElBQVA7QUFDSDs7QUFDRCxNQUFNMEIsTUFBTSxHQUFHMUIsU0FBUyxDQUFDMkIsY0FBVixFQUFmO0FBQ0EsU0FBT0QsTUFBTSxLQUFJQSxNQUFKLGFBQUlBLE1BQUosdUJBQUlBLE1BQU0sQ0FBRW4xQyxNQUFaLENBQU4sR0FBMkJtMUMsTUFBTSxDQUFDLENBQUQsQ0FBakMsR0FBdUMsSUFBOUM7QUFDSDtBQUVEOzs7OztBQUdBLElBQU1FLG9CQUFvQixHQUFHO0FBQ25CQyxTQURtQixtQkFDWDNCLEtBRFcsRUFDY1ksZ0JBRGQsRUFDb0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUM1RUssZUFBZSxDQUFDTCxnQkFBRCxDQUQ2RDs7QUFBQTtBQUNuR2dCLDRCQURtRztBQUFBLCtDQUVsR3ZCLFVBQVUsQ0FBQ0wsS0FBRCxFQUFRNEIsY0FBUixDQUZ3Rjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUc1RyxHQUp3QjtBQUt6QkMsU0FMeUIscUJBS1Q7QUFDWjtBQUNBLFFBQU1MLE1BQU0sR0FBRzFCLFNBQVMsSUFBSUEsU0FBUyxDQUFDMkIsY0FBVixFQUE1Qjs7QUFDQSxRQUFJRCxNQUFNLElBQUlBLE1BQU0sQ0FBQ24xQyxNQUFyQixFQUE2QjtBQUN6Qm0xQyxZQUFNLENBQUMsQ0FBRCxDQUFOLENBQVU3WSxJQUFWO0FBQ0g7O0FBQ0RtWCxhQUFTLEdBQUcsSUFBWjtBQUNILEdBWndCO0FBYXpCc0IsdUJBQXFCLEVBQXJCQSxxQkFieUI7QUFjekJVLHNCQWR5QixrQ0FjTTtBQUMzQixRQUFNQyxLQUFLLEdBQUdSLGNBQWMsRUFBNUI7QUFDQSxXQUFPUSxLQUFLLEdBQUdBLEtBQUssQ0FBQ3RnQyxLQUFULEdBQWlCLEVBQTdCO0FBQ0gsR0FqQndCO0FBa0J6QjgvQixnQkFBYyxFQUFkQTtBQWxCeUIsQ0FBN0I7QUFxQmVHLHNFQUFmLEU7O0FDbkhBOztBQVNBLFNBQVNNLFFBQVQsQ0FBa0IxRSxVQUFsQixFQUFrRGxsQyxJQUFsRCxFQUE0RjtBQUN4RixTQUFPQSxJQUFJLElBQUlBLElBQUksQ0FBQzZwQyxJQUFMLENBQVUsVUFBQ3ZwQyxJQUFELEVBQVU7QUFDL0IsUUFBTThGLElBQUksR0FBRzFULE1BQU0sQ0FBQzBULElBQVAsQ0FBWTlGLElBQVosQ0FBYjtBQUNBLFdBQU84RixJQUFJLENBQUMwakMsS0FBTCxDQUFXLFVBQUN0M0MsR0FBRDtBQUFBLGFBQVM4TixJQUFJLENBQUM5TixHQUFELENBQUosS0FBYzB5QyxVQUFVLENBQUMxeUMsR0FBRCxDQUFqQztBQUFBLEtBQVgsQ0FBUDtBQUNILEdBSGMsQ0FBZjtBQUlIOztBQUVELFNBQVN1M0MsWUFBVCxDQUNJN0UsVUFESixFQUVJNXlCLE1BRkosRUFHVztBQUNQLFNBQU8sT0FBT0EsTUFBUCxLQUFrQixVQUFsQixHQUErQkEsTUFBTSxDQUFDNHlCLFVBQUQsQ0FBckMsR0FBb0QsSUFBM0Q7QUFDSDs7QUFPYztBQUNYbndDLFFBRFcsa0JBQ0orTSxNQURJLEVBQzhDO0FBQUE7O0FBQ3JELFFBQU1NLE1BQU0sR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQSxRQUFNekIsR0FBRyxHQUFHdUIsTUFBTSxDQUFDTSxVQUFQLENBQWtCLElBQWxCLENBQVo7QUFDQSxRQUFNc25DLE9BQWtDLEdBQUcsRUFBM0M7QUFDQSxRQUFJQyxRQUFRLHVCQUFHbm9DLE1BQU0sQ0FBQ21vQyxRQUFWLCtEQUFzQixFQUFsQztBQUNBLFFBQU1DLE9BQU8sR0FBR3BvQyxNQUFNLENBQUNvb0MsT0FBUCxLQUFtQixJQUFuQzs7QUFFQSxhQUFTQyxrQkFBVCxDQUE0QmpGLFVBQTVCLEVBQXFFO0FBQ2pFLGFBQU8sQ0FBQyxDQUFDK0UsUUFBRixJQUNBL0UsVUFEQSxJQUVBLENBQUMwRSxRQUFRLENBQUMxRSxVQUFELEVBQWFwakMsTUFBTSxDQUFDc29DLFNBQXBCLENBRlQsSUFHQUwsWUFBWSxDQUFDN0UsVUFBRCxFQUFhcGpDLE1BQU0sQ0FBQ3dRLE1BQXBCLENBSG5CO0FBSUg7O0FBRUQsV0FBTztBQUNIKzNCLGVBREcscUJBQ09ud0MsSUFEUCxFQUM4Qm93QyxTQUQ5QixFQUNpRHBGLFVBRGpELEVBQ3VGO0FBQ3RGLFlBQU1ybkMsTUFBVyxHQUFHLEVBQXBCLENBRHNGLENBQzdEOztBQUN6QixZQUFJc3NDLGtCQUFrQixDQUFDakYsVUFBRCxDQUF0QixFQUFvQztBQUNoQytFLGtCQUFRO0FBQ1Jwc0MsZ0JBQU0sQ0FBQ3FuQyxVQUFQLEdBQW9CQSxVQUFwQjs7QUFDQSxjQUFJZ0YsT0FBSixFQUFhO0FBQ1Q5bkMsa0JBQU0sQ0FBQ2pJLEtBQVAsR0FBZW13QyxTQUFTLENBQUM3d0MsQ0FBekI7QUFDQTJJLGtCQUFNLENBQUMvSCxNQUFQLEdBQWdCaXdDLFNBQVMsQ0FBQzV3QyxDQUExQjtBQUNBZ1gsMENBQVUsQ0FBQzNQLFNBQVgsQ0FBcUI3RyxJQUFyQixFQUEyQm93QyxTQUEzQixFQUFzQ3pwQyxHQUF0QztBQUNBaEQsa0JBQU0sQ0FBQytNLEtBQVAsR0FBZXhJLE1BQU0sQ0FBQ21vQyxTQUFQLEVBQWY7QUFDSDs7QUFDRFAsaUJBQU8sQ0FBQzN4QyxJQUFSLENBQWF3RixNQUFiO0FBQ0g7QUFDSixPQWRFO0FBZUgyc0MsZ0JBZkcsd0JBZXFDO0FBQ3BDLGVBQU9SLE9BQVA7QUFDSDtBQWpCRSxLQUFQO0FBbUJIO0FBbENVLENBQWYsRTs7QUMxQkEsSUFBTVMsU0FBK0IsR0FBRztBQUNwQzMyQixhQUFXLEVBQUU7QUFDVGdHLFFBQUksRUFBRSxNQURHO0FBRVR6TyxRQUFJLEVBQUUsWUFGRztBQUdUbzhCLGVBQVcsRUFBRTtBQUNUdHRDLFdBQUssRUFBRSxHQURFO0FBRVRFLFlBQU0sRUFBRSxHQUZDO0FBR1Q7QUFDQXV1QyxnQkFBVSxFQUFFLGFBSkgsQ0FJa0I7QUFDM0I7O0FBTFMsS0FISjtBQVVUMWlDLFFBQUksRUFBRTtBQUNGdEksU0FBRyxFQUFFLElBREg7QUFFRmxDLFdBQUssRUFBRSxJQUZMO0FBR0ZELFVBQUksRUFBRSxJQUhKO0FBSUZxSyxZQUFNLEVBQUU7QUFKTixLQVZHO0FBZ0JUOUQsaUJBQWEsRUFBRSxLQWhCTixDQWdCYTs7QUFoQmIsR0FEdUI7QUFtQnBDNFIsUUFBTSxFQUFFLElBbkI0QjtBQW9CcEM4MkIsY0FBWSxFQUFFLENBcEJzQjtBQXFCcENDLFNBQU8sRUFBRTtBQUNMN0csV0FBTyxFQUFFLENBQ0wsaUJBREssQ0FESjtBQUlMbjBCLFNBQUssRUFBRTtBQUNIazJCLHFCQUFlLEVBQUUsS0FEZDtBQUVIeEIsbUJBQWEsRUFBRSxLQUZaO0FBR0gyQixrQkFBWSxFQUFFLEtBSFg7QUFJSDFCLGlCQUFXLEVBQUU7QUFKVjtBQUpGLEdBckIyQjtBQWdDcENzRyxTQUFPLEVBQUU7QUFDTGhvQyxjQUFVLEVBQUUsSUFEUDtBQUVMMkIsYUFBUyxFQUFFLFFBRk47QUFFZ0I7QUFDckJvTCxTQUFLLEVBQUU7QUFDSEMsZ0JBQVUsRUFBRSxLQURUO0FBRUhhLGlCQUFXLEVBQUUsS0FGVjtBQUdIcUIsc0JBQWdCLEVBQUUsS0FIZjtBQUlIaUIsa0JBQVksRUFBRSxLQUpYO0FBS0hyQixnQkFBVSxFQUFFLEtBTFQ7QUFNSGdDLHFCQUFlLEVBQUUsS0FOZDtBQU9IaEIsOEJBQXdCLEVBQUUsS0FQdkI7QUFRSDNDLG9CQUFjLEVBQUU7QUFDWmEsdUJBQWUsRUFBRSxLQURMO0FBRVpDLDBCQUFrQixFQUFFLEtBRlI7QUFHWkMsY0FBTSxFQUFFO0FBSEk7QUFSYjtBQUhGO0FBaEMyQixDQUF4QztBQW9EZTI1Qix3REFBZixFOztBQ3BEQSxJQUFNSSxVQUFnQyxHQUFHO0FBQ3JDLzJCLGFBQVcsRUFBRTtBQUNUekksUUFBSSxFQUFFLGFBREc7QUFFVHkvQixZQUFRLEVBQUUsS0FGRDtBQUdUMXdDLFFBQUksRUFBRSxHQUhHO0FBSVQ4TCxRQUFJLEVBQUU7QUFDRnRJLFNBQUcsRUFBRSxJQURIO0FBRUZsQyxXQUFLLEVBQUUsSUFGTDtBQUdGRCxVQUFJLEVBQUUsSUFISjtBQUlGcUssWUFBTSxFQUFFO0FBSk4sS0FKRztBQVVUOUQsaUJBQWEsRUFBRSxLQVZOLENBVWE7O0FBVmIsR0FEd0I7QUFhckM0UixRQUFNLEVBQUUsSUFiNkI7QUFjckM4MkIsY0FBWSxFQUFFLENBZHVCO0FBZXJDQyxTQUFPLEVBQUU7QUFDTDdHLFdBQU8sRUFBRSxDQUNMLGlCQURLO0FBREosR0FmNEI7QUFvQnJDOEcsU0FBTyxFQUFFO0FBQ0xob0MsY0FBVSxFQUFFLElBRFA7QUFFTDJCLGFBQVMsRUFBRSxRQUZOLENBRWdCOztBQUZoQjtBQXBCNEIsQ0FBekM7QUEwQmVzbUMsMERBQWYsRTs7QUMxQkEsSUFBTUUsVUFBZ0MsR0FBRztBQUNyQ2ozQixhQUFXLEVBQUU7QUFDVGdHLFFBQUksRUFBRSxNQURHO0FBRVR6TyxRQUFJLEVBQUUsWUFGRztBQUdUbzhCLGVBQVcsRUFBRTtBQUNUdHRDLFdBQUssRUFBRSxHQURFO0FBRVRFLFlBQU0sRUFBRSxHQUZDO0FBR1Q7QUFDQXV1QyxnQkFBVSxFQUFFLGFBSkgsQ0FJa0I7QUFDM0I7O0FBTFMsS0FISjtBQVVUMWlDLFFBQUksRUFBRTtBQUNGdEksU0FBRyxFQUFFLElBREg7QUFFRmxDLFdBQUssRUFBRSxJQUZMO0FBR0ZELFVBQUksRUFBRSxJQUhKO0FBSUZxSyxZQUFNLEVBQUU7QUFKTixLQVZHO0FBZ0JUOUQsaUJBQWEsRUFBRSxLQWhCTixDQWdCYTs7QUFoQmIsR0FEd0I7QUFtQnJDNFIsUUFBTSxFQUFFLElBbkI2QjtBQW9CckM4MkIsY0FBWSxFQUFFLENBcEJ1QjtBQXFCckNDLFNBQU8sRUFBRTtBQUNMN0csV0FBTyxFQUFFLENBQ0wsaUJBREs7QUFESixHQXJCNEI7QUEwQnJDOEcsU0FBTyxFQUFFO0FBQ0xob0MsY0FBVSxFQUFFLElBRFA7QUFFTDJCLGFBQVMsRUFBRSxRQUZOLENBRWdCOztBQUZoQjtBQTFCNEIsQ0FBekM7QUFnQ2V3bUMsMERBQWYsRTs7QUNqQ0E7QUFDQTtDQUdBO0FBQ0E7O0FBQ0EsSUFBTUMsWUFBa0MsR0FBR3Q3QixLQUFBLEdBQ3JDKzZCLFVBRHFDLEdBRXJDLzZCLFNBRk47QUFNZXM3Qiw4REFBZixFOzs7Ozs7O0FDVk8sSUFBTUMsMkJBQWI7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQSw0Q0FTOEIsS0FUOUI7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQUEsK0NBaUIrQixFQWpCL0I7O0FBQUEsK0NBbUJ3QixJQW5CeEI7O0FBQUEsb0RBcUJzQyxJQUFJQyw2QkFBSixFQXJCdEM7QUFBQTtBQXdCTyxJQUFNQyx3QkFBYjtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFLTyxJQUFNRCw2QkFBYixHQUlJLDJCQUFjO0FBQUE7O0FBQUE7O0FBQUE7O0FBQ1YsT0FBS3JxQyxHQUFMLEdBQVcsSUFBSXNxQyx3QkFBSixFQUFYO0FBQ0EsT0FBS3Q4QixHQUFMLEdBQVcsSUFBSXM4Qix3QkFBSixFQUFYO0FBQ0gsQ0FQTCxDOzs7OztBQ2hDQTtBQUVBO0FBQ0E7QUFRQTtBQUNlLFNBQVNsOEIsdUJBQVQsQ0FDWDZFLFdBRFcsRUFFWC9aLFlBRlcsRUFHWDZ3QyxPQUhXLEVBSUM7QUFDWixNQUFNajNCLGlCQUFpQixHQUFHNVosWUFBWSxJQUFJLElBQUkyTyxnQ0FBSixDQUFpQjtBQUN2RGpQLEtBQUMsRUFBRXFhLFdBQVcsQ0FBQ0MsUUFBWixFQURvRDtBQUV2RHJhLEtBQUMsRUFBRW9hLFdBQVcsQ0FBQ0UsU0FBWixFQUZvRDtBQUd2RDNJLFFBQUksRUFBRTtBQUhpRCxHQUFqQixDQUExQzs7QUFNQSxNQUFJcUUsSUFBSixFQUFxQjtBQUNqQjJFLFdBQU8sQ0FBQ0MsR0FBUiw4QkFBa0NYLGlCQUFpQixDQUFDdlosSUFBcEQ7QUFDSDs7QUFDRCxNQUFNZ3hDLE9BQU8sR0FBRyxDQUNabDJDLHdCQUFLLENBQUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFELENBRE8sRUFFWkEsd0JBQUssQ0FBQyxDQUFDLENBQUQsRUFBSXllLGlCQUFpQixDQUFDdlosSUFBbEIsQ0FBdUJWLENBQTNCLENBQUQsQ0FGTyxFQUdaeEUsd0JBQUssQ0FBQyxDQUFDeWUsaUJBQWlCLENBQUN2WixJQUFsQixDQUF1QlgsQ0FBeEIsRUFBMkJrYSxpQkFBaUIsQ0FBQ3ZaLElBQWxCLENBQXVCVixDQUFsRCxDQUFELENBSE8sRUFJWnhFLHdCQUFLLENBQUMsQ0FBQ3llLGlCQUFpQixDQUFDdlosSUFBbEIsQ0FBdUJYLENBQXhCLEVBQTJCLENBQTNCLENBQUQsQ0FKTyxDQUFoQjtBQU1BNHhDLG9DQUFjLENBQUMxeUMsSUFBZixDQUFvQmdiLGlCQUFwQixFQUF1Q2kzQixPQUF2QztBQUNBLFNBQU87QUFBRWozQixxQkFBaUIsRUFBakJBLGlCQUFGO0FBQXFCeTNCLFdBQU8sRUFBUEE7QUFBckIsR0FBUDtBQUNILEM7O0FDbENjLFNBQVNFLHVCQUFULENBQXFCeDNDLE1BQXJCLEVBQWdFO0FBQzNFLE1BQUksT0FBT3VPLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUM7QUFDakMsV0FBTyxJQUFQO0FBQ0gsR0FIMEUsQ0FLM0U7OztBQUNBLE1BQUl2TyxNQUFNLFlBQVl5M0MsV0FBbEIsSUFBaUN6M0MsTUFBTSxDQUFDMDNDLFFBQXhDLElBQW9EMTNDLE1BQU0sQ0FBQ3FuQixRQUFQLEtBQW9CLENBQTVFLEVBQStFO0FBQzNFLFdBQU9ybkIsTUFBUDtBQUNILEdBUjBFLENBUzNFOzs7QUFDQSxNQUFNMjNDLFFBQVEsR0FBRyxPQUFPMzNDLE1BQVAsS0FBa0IsUUFBbEIsR0FBNkJBLE1BQTdCLEdBQXNDLHVCQUF2RDtBQUNBLFNBQU91TyxRQUFRLENBQUN3TixhQUFULENBQXVCNDdCLFFBQXZCLENBQVA7QUFDSCxDOztBQ1ZEOztBQUVBLFNBQVNDLGtCQUFULENBQTRCRCxRQUE1QixFQUE4Q2g4QixTQUE5QyxFQUFpRTtBQUM3RCxNQUFJck4sTUFBZ0MsR0FBR0MsUUFBUSxDQUFDd04sYUFBVCxDQUF1QjQ3QixRQUF2QixDQUF2Qzs7QUFDQSxNQUFJLENBQUNycEMsTUFBTCxFQUFhO0FBQ1RBLFVBQU0sR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLFFBQXZCLENBQVQ7QUFDQUYsVUFBTSxDQUFDcU4sU0FBUCxHQUFtQkEsU0FBbkI7QUFDSDs7QUFDRCxTQUFPck4sTUFBUDtBQUNIOztBQUVELFNBQVN1cEMsbUJBQVQsQ0FBNkJGLFFBQTdCLEVBQStDaDhCLFNBQS9DLEVBQWtFO0FBQzlELE1BQU1yTixNQUFNLEdBQUdzcEMsa0JBQWtCLENBQUNELFFBQUQsRUFBV2g4QixTQUFYLENBQWpDO0FBQ0EsTUFBTTVKLE9BQU8sR0FBR3pELE1BQU0sQ0FBQ00sVUFBUCxDQUFrQixJQUFsQixDQUFoQjtBQUNBLFNBQU87QUFBRU4sVUFBTSxFQUFOQSxNQUFGO0FBQVV5RCxXQUFPLEVBQVBBO0FBQVYsR0FBUDtBQUNIOztBQUVELFNBQVMrbEMsWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0U7QUFDOUQsTUFBSSxPQUFPeHBDLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUM7QUFDakMsUUFBTXlwQyxLQUFLLEdBQUdILG1CQUFtQixDQUFDLGtCQUFELEVBQXFCLFdBQXJCLENBQWpDO0FBQ0EsUUFBTWg2QixPQUFPLEdBQUdnNkIsbUJBQW1CLENBQUMsc0JBQUQsRUFBeUIsZUFBekIsQ0FBbkM7QUFFQUcsU0FBSyxDQUFDMXBDLE1BQU4sQ0FBYWpJLEtBQWIsR0FBcUJ3WCxPQUFPLENBQUN2UCxNQUFSLENBQWVqSSxLQUFmLEdBQXVCMHhDLFVBQVUsQ0FBQ3B5QyxDQUF2RDtBQUNBcXlDLFNBQUssQ0FBQzFwQyxNQUFOLENBQWEvSCxNQUFiLEdBQXNCc1gsT0FBTyxDQUFDdlAsTUFBUixDQUFlL0gsTUFBZixHQUF3Qnd4QyxVQUFVLENBQUNueUMsQ0FBekQ7QUFFQSxXQUFPO0FBQ0htVixTQUFHLEVBQUU7QUFDRGk5QixhQUFLLEVBQUVBLEtBQUssQ0FBQzFwQyxNQURaO0FBRUR1UCxlQUFPLEVBQUVBLE9BQU8sQ0FBQ3ZQO0FBRmhCLE9BREY7QUFLSHZCLFNBQUcsRUFBRTtBQUNEaXJDLGFBQUssRUFBRUEsS0FBSyxDQUFDam1DLE9BRFo7QUFFRDhMLGVBQU8sRUFBRUEsT0FBTyxDQUFDOUw7QUFGaEI7QUFMRixLQUFQO0FBVUg7O0FBQ0QsU0FBTyxJQUFQO0FBQ0g7O0FBRWMsU0FBUzBKLHFCQUFULENBQW9CMUosT0FBcEIsRUFBb0U7QUFBQTs7QUFDL0UsTUFBTWttQyxRQUFRLEdBQUdULHVCQUFXLENBQUN6bEMsT0FBRCxhQUFDQSxPQUFELDBDQUFDQSxPQUFPLENBQUUvRCxNQUFWLDZFQUFDLGdCQUFpQmdTLFdBQWxCLDBEQUFDLHNCQUE4QmhnQixNQUEvQixDQUE1QjtBQUNBLE1BQU11WCxJQUFJLEdBQUd4RixPQUFILGFBQUdBLE9BQUgsMkNBQUdBLE9BQU8sQ0FBRS9ELE1BQVosOEVBQUcsaUJBQWlCZ1MsV0FBcEIsMERBQUcsc0JBQThCekksSUFBM0M7QUFDQSxNQUFJLENBQUNBLElBQUwsRUFBVyxPQUFPLElBQVA7QUFDWCxNQUFNMmdDLFNBQVMsR0FBR0osWUFBWSxDQUFDL2xDLE9BQU8sQ0FBQ2lPLFdBQVIsQ0FBb0JtNEIsYUFBcEIsRUFBRCxDQUE5QjtBQUNBLE1BQUksQ0FBQ0QsU0FBTCxFQUFnQixPQUFPO0FBQUVuOUIsT0FBRyxFQUFFO0FBQUVpOUIsV0FBSyxFQUFFLElBQVQ7QUFBZW42QixhQUFPLEVBQUU7QUFBeEIsS0FBUDtBQUF1QzlRLE9BQUcsRUFBRTtBQUFFaXJDLFdBQUssRUFBRSxJQUFUO0FBQWVuNkIsYUFBTyxFQUFFO0FBQXhCO0FBQTVDLEdBQVA7QUFMK0QsTUFPdkU5QyxHQVB1RSxHQU8vRG05QixTQVArRCxDQU92RW45QixHQVB1RTs7QUFRL0UsTUFBSSxPQUFPeE0sUUFBUCxLQUFvQixXQUF4QixFQUFxQztBQUNqQyxRQUFJMHBDLFFBQUosRUFBYztBQUNWLFVBQUkxZ0MsSUFBSSxLQUFLLGFBQVQsSUFBMEIsQ0FBQzBnQyxRQUFRLENBQUNuQyxRQUFULENBQWtCLzZCLEdBQUcsQ0FBQ2k5QixLQUF0QixDQUEvQixFQUE2RDtBQUN6REMsZ0JBQVEsQ0FBQ2o4QixXQUFULENBQXFCakIsR0FBRyxDQUFDaTlCLEtBQXpCO0FBQ0g7O0FBQ0QsVUFBSSxDQUFDQyxRQUFRLENBQUNuQyxRQUFULENBQWtCLzZCLEdBQUcsQ0FBQzhDLE9BQXRCLENBQUwsRUFBcUM7QUFDakNvNkIsZ0JBQVEsQ0FBQ2o4QixXQUFULENBQXFCakIsR0FBRyxDQUFDOEMsT0FBekI7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsU0FBT3E2QixTQUFQO0FBQ0gsQzs7QUM1REQ7QUFDQTtBQUNBO0FBRUE7QUFDQSxJQUFNRSxRQUFRLEdBQUc7QUFBRSxVQUFRO0FBQVYsQ0FBakI7QUFDTyxJQUFNQyxhQUFhLEdBQUd6NUMsTUFBTSxDQUFDMFQsSUFBUCxDQUFZOGxDLFFBQVosRUFBc0IvNUIsR0FBdEIsQ0FBMEIsVUFBQzNmLEdBQUQ7QUFBQSxTQUFTMDVDLFFBQVEsQ0FBQzE1QyxHQUFELENBQWpCO0FBQUEsQ0FBMUIsQ0FBdEI7QUFFQSxTQUFTNDVDLG1CQUFULENBQTZCbHFDLEdBQTdCLEVBQXdEO0FBQUEsTUFBdEJtcUMsSUFBc0IsdUVBQWZGLGFBQWU7O0FBQzNELE1BQUksVUFBVTcxQixJQUFWLENBQWVwVSxHQUFmLENBQUosRUFBeUI7QUFDckIsV0FBT29xQyxlQUFlLENBQUNwcUMsR0FBRCxDQUFmLENBQ0Z5VixJQURFLENBQ0c0MEIsWUFESCxFQUVGNTBCLElBRkUsQ0FFRyxVQUFDMkgsTUFBRDtBQUFBLGFBQVlrdEIsZ0JBQWdCLENBQUNsdEIsTUFBRCxFQUFTK3NCLElBQVQsQ0FBNUI7QUFBQSxLQUZILENBQVA7QUFHSDs7QUFDRCxTQUFPMzBCLE9BQU8sQ0FBQ1IsT0FBUixDQUFnQixJQUFoQixDQUFQO0FBQ0g7QUFFTSxTQUFTdTFCLG1CQUFULENBQTZCQyxPQUE3QixFQUFzQztBQUN6QyxNQUFNQyxNQUFNLEdBQUdELE9BQU8sQ0FBQ3JuQixPQUFSLENBQWdCLDBCQUFoQixFQUE0QyxFQUE1QyxDQUFmO0FBQ0EsTUFBTXpXLE1BQU0sR0FBR2crQixJQUFJLENBQUNELE1BQUQsQ0FBbkI7QUFDQSxNQUFNLzFDLEdBQUcsR0FBR2dZLE1BQU0sQ0FBQzNhLE1BQW5CO0FBQ0EsTUFBTXFyQixNQUFNLEdBQUcsSUFBSW5RLFdBQUosQ0FBZ0J2WSxHQUFoQixDQUFmO0FBQ0EsTUFBTWkyQyxJQUFJLEdBQUcsSUFBSWxxQyxVQUFKLENBQWUyYyxNQUFmLENBQWI7O0FBRUEsT0FBSyxJQUFJdHJCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0QyxHQUFwQixFQUF5QjVDLENBQUMsRUFBMUIsRUFBOEI7QUFDMUI2NEMsUUFBSSxDQUFDNzRDLENBQUQsQ0FBSixHQUFVNGEsTUFBTSxDQUFDc2pCLFVBQVAsQ0FBa0JsK0IsQ0FBbEIsQ0FBVjtBQUNIOztBQUNELFNBQU9zckIsTUFBUDtBQUNIOztBQUVELFNBQVNpdEIsWUFBVCxDQUFzQk8sSUFBdEIsRUFBNEI7QUFDeEIsU0FBTyxJQUFJcDFCLE9BQUosQ0FBWSxVQUFDUixPQUFELEVBQWE7QUFDNUIsUUFBTTYxQixVQUFVLEdBQUcsSUFBSUMsVUFBSixFQUFuQjs7QUFDQUQsY0FBVSxDQUFDdHFDLE1BQVgsR0FBb0IsVUFBVW9RLENBQVYsRUFBYTtBQUM3QixhQUFPcUUsT0FBTyxDQUFDckUsQ0FBQyxDQUFDL2UsTUFBRixDQUFTK0osTUFBVixDQUFkO0FBQ0gsS0FGRDs7QUFHQWt2QyxjQUFVLENBQUNFLGlCQUFYLENBQTZCSCxJQUE3QjtBQUNILEdBTk0sQ0FBUDtBQU9IOztBQUVELFNBQVNSLGVBQVQsQ0FBeUJZLEdBQXpCLEVBQThCO0FBQzFCLFNBQU8sSUFBSXgxQixPQUFKLENBQVksVUFBQ1IsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3BDLFFBQU1nMkIsSUFBSSxHQUFHLElBQUlDLGNBQUosRUFBYjtBQUNBRCxRQUFJLENBQUNFLElBQUwsQ0FBVSxLQUFWLEVBQWlCSCxHQUFqQixFQUFzQixJQUF0QjtBQUNBQyxRQUFJLENBQUNHLFlBQUwsR0FBb0IsTUFBcEI7O0FBQ0FILFFBQUksQ0FBQ0ksa0JBQUwsR0FBMEIsWUFBWTtBQUNsQyxVQUFJSixJQUFJLENBQUNLLFVBQUwsS0FBb0JKLGNBQWMsQ0FBQ0ssSUFBbkMsS0FBNENOLElBQUksQ0FBQ08sTUFBTCxLQUFnQixHQUFoQixJQUF1QlAsSUFBSSxDQUFDTyxNQUFMLEtBQWdCLENBQW5GLENBQUosRUFBMkY7QUFDdkZ4MkIsZUFBTyxDQUFDLEtBQUt5MkIsUUFBTixDQUFQO0FBQ0g7QUFDSixLQUpEOztBQUtBUixRQUFJLENBQUNTLE9BQUwsR0FBZXoyQixNQUFmO0FBQ0FnMkIsUUFBSSxDQUFDVSxJQUFMO0FBQ0gsR0FYTSxDQUFQO0FBWUg7O0FBRU0sU0FBU3JCLGdCQUFULENBQTBCc0IsSUFBMUIsRUFBOEQ7QUFBQSxNQUE5QkMsWUFBOEIsdUVBQWY1QixhQUFlO0FBQ2pFLE1BQU02QixRQUFRLEdBQUcsSUFBSUMsUUFBSixDQUFhSCxJQUFiLENBQWpCO0FBQ0EsTUFBTTc1QyxNQUFNLEdBQUc2NUMsSUFBSSxDQUFDaG1CLFVBQXBCO0FBQ0EsTUFBTW9tQixRQUFRLEdBQUdILFlBQVksQ0FBQzFuQyxNQUFiLENBQW9CLFVBQUN4SSxNQUFELEVBQVNzd0MsV0FBVCxFQUF5QjtBQUMxRCxRQUFNQyxPQUFPLEdBQUcxN0MsTUFBTSxDQUFDMFQsSUFBUCxDQUFZOGxDLFFBQVosRUFBc0I1NUIsTUFBdEIsQ0FBNkIsVUFBQ3dHLEdBQUQ7QUFBQSxhQUFTb3pCLFFBQVEsQ0FBQ3B6QixHQUFELENBQVIsS0FBa0JxMUIsV0FBM0I7QUFBQSxLQUE3QixFQUFxRSxDQUFyRSxDQUFoQjs7QUFDQSxRQUFJQyxPQUFKLEVBQWE7QUFDVHZ3QyxZQUFNLENBQUN1d0MsT0FBRCxDQUFOLEdBQWtCRCxXQUFsQjtBQUNIOztBQUNELFdBQU90d0MsTUFBUDtBQUNILEdBTmdCLEVBTWQsRUFOYyxDQUFqQjtBQU9BLE1BQUl1RCxNQUFNLEdBQUcsQ0FBYjtBQUNBLE1BQUlpdEMsTUFBSjs7QUFFQSxNQUFLTCxRQUFRLENBQUNNLFFBQVQsQ0FBa0IsQ0FBbEIsTUFBeUIsSUFBMUIsSUFBb0NOLFFBQVEsQ0FBQ00sUUFBVCxDQUFrQixDQUFsQixNQUF5QixJQUFqRSxFQUF3RTtBQUNwRSxXQUFPLEtBQVA7QUFDSDs7QUFFRCxTQUFPbHRDLE1BQU0sR0FBR25OLE1BQWhCLEVBQXdCO0FBQ3BCLFFBQUkrNUMsUUFBUSxDQUFDTSxRQUFULENBQWtCbHRDLE1BQWxCLE1BQThCLElBQWxDLEVBQXdDO0FBQ3BDLGFBQU8sS0FBUDtBQUNIOztBQUVEaXRDLFVBQU0sR0FBR0wsUUFBUSxDQUFDTSxRQUFULENBQWtCbHRDLE1BQU0sR0FBRyxDQUEzQixDQUFUOztBQUNBLFFBQUlpdEMsTUFBTSxLQUFLLElBQWYsRUFBcUI7QUFDakIsYUFBT0UsWUFBWSxDQUFDUCxRQUFELEVBQVc1c0MsTUFBTSxHQUFHLENBQXBCLEVBQXVCOHNDLFFBQXZCLENBQW5CO0FBQ0g7O0FBQ0Q5c0MsVUFBTSxJQUFJLElBQUk0c0MsUUFBUSxDQUFDUSxTQUFULENBQW1CcHRDLE1BQU0sR0FBRyxDQUE1QixDQUFkO0FBQ0g7O0FBRUQsU0FBTyxLQUFQO0FBQ0g7O0FBRUQsU0FBU210QyxZQUFULENBQXNCVCxJQUF0QixFQUE0Qnh4QixLQUE1QixFQUFtQzR4QixRQUFuQyxFQUE2QztBQUN6QyxNQUFJTyxtQkFBbUIsQ0FBQ1gsSUFBRCxFQUFPeHhCLEtBQVAsRUFBYyxDQUFkLENBQW5CLEtBQXdDLE1BQTVDLEVBQW9EO0FBQ2hELFdBQU8sS0FBUDtBQUNIOztBQUVELE1BQU1veUIsVUFBVSxHQUFHcHlCLEtBQUssR0FBRyxDQUEzQjtBQUNBLE1BQUlxeUIsTUFBSjs7QUFFQSxNQUFJYixJQUFJLENBQUNVLFNBQUwsQ0FBZUUsVUFBZixNQUErQixNQUFuQyxFQUEyQztBQUN2Q0MsVUFBTSxHQUFHLEtBQVQ7QUFDSCxHQUZELE1BRU8sSUFBSWIsSUFBSSxDQUFDVSxTQUFMLENBQWVFLFVBQWYsTUFBK0IsTUFBbkMsRUFBMkM7QUFDOUNDLFVBQU0sR0FBRyxJQUFUO0FBQ0gsR0FGTSxNQUVBO0FBQ0gsV0FBTyxLQUFQO0FBQ0g7O0FBRUQsTUFBSWIsSUFBSSxDQUFDVSxTQUFMLENBQWVFLFVBQVUsR0FBRyxDQUE1QixFQUErQixDQUFDQyxNQUFoQyxNQUE0QyxNQUFoRCxFQUF3RDtBQUNwRCxXQUFPLEtBQVA7QUFDSDs7QUFFRCxNQUFNQyxjQUFjLEdBQUdkLElBQUksQ0FBQ2UsU0FBTCxDQUFlSCxVQUFVLEdBQUcsQ0FBNUIsRUFBK0IsQ0FBQ0MsTUFBaEMsQ0FBdkI7O0FBQ0EsTUFBSUMsY0FBYyxHQUFHLFVBQXJCLEVBQWlDO0FBQzdCLFdBQU8sS0FBUDtBQUNIOztBQUVELE1BQU12QyxJQUFJLEdBQUd5QyxRQUFRLENBQUNoQixJQUFELEVBQU9ZLFVBQVAsRUFBbUJBLFVBQVUsR0FBR0UsY0FBaEMsRUFBZ0RWLFFBQWhELEVBQTBEUyxNQUExRCxDQUFyQjtBQUNBLFNBQU90QyxJQUFQO0FBQ0g7O0FBRUQsU0FBU3lDLFFBQVQsQ0FBa0JoQixJQUFsQixFQUF3QmlCLFNBQXhCLEVBQW1DQyxRQUFuQyxFQUE2Q0MsT0FBN0MsRUFBc0ROLE1BQXRELEVBQThEO0FBQzFELE1BQU0xNUIsT0FBTyxHQUFHNjRCLElBQUksQ0FBQ1UsU0FBTCxDQUFlUSxRQUFmLEVBQXlCLENBQUNMLE1BQTFCLENBQWhCO0FBQ0EsTUFBTXRDLElBQUksR0FBRyxFQUFiOztBQUVBLE9BQUssSUFBSXI0QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaWhCLE9BQXBCLEVBQTZCamhCLENBQUMsRUFBOUIsRUFBa0M7QUFDOUIsUUFBTWs3QyxXQUFXLEdBQUdGLFFBQVEsR0FBR2g3QyxDQUFDLEdBQUcsRUFBZixHQUFvQixDQUF4QztBQUNBLFFBQU04a0IsR0FBRyxHQUFHbTJCLE9BQU8sQ0FBQ25CLElBQUksQ0FBQ1UsU0FBTCxDQUFlVSxXQUFmLEVBQTRCLENBQUNQLE1BQTdCLENBQUQsQ0FBbkI7O0FBQ0EsUUFBSTcxQixHQUFKLEVBQVM7QUFDTHV6QixVQUFJLENBQUN2ekIsR0FBRCxDQUFKLEdBQVlxMkIsWUFBWSxDQUFDckIsSUFBRCxFQUFPb0IsV0FBUCxFQUFvQkgsU0FBcEIsRUFBK0JDLFFBQS9CLEVBQXlDTCxNQUF6QyxDQUF4QjtBQUNIO0FBQ0o7O0FBQ0QsU0FBT3RDLElBQVA7QUFDSDs7QUFFRCxTQUFTOEMsWUFBVCxDQUFzQnJCLElBQXRCLEVBQTRCb0IsV0FBNUIsRUFBeUNILFNBQXpDLEVBQW9EQyxRQUFwRCxFQUE4REwsTUFBOUQsRUFBc0U7QUFDbEUsTUFBTXRqQyxJQUFJLEdBQUd5aUMsSUFBSSxDQUFDVSxTQUFMLENBQWVVLFdBQVcsR0FBRyxDQUE3QixFQUFnQyxDQUFDUCxNQUFqQyxDQUFiO0FBQ0EsTUFBTVMsU0FBUyxHQUFHdEIsSUFBSSxDQUFDZSxTQUFMLENBQWVLLFdBQVcsR0FBRyxDQUE3QixFQUFnQyxDQUFDUCxNQUFqQyxDQUFsQjs7QUFFQSxVQUFRdGpDLElBQVI7QUFDSSxTQUFLLENBQUw7QUFDSSxVQUFJK2pDLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUNqQixlQUFPdEIsSUFBSSxDQUFDVSxTQUFMLENBQWVVLFdBQVcsR0FBRyxDQUE3QixFQUFnQyxDQUFDUCxNQUFqQyxDQUFQO0FBQ0g7O0FBSlQ7O0FBT0EsU0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBU0YsbUJBQVQsQ0FBNkJudkIsTUFBN0IsRUFBcUNoRCxLQUFyQyxFQUE0Q3JvQixNQUE1QyxFQUFvRDtBQUNoRCxNQUFJbzdDLE1BQU0sR0FBRyxFQUFiOztBQUNBLE9BQUssSUFBSXpyQyxDQUFDLEdBQUcwWSxLQUFiLEVBQW9CMVksQ0FBQyxHQUFHMFksS0FBSyxHQUFHcm9CLE1BQWhDLEVBQXdDMlAsQ0FBQyxFQUF6QyxFQUE2QztBQUN6Q3lyQyxVQUFNLElBQUlobEIsTUFBTSxDQUFDaVAsWUFBUCxDQUFvQmhhLE1BQU0sQ0FBQ2d2QixRQUFQLENBQWdCMXFDLENBQWhCLENBQXBCLENBQVY7QUFDSDs7QUFDRCxTQUFPeXJDLE1BQVA7QUFDSCxDOztBQ3RKRDtBQUVBLElBQU1DLFdBQVcsR0FBRyxFQUFwQjs7QUFDQUEsV0FBVyxDQUFDQyxJQUFaLEdBQW1CLFVBQVVDLFNBQVYsRUFBcUJydEMsUUFBckIsRUFBK0JmLE1BQS9CLEVBQXVDaEgsSUFBdkMsRUFBNkMwd0MsUUFBN0MsRUFBdUQ7QUFDdEUsTUFBTTJFLGtCQUFrQixHQUFHLElBQUlsa0MsS0FBSixDQUFVblIsSUFBVixDQUEzQjtBQUNBLE1BQU1zMUMsZUFBZSxHQUFHLElBQUlua0MsS0FBSixDQUFVa2tDLGtCQUFrQixDQUFDeDdDLE1BQTdCLENBQXhCO0FBQ0EsTUFBSUQsQ0FBSjtBQUNBLE1BQUl1TyxHQUFKO0FBQ0EsTUFBSW90QyxHQUFKOztBQUVBLE1BQUk3RSxRQUFRLEtBQUssS0FBakIsRUFBd0I7QUFDcEIyRSxzQkFBa0IsQ0FBQyxDQUFELENBQWxCLEdBQXdCRCxTQUF4QjtBQUNILEdBRkQsTUFFTztBQUNILFNBQUt4N0MsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHeTdDLGtCQUFrQixDQUFDeDdDLE1BQW5DLEVBQTJDRCxDQUFDLEVBQTVDLEVBQWdEO0FBQzVDMjdDLFNBQUcsR0FBSXZ1QyxNQUFNLEdBQUdwTixDQUFoQjtBQUNBeTdDLHdCQUFrQixDQUFDejdDLENBQUQsQ0FBbEIsYUFBMkJ3N0MsU0FBM0IsbUJBQTZDLFlBQU1HLEdBQU4sRUFBYTkxQixLQUFiLENBQW1CLENBQUMsQ0FBcEIsQ0FBN0M7QUFDSDtBQUNKOztBQUNENjFCLGlCQUFlLENBQUNFLFNBQWhCLEdBQTRCLEVBQTVCOztBQUNBRixpQkFBZSxDQUFDRyxRQUFoQixHQUEyQixVQUFVL0QsS0FBVixFQUFpQjtBQUN4QzRELG1CQUFlLENBQUNFLFNBQWhCLENBQTBCdjNDLElBQTFCLENBQStCeXpDLEtBQS9CO0FBQ0gsR0FGRDs7QUFHQTRELGlCQUFlLENBQUNJLE1BQWhCLEdBQXlCLFVBQVVDLFNBQVYsRUFBcUI7QUFDMUMsUUFBTUMsYUFBYSxHQUFHTixlQUFlLENBQUNFLFNBQXRDOztBQUNBLFNBQUssSUFBSW4yQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdTJDLGFBQWEsQ0FBQy83QyxNQUFsQyxFQUEwQ3dGLENBQUMsRUFBM0MsRUFBK0M7QUFDM0MsVUFBSXUyQyxhQUFhLENBQUN2MkMsQ0FBRCxDQUFiLEtBQXFCczJDLFNBQXpCLEVBQW9DO0FBQ2hDQyxxQkFBYSxDQUFDeHJCLE1BQWQsQ0FBcUIvcUIsQ0FBckIsRUFBd0IsQ0FBeEI7O0FBQ0EsYUFBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHKzFDLGtCQUFrQixDQUFDeDdDLE1BQXZDLEVBQStDeUYsQ0FBQyxFQUFoRCxFQUFvRDtBQUNoRCxjQUFNdTJDLE9BQU8sR0FBR1Isa0JBQWtCLENBQUMvMUMsQ0FBRCxDQUFsQixDQUFzQncyQyxNQUF0QixDQUE2QlQsa0JBQWtCLENBQUMvMUMsQ0FBRCxDQUFsQixDQUFzQnkyQyxXQUF0QixDQUFrQyxHQUFsQyxDQUE3QixDQUFoQjs7QUFDQSxjQUFJSixTQUFTLENBQUM3dEMsR0FBVixDQUFjaXVDLFdBQWQsQ0FBMEJGLE9BQTFCLE1BQXVDLENBQUMsQ0FBNUMsRUFBK0M7QUFDM0NQLDJCQUFlLENBQUNoMkMsQ0FBRCxDQUFmLEdBQXFCO0FBQUU2SSxpQkFBRyxFQUFFd3RDO0FBQVAsYUFBckI7QUFDQTtBQUNIO0FBQ0o7O0FBQ0Q7QUFDSDtBQUNKOztBQUNELFFBQUlDLGFBQWEsQ0FBQy83QyxNQUFkLEtBQXlCLENBQTdCLEVBQWdDO0FBQzVCLFVBQUl5YixJQUFKLEVBQXFCO0FBQ2pCMkUsZUFBTyxDQUFDQyxHQUFSLENBQVksZUFBWjtBQUNIOztBQUNELFVBQUl3MkIsUUFBUSxLQUFLLEtBQWpCLEVBQXdCO0FBQ3BCc0IsMkJBQW1CLENBQUNvRCxTQUFELEVBQVksQ0FBQyxhQUFELENBQVosQ0FBbkIsQ0FDSzczQixJQURMLENBQ1UsVUFBQzAwQixJQUFELEVBQVU7QUFDWnFELHlCQUFlLENBQUMsQ0FBRCxDQUFmLENBQW1CckQsSUFBbkIsR0FBMEJBLElBQTFCO0FBQ0FscUMsa0JBQVEsQ0FBQ3V0QyxlQUFELENBQVI7QUFDSCxTQUpMLFdBSWEsVUFBQzc4QixDQUFELEVBQU87QUFDWndCLGlCQUFPLENBQUNDLEdBQVIsQ0FBWXpCLENBQVo7QUFDQTFRLGtCQUFRLENBQUN1dEMsZUFBRCxDQUFSO0FBQ0gsU0FQTDtBQVFILE9BVEQsTUFTTztBQUNIdnRDLGdCQUFRLENBQUN1dEMsZUFBRCxDQUFSO0FBQ0g7QUFDSjtBQUNKLEdBaENEOztBQWtDQSxPQUFLMTdDLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3k3QyxrQkFBa0IsQ0FBQ3g3QyxNQUFuQyxFQUEyQ0QsQ0FBQyxFQUE1QyxFQUFnRDtBQUM1Q3VPLE9BQUcsR0FBRyxJQUFJQyxLQUFKLEVBQU47QUFDQWt0QyxtQkFBZSxDQUFDRyxRQUFoQixDQUF5QnR0QyxHQUF6QjtBQUNBNnRDLG9CQUFnQixDQUFDN3RDLEdBQUQsRUFBTW10QyxlQUFOLENBQWhCO0FBQ0FudEMsT0FBRyxDQUFDTCxHQUFKLEdBQVV1dEMsa0JBQWtCLENBQUN6N0MsQ0FBRCxDQUE1QjtBQUNIO0FBQ0osQ0EzREQ7O0FBNkRBLFNBQVNvOEMsZ0JBQVQsQ0FBMEI3dEMsR0FBMUIsRUFBK0JtdEMsZUFBL0IsRUFBZ0Q7QUFDNUNudEMsS0FBRyxDQUFDRSxNQUFKLEdBQWEsWUFBWTtBQUNyQml0QyxtQkFBZSxDQUFDSSxNQUFoQixDQUF1QixJQUF2QjtBQUNILEdBRkQ7QUFHSDs7QUFFZVIsNERBQWhCLEU7O0FDdEVBO0FBRUE7QUFJQSxJQUFNZSxrQkFBc0MsR0FBRztBQUMzQ0MsbUJBRDJDLDZCQUN6QjFJLEtBRHlCLEVBQ0w7QUFDbEMsUUFBSTM1QixPQUE4QyxHQUFHLElBQXJEO0FBQ0EsUUFBTXNpQyxXQUFXLEdBQUcsQ0FBQyxXQUFELEVBQWMsT0FBZCxDQUFwQjtBQUNBLFFBQU1DLGNBQWdDLEdBQUcsRUFBekM7O0FBQ0EsUUFBSUMsZ0JBQUo7O0FBQ0EsUUFBSUMsaUJBQUo7O0FBQ0EsUUFBTUMsU0FBZ0IsR0FBRztBQUFFbDNDLE9BQUMsRUFBRSxDQUFMO0FBQVFDLE9BQUMsRUFBRSxDQUFYO0FBQWMyUixVQUFJLEVBQUU7QUFBcEIsS0FBekI7QUFDQSxRQUFNdWxDLFdBQW1CLEdBQUc7QUFBRW4zQyxPQUFDLEVBQUUsQ0FBTDtBQUFRQyxPQUFDLEVBQUUsQ0FBWDtBQUFjMlIsVUFBSSxFQUFFO0FBQXBCLEtBQTVCOztBQUVBLGFBQVN3bEMsUUFBVCxHQUEwQjtBQUFBOztBQUN0QixVQUFNMTJDLEtBQUssR0FBR3l0QyxLQUFLLENBQUNHLFVBQXBCO0FBQ0EsVUFBTTF0QyxNQUFNLEdBQUd1dEMsS0FBSyxDQUFDSSxXQUFyQixDQUZzQixDQUl0Qjs7QUFDQXlJLHNCQUFnQixHQUFHLGFBQUF4aUMsT0FBTyxVQUFQLDRDQUFTN1QsSUFBVCxJQUFnQkQsS0FBSyxHQUFHRSxNQUFSLEdBQWlCLENBQWpCLEdBQXFCNFQsT0FBTyxDQUFDN1QsSUFBN0IsR0FBb0M1QixJQUFJLENBQUNyQyxLQUFMLENBQVlnRSxLQUFLLEdBQUdFLE1BQVQsR0FBbUI0VCxPQUFPLENBQUM3VCxJQUF0QyxDQUFwRCxHQUFrR0QsS0FBckgsQ0FMc0IsQ0FNdEI7O0FBQ0F1MkMsdUJBQWlCLEdBQUcsYUFBQXppQyxPQUFPLFVBQVAsNENBQVM3VCxJQUFULElBQWdCRCxLQUFLLEdBQUdFLE1BQVIsR0FBaUIsQ0FBakIsR0FBcUI3QixJQUFJLENBQUNyQyxLQUFMLENBQVlrRSxNQUFNLEdBQUdGLEtBQVYsR0FBbUI4VCxPQUFPLENBQUM3VCxJQUF0QyxDQUFyQixHQUFtRTZULE9BQU8sQ0FBQzdULElBQTNGLEdBQWtHQyxNQUF0SDtBQUVBdTJDLGlCQUFXLENBQUNuM0MsQ0FBWixHQUFnQmczQyxnQkFBaEI7QUFDQUcsaUJBQVcsQ0FBQ2wzQyxDQUFaLEdBQWdCZzNDLGlCQUFoQjtBQUNIOztBQUNELFFBQU01OEIsV0FBd0IsR0FBRztBQUM3Qmc5QixrQkFENkIsMEJBQ2Q7QUFDWCxlQUFPbEosS0FBSyxDQUFDRyxVQUFiO0FBQ0gsT0FINEI7QUFLN0JnSixtQkFMNkIsMkJBS2I7QUFDWixlQUFPbkosS0FBSyxDQUFDSSxXQUFiO0FBQ0gsT0FQNEI7QUFTN0JqMEIsY0FUNkIsc0JBU2xCO0FBQ1AsZUFBTzA4QixnQkFBUDtBQUNILE9BWDRCO0FBYTdCejhCLGVBYjZCLHVCQWFqQjtBQUNSLGVBQU8wOEIsaUJBQVA7QUFDSCxPQWY0QjtBQWlCN0JqOEIsY0FqQjZCLG9CQWlCcEJ0YSxLQWpCb0IsRUFpQmI7QUFDWnMyQyx3QkFBZ0IsR0FBR3QyQyxLQUFuQjtBQUNILE9BbkI0QjtBQXFCN0J1YSxlQXJCNkIscUJBcUJuQnJhLE1BckJtQixFQXFCWDtBQUNkcTJDLHlCQUFpQixHQUFHcjJDLE1BQXBCO0FBQ0gsT0F2QjRCO0FBeUI3QjIyQyxvQkF6QjZCLDBCQXlCZGx2QyxNQXpCYyxFQXlCTjtBQUNuQjtBQUNBbU0sZUFBTyxHQUFHbk0sTUFBVixDQUZtQixDQUduQjs7QUFDQSxhQUFLcW1DLFlBQUwsQ0FBa0IsS0FBbEIsRUFBMEIsT0FBT3JtQyxNQUFNLENBQUNJLEdBQWQsS0FBc0IsV0FBdkIsR0FBc0NKLE1BQU0sQ0FBQ0ksR0FBN0MsR0FBbUQsRUFBNUU7QUFDSCxPQTlCNEI7QUFnQzdCK3VDLFdBaEM2QixtQkFnQ3JCO0FBQ0osZUFBT3JKLEtBQUssQ0FBQ3FKLEtBQWI7QUFDSCxPQWxDNEI7QUFvQzdCLzhCLGVBcEM2Qix1QkFvQ2pCO0FBQ1IsZUFBT2pHLE9BQVA7QUFDSCxPQXRDNEI7QUF3QzdCazZCLGtCQXhDNkIsd0JBd0NoQnJ1QixJQXhDZ0IsRUF3Q1ZybkIsS0F4Q1UsRUF3Q0g7QUFDdEIsWUFBSW0xQyxLQUFKLEVBQVc7QUFDUEEsZUFBSyxDQUFDTyxZQUFOLENBQW1CcnVCLElBQW5CLEVBQXlCcm5CLEtBQXpCO0FBQ0g7QUFDSixPQTVDNEI7QUE4QzdCeStDLFdBOUM2QixtQkE4Q3JCO0FBQ0p0SixhQUFLLENBQUNzSixLQUFOO0FBQ0gsT0FoRDRCO0FBa0Q3QjVJLFVBbEQ2QixrQkFrRHRCO0FBQ0g7QUFDQVYsYUFBSyxDQUFDVSxJQUFOO0FBQ0gsT0FyRDRCO0FBdUQ3QjZJLG9CQXZENkIsMEJBdURkQyxJQXZEYyxFQXVEUjtBQUFBOztBQUNqQixZQUFJLGFBQUFuakMsT0FBTyxVQUFQLDRDQUFTNUMsSUFBVCxNQUFrQixZQUF0QixFQUFvQztBQUNoQyxlQUFLODhCLFlBQUwsQ0FBa0IsYUFBbEIsRUFBaUNpSixJQUFJLENBQUMzNkIsUUFBTCxFQUFqQztBQUNIO0FBQ0osT0EzRDRCO0FBNkQ3QjR4QixzQkE3RDZCLDRCQTZEWnZCLEtBN0RZLEVBNkRMdUssQ0E3REssRUE2REZDLElBN0RFLEVBNkRJO0FBQzdCLFlBQUlmLFdBQVcsQ0FBQzVxQyxPQUFaLENBQW9CbWhDLEtBQXBCLE1BQStCLENBQUMsQ0FBcEMsRUFBdUM7QUFDbkMsY0FBSSxDQUFDMEosY0FBYyxDQUFDMUosS0FBRCxDQUFuQixFQUE0QjtBQUN4QjBKLDBCQUFjLENBQUMxSixLQUFELENBQWQsR0FBd0IsRUFBeEI7QUFDSDs7QUFDRDBKLHdCQUFjLENBQUMxSixLQUFELENBQWQsQ0FBc0J6dUMsSUFBdEIsQ0FBMkJnNUMsQ0FBM0I7QUFDSCxTQUxELE1BS087QUFDSHpKLGVBQUssQ0FBQ1MsZ0JBQU4sQ0FBdUJ2QixLQUF2QixFQUE4QnVLLENBQTlCLEVBQWlDQyxJQUFqQztBQUNIO0FBQ0osT0F0RTRCO0FBd0U3QkMsd0JBeEU2QixnQ0F3RVI7QUFDakJoQixtQkFBVyxDQUFDOTRDLE9BQVosQ0FBb0IsVUFBQyt1QyxTQUFELEVBQWU7QUFDL0IsY0FBTWdMLFFBQVEsR0FBR2hCLGNBQWMsQ0FBQ2hLLFNBQUQsQ0FBL0I7O0FBQ0EsY0FBSWdMLFFBQVEsSUFBSUEsUUFBUSxDQUFDdjlDLE1BQVQsR0FBa0IsQ0FBbEMsRUFBcUM7QUFDakN1OUMsb0JBQVEsQ0FBQy81QyxPQUFULENBQWlCLFVBQUNnNkMsT0FBRCxFQUFhO0FBQzFCN0osbUJBQUssQ0FBQzhKLG1CQUFOLENBQTBCbEwsU0FBMUIsRUFBcUNpTCxPQUFyQztBQUNILGFBRkQ7QUFHSDtBQUNKLFNBUEQ7QUFRSCxPQWpGNEI7QUFtRjdCRSxhQW5GNkIsbUJBbUZyQm5MLFNBbkZxQixFQW1GVjF1QixJQW5GVSxFQW1GSjtBQUNyQixZQUFJelQsQ0FBSixDQURxQixDQUVyQjs7QUFDQSxZQUFNbXRDLFFBQVEsR0FBR2hCLGNBQWMsQ0FBQ2hLLFNBQUQsQ0FBL0I7O0FBRUEsWUFBSUEsU0FBUyxLQUFLLFdBQWxCLEVBQStCO0FBQzNCcUssa0JBQVE7QUFDWDs7QUFDRCxZQUFJVyxRQUFRLElBQUlBLFFBQVEsQ0FBQ3Y5QyxNQUFULEdBQWtCLENBQWxDLEVBQXFDO0FBQ2pDLGVBQUtvUSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdtdEMsUUFBUSxDQUFDdjlDLE1BQXpCLEVBQWlDb1EsQ0FBQyxFQUFsQyxFQUFzQztBQUNsQ210QyxvQkFBUSxDQUFDbnRDLENBQUQsQ0FBUixDQUFZOUQsS0FBWixDQUFrQnVULFdBQWxCLEVBQStCZ0UsSUFBL0I7QUFDSDtBQUNKO0FBQ0osT0FoRzRCO0FBa0c3QjNELGlCQWxHNkIsdUJBa0dqQnk5QixRQWxHaUIsRUFrR1A7QUFDbEJqQixpQkFBUyxDQUFDbDNDLENBQVYsR0FBY200QyxRQUFRLENBQUNuNEMsQ0FBdkI7QUFDQWszQyxpQkFBUyxDQUFDajNDLENBQVYsR0FBY2s0QyxRQUFRLENBQUNsNEMsQ0FBdkI7QUFDSCxPQXJHNEI7QUF1RzdCbTRDLGlCQXZHNkIseUJBdUdmO0FBQ1YsZUFBT2xCLFNBQVA7QUFDSCxPQXpHNEI7QUEyRzdCdjhCLG1CQTNHNkIseUJBMkdmaGEsSUEzR2UsRUEyR1Q7QUFDaEJ3MkMsbUJBQVcsQ0FBQ24zQyxDQUFaLEdBQWdCVyxJQUFJLENBQUNYLENBQXJCO0FBQ0FtM0MsbUJBQVcsQ0FBQ2wzQyxDQUFaLEdBQWdCVSxJQUFJLENBQUNWLENBQXJCO0FBQ0gsT0E5RzRCO0FBZ0g3QnV5QyxtQkFoSDZCLDJCQWdIYjtBQUNaLGVBQU8yRSxXQUFQO0FBQ0gsT0FsSDRCO0FBb0g3QmtCLGNBcEg2QixzQkFvSGxCO0FBQ1AsZUFBT2xLLEtBQVA7QUFDSDtBQXRINEIsS0FBakM7QUF3SEEsV0FBTzl6QixXQUFQO0FBQ0gsR0EvSTBDO0FBZ0ozQ2krQixrQkFoSjJDLDRCQWdKMUJuSyxLQWhKMEIsRUFnSk47QUFDakMsUUFBSUEsS0FBSixFQUFXO0FBQ1BBLFdBQUssQ0FBQ08sWUFBTixDQUFtQixVQUFuQixFQUErQixNQUEvQjtBQUNIOztBQUNELFFBQU14dUMsSUFBSSxHQUFHMDJDLGtCQUFrQixDQUFDQyxpQkFBbkIsQ0FBcUMxSSxLQUFyQyxDQUFiOztBQUNBanVDLFFBQUksQ0FBQ3MzQyxLQUFMLEdBQWEsU0FBU0EsS0FBVCxHQUF3QjtBQUNqQyxhQUFPLEtBQVA7QUFDSCxLQUZEOztBQUdBLFdBQU90M0MsSUFBUDtBQUNILEdBekowQztBQTBKM0NxNEMsbUJBMUoyQywrQkEwSlY7QUFDN0IsUUFBSS9qQyxPQUErQyxHQUFHLElBQXREO0FBRUEsUUFBSTlULEtBQUssR0FBRyxDQUFaO0FBQ0EsUUFBSUUsTUFBTSxHQUFHLENBQWI7QUFDQSxRQUFJNDNDLFFBQVEsR0FBRyxDQUFmO0FBQ0EsUUFBSUMsTUFBTSxHQUFHLElBQWI7QUFDQSxRQUFJcEMsTUFBTSxHQUFHLEtBQWI7QUFDQSxRQUFJcUMsUUFBc0IsR0FBRyxJQUE3QjtBQUNBLFFBQUkvM0MsSUFBSSxHQUFHLENBQVg7QUFDQSxRQUFNZ0gsTUFBTSxHQUFHLENBQWY7QUFDQSxRQUFJZ3hDLE9BQXNCLEdBQUcsSUFBN0I7QUFDQSxRQUFJbkIsTUFBSyxHQUFHLEtBQVo7QUFDQSxRQUFJb0IsZUFBSjtBQUNBLFFBQUlDLGdCQUFKO0FBQ0EsUUFBTS9CLFdBQVcsR0FBRyxDQUFDLFdBQUQsRUFBYyxPQUFkLENBQXBCO0FBQ0EsUUFBTUMsY0FBZ0MsR0FBRyxFQUF6QztBQUNBLFFBQU1HLFNBQWdCLEdBQUc7QUFBRWwzQyxPQUFDLEVBQUUsQ0FBTDtBQUFRQyxPQUFDLEVBQUUsQ0FBWDtBQUFjMlIsVUFBSSxFQUFFO0FBQXBCLEtBQXpCO0FBQ0EsUUFBTXVsQyxXQUFtQixHQUFHO0FBQUVuM0MsT0FBQyxFQUFFLENBQUw7QUFBUUMsT0FBQyxFQUFFLENBQVg7QUFBYzJSLFVBQUksRUFBRTtBQUFwQixLQUE1Qjs7QUFFQSxhQUFTa25DLFVBQVQsR0FBNEI7QUFBQTs7QUFDeEJ6QyxZQUFNLEdBQUcsS0FBVDtBQUNBUixrQkFBVyxDQUFDQyxJQUFaLENBQWlCNkMsT0FBakIsRUFBMEIsVUFBQ0ksSUFBRCxFQUFzRDtBQUFBOztBQUM1RUwsZ0JBQVEsR0FBR0ssSUFBWCxDQUQ0RSxDQUU1RTs7QUFDQSxZQUFJQSxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFuRyxJQUFSLElBQWdCbUcsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRbkcsSUFBUixDQUFhb0csV0FBakMsRUFBOEM7QUFDMUM7QUFDQSxrQkFBUUQsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRbkcsSUFBUixDQUFhb0csV0FBckI7QUFDSSxpQkFBSyxDQUFMO0FBQ0EsaUJBQUssQ0FBTDtBQUNJdDRDLG1CQUFLLEdBQUdxNEMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRandDLEdBQVIsQ0FBWWxJLE1BQXBCO0FBQ0FBLG9CQUFNLEdBQUdtNEMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRandDLEdBQVIsQ0FBWXBJLEtBQXJCO0FBQ0E7O0FBQ0o7QUFDSUEsbUJBQUssR0FBR3E0QyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFqd0MsR0FBUixDQUFZcEksS0FBcEI7QUFDQUUsb0JBQU0sR0FBR200QyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFqd0MsR0FBUixDQUFZbEksTUFBckI7QUFSUjtBQVVILFNBWkQsTUFZTztBQUNIRixlQUFLLEdBQUdxNEMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRandDLEdBQVIsQ0FBWXBJLEtBQXBCO0FBQ0FFLGdCQUFNLEdBQUdtNEMsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRandDLEdBQVIsQ0FBWWxJLE1BQXJCO0FBQ0gsU0FsQjJFLENBbUI1RTs7O0FBQ0FnNEMsdUJBQWUsR0FBRyxhQUFBcGtDLE9BQU8sVUFBUCw0Q0FBUzdULElBQVQsSUFBZ0JELEtBQUssR0FBR0UsTUFBUixHQUFpQixDQUFqQixHQUFxQjRULE9BQU8sQ0FBQzdULElBQTdCLEdBQW9DNUIsSUFBSSxDQUFDckMsS0FBTCxDQUFZZ0UsS0FBSyxHQUFHRSxNQUFULEdBQW1CNFQsT0FBTyxDQUFDN1QsSUFBdEMsQ0FBcEQsR0FBa0dELEtBQXBILENBcEI0RSxDQXFCNUU7O0FBQ0FtNEMsd0JBQWdCLEdBQUcsYUFBQXJrQyxPQUFPLFVBQVAsNENBQVM3VCxJQUFULElBQWdCRCxLQUFLLEdBQUdFLE1BQVIsR0FBaUIsQ0FBakIsR0FBcUI3QixJQUFJLENBQUNyQyxLQUFMLENBQVlrRSxNQUFNLEdBQUdGLEtBQVYsR0FBbUI4VCxPQUFPLENBQUM3VCxJQUF0QyxDQUFyQixHQUFtRTZULE9BQU8sQ0FBQzdULElBQTNGLEdBQWtHQyxNQUFySDtBQUNBdTJDLG1CQUFXLENBQUNuM0MsQ0FBWixHQUFnQjQ0QyxlQUFoQjtBQUNBekIsbUJBQVcsQ0FBQ2wzQyxDQUFaLEdBQWdCNDRDLGdCQUFoQjtBQUNBeEMsY0FBTSxHQUFHLElBQVQ7QUFDQW1DLGdCQUFRLEdBQUcsQ0FBWDtBQUNBdnhCLGtCQUFVLENBQUMsWUFBTTtBQUNiO0FBQ0FneUIsc0JBQVksQ0FBQyxXQUFELEVBQWMsRUFBZCxDQUFaO0FBQ0gsU0FIUyxFQUdQLENBSE8sQ0FBVjtBQUlILE9BL0JELEVBK0JHdHhDLE1BL0JILEVBK0JXaEgsSUEvQlgsY0ErQmlCNlQsT0EvQmpCLDZDQStCaUIsU0FBUzY4QixRQS9CMUI7QUFnQ0g7O0FBRUQsYUFBUzRILFlBQVQsQ0FBc0JsTSxTQUF0QixFQUF5QzF1QixJQUF6QyxFQUFpRTtBQUM3RCxVQUFJelQsQ0FBSjtBQUNBLFVBQU1tdEMsUUFBUSxHQUFHaEIsY0FBYyxDQUFDaEssU0FBRCxDQUEvQjs7QUFFQSxVQUFJZ0wsUUFBUSxJQUFJQSxRQUFRLENBQUN2OUMsTUFBVCxHQUFrQixDQUFsQyxFQUFxQztBQUNqQyxhQUFLb1EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHbXRDLFFBQVEsQ0FBQ3Y5QyxNQUF6QixFQUFpQ29RLENBQUMsRUFBbEMsRUFBc0M7QUFDbEM7QUFDQW10QyxrQkFBUSxDQUFDbnRDLENBQUQsQ0FBUixDQUFZOUQsS0FBWixDQUFrQnVULFdBQWxCLEVBQStCZ0UsSUFBL0IsRUFGa0MsQ0FFVztBQUNoRDtBQUNKO0FBQ0osS0FsRTRCLENBb0U3QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSWhFLFdBQXdCLEdBQUc7QUFFM0I2OUIsYUFBTyxFQUFFZSxZQUZrQjtBQUkzQjMrQixjQUoyQixzQkFJaEI7QUFDUCxlQUFPcytCLGVBQVA7QUFDSCxPQU4wQjtBQVEzQnIrQixlQVIyQix1QkFRZjtBQUNSLGVBQU9zK0IsZ0JBQVA7QUFDSCxPQVYwQjtBQVkzQjc5QixjQVoyQixvQkFZbEJrK0IsUUFaa0IsRUFZUjtBQUNmTix1QkFBZSxHQUFHTSxRQUFsQjtBQUNILE9BZDBCO0FBZ0IzQmorQixlQWhCMkIscUJBZ0JqQmsrQixTQWhCaUIsRUFnQk47QUFDakJOLHdCQUFnQixHQUFHTSxTQUFuQjtBQUNILE9BbEIwQjtBQW9CM0I5QixrQkFwQjJCLDBCQW9CWjtBQUNYLGVBQU8zMkMsS0FBUDtBQUNILE9BdEIwQjtBQXdCM0I0MkMsbUJBeEIyQiwyQkF3Qlg7QUFDWixlQUFPMTJDLE1BQVA7QUFDSCxPQTFCMEI7QUE0QjNCMjJDLG9CQTVCMkIsMEJBNEJaOUksTUE1QlksRUE0Qko7QUFDbkI7QUFDQWo2QixlQUFPLEdBQUdpNkIsTUFBVixDQUZtQixDQUduQjs7QUFDQSxZQUFJQSxNQUFNLENBQUM0QyxRQUFQLEtBQW9CLEtBQXhCLEVBQStCO0FBQzNCO0FBQ0FzSCxpQkFBTyxHQUFHbEssTUFBTSxDQUFDaG1DLEdBQWpCO0FBQ0E5SCxjQUFJLEdBQUcsQ0FBUDtBQUNILFNBSkQsTUFJTztBQUNIO0FBQ0FnNEMsaUJBQU8sR0FBR2xLLE1BQU0sQ0FBQ2htQyxHQUFqQixDQUZHLENBR0g7O0FBQ0E5SCxjQUFJLEdBQUc4dEMsTUFBTSxDQUFDajBDLE1BQWQ7QUFDSDs7QUFDRHMrQyxrQkFBVTtBQUNiLE9BM0MwQjtBQTZDM0J0QixXQTdDMkIsbUJBNkNuQjtBQUNKLGVBQU9BLE1BQVA7QUFDSCxPQS9DMEI7QUFpRDNCOUksa0JBakQyQiwwQkFpRFosQ0FBRSxDQWpEVTtBQW1EM0JqMEIsZUFuRDJCLHVCQW1EZjtBQUNSLGVBQU9qRyxPQUFQO0FBQ0gsT0FyRDBCO0FBdUQzQmlqQyxXQXZEMkIsbUJBdURuQjtBQUNKZ0IsY0FBTSxHQUFHLElBQVQ7QUFDSCxPQXpEMEI7QUEyRDNCNUosVUEzRDJCLGtCQTJEcEI7QUFDSDRKLGNBQU0sR0FBRyxLQUFUO0FBQ0gsT0E3RDBCO0FBK0QzQmYsb0JBL0QyQiwwQkErRFpDLElBL0RZLEVBK0ROO0FBQ2pCYSxnQkFBUSxHQUFHYixJQUFYO0FBQ0gsT0FqRTBCO0FBbUUzQi9JLHNCQW5FMkIsNEJBbUVWdkIsS0FuRVUsRUFtRUh1SyxDQW5FRyxFQW1FQTtBQUN2QixZQUFJZCxXQUFXLENBQUM1cUMsT0FBWixDQUFvQm1oQyxLQUFwQixNQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ25DLGNBQUksQ0FBQzBKLGNBQWMsQ0FBQzFKLEtBQUQsQ0FBbkIsRUFBNEI7QUFDeEIwSiwwQkFBYyxDQUFDMUosS0FBRCxDQUFkLEdBQXdCLEVBQXhCO0FBQ0g7O0FBQ0QwSix3QkFBYyxDQUFDMUosS0FBRCxDQUFkLENBQXNCenVDLElBQXRCLENBQTJCZzVDLENBQTNCO0FBQ0g7QUFDSixPQTFFMEI7QUE0RTNCRSx3QkE1RTJCLGdDQTRFTjtBQUNqQjcrQyxjQUFNLENBQUMwVCxJQUFQLENBQVlvcUMsY0FBWixFQUE0Qi80QyxPQUE1QixDQUFvQyxVQUFDbzdDLEdBQUQ7QUFBQSxpQkFBUyxPQUFPckMsY0FBYyxDQUFDcUMsR0FBRCxDQUE5QjtBQUFBLFNBQXBDO0FBQ0gsT0E5RTBCO0FBZ0YzQjErQixpQkFoRjJCLHVCQWdGZnk5QixRQWhGZSxFQWdGTDtBQUNsQmpCLGlCQUFTLENBQUNsM0MsQ0FBVixHQUFjbTRDLFFBQVEsQ0FBQ240QyxDQUF2QjtBQUNBazNDLGlCQUFTLENBQUNqM0MsQ0FBVixHQUFjazRDLFFBQVEsQ0FBQ2w0QyxDQUF2QjtBQUNILE9BbkYwQjtBQXFGM0JtNEMsaUJBckYyQix5QkFxRmI7QUFDVixlQUFPbEIsU0FBUDtBQUNILE9BdkYwQjtBQXlGM0J2OEIsbUJBekYyQix5QkF5RmJ5M0IsVUF6RmEsRUF5RkQ7QUFDdEIrRSxtQkFBVyxDQUFDbjNDLENBQVosR0FBZ0JveUMsVUFBVSxDQUFDcHlDLENBQTNCO0FBQ0FtM0MsbUJBQVcsQ0FBQ2wzQyxDQUFaLEdBQWdCbXlDLFVBQVUsQ0FBQ255QyxDQUEzQjtBQUNILE9BNUYwQjtBQThGM0J1eUMsbUJBOUYyQiwyQkE4Rlg7QUFDWixlQUFPMkUsV0FBUDtBQUNILE9BaEcwQjtBQWtHM0JrQixjQWxHMkIsc0JBa0doQjtBQUNQLFlBQUlsbkMsS0FBSjs7QUFFQSxZQUFJLENBQUNrbEMsTUFBTCxFQUFhO0FBQ1QsaUJBQU8sSUFBUDtBQUNIOztBQUNELFlBQUksQ0FBQ29DLE1BQUwsRUFBYTtBQUFBOztBQUNUO0FBQ0F0bkMsZUFBSyxnQkFBR3VuQyxRQUFILDhDQUFHLFVBQVdGLFFBQVgsQ0FBUjs7QUFDQSxjQUFJQSxRQUFRLEdBQUk3M0MsSUFBSSxHQUFHLENBQXZCLEVBQTJCO0FBQ3ZCNjNDLG9CQUFRO0FBQ1gsV0FGRCxNQUVPO0FBQ0h2eEIsc0JBQVUsQ0FBQyxZQUFNO0FBQ2J1d0Isb0JBQUssR0FBRyxJQUFSO0FBQ0F5QiwwQkFBWSxDQUFDLE9BQUQsRUFBVSxFQUFWLENBQVo7QUFDSCxhQUhTLEVBR1AsQ0FITyxDQUFWO0FBSUg7QUFDSixTQWpCTSxDQWtCUDs7O0FBQ0EsZUFBTzluQyxLQUFQO0FBQ0g7QUF0SDBCLEtBQS9CO0FBd0hBLFdBQU9rSixXQUFQO0FBQ0g7QUEzVjBDLENBQS9DO0FBOFZldThCLDJFQUFmLEU7Ozs7O0FDcFdBO0FBQ0E7QUFFQTtBQU1BLElBQU15QyxVQUFVLEdBQUd0NkMsSUFBSSxDQUFDb1IsRUFBTCxHQUFVLEdBQTdCOztBQUVBLFNBQVNtcEMsZ0JBQVQsQ0FBMEIzd0MsTUFBMUIsRUFBa0M0d0MsVUFBbEMsRUFBOEM7QUFDMUMsTUFBSTV3QyxNQUFNLENBQUNqSSxLQUFQLEtBQWlCNjRDLFVBQVUsQ0FBQ3Y1QyxDQUFoQyxFQUFtQztBQUMvQixRQUFJaVcsSUFBSixFQUFxQjtBQUNqQjJFLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLDJDQUFaO0FBQ0g7O0FBQ0RsUyxVQUFNLENBQUNqSSxLQUFQLEdBQWU2NEMsVUFBVSxDQUFDdjVDLENBQTFCO0FBQ0g7O0FBQ0QsTUFBSTJJLE1BQU0sQ0FBQy9ILE1BQVAsS0FBa0IyNEMsVUFBVSxDQUFDdDVDLENBQWpDLEVBQW9DO0FBQ2hDLFFBQUlnVyxJQUFKLEVBQXFCO0FBQ2pCMkUsYUFBTyxDQUFDQyxHQUFSLENBQVksMkNBQVo7QUFDSDs7QUFDRGxTLFVBQU0sQ0FBQy9ILE1BQVAsR0FBZ0IyNEMsVUFBVSxDQUFDdDVDLENBQTNCO0FBQ0g7QUFDSjs7QUFFRCxJQUFNdTVDLFlBQVksR0FBRyxFQUFyQjs7QUFFQUEsWUFBWSxDQUFDbCtDLE1BQWIsR0FBc0IsVUFBVStlLFdBQVYsRUFBdUIxUixNQUF2QixFQUErQjtBQUNqRCxNQUFNOHdDLEtBQUssR0FBRyxFQUFkOztBQUNBLE1BQU1DLGFBQWEsR0FBR3IvQixXQUFXLENBQUNJLFNBQVosRUFBdEI7O0FBQ0EsTUFBTWsvQixVQUFVLEdBQUc1NUMsb0NBQVEsQ0FBQ3NhLFdBQVcsQ0FBQ2c5QixZQUFaLEVBQUQsRUFBNkJoOUIsV0FBVyxDQUFDaTlCLGFBQVosRUFBN0IsQ0FBM0I7O0FBQ0EsTUFBTUgsV0FBVyxHQUFHOThCLFdBQVcsQ0FBQ200QixhQUFaLEVBQXBCOztBQUNBLE1BQU1vSCxLQUFLLEdBQUc3NUMsb0NBQVEsQ0FBQ3NhLFdBQVcsQ0FBQ0MsUUFBWixFQUFELEVBQXlCRCxXQUFXLENBQUNFLFNBQVosRUFBekIsQ0FBdEI7O0FBQ0EsTUFBTTQ5QixRQUFRLEdBQUc5OUIsV0FBVyxDQUFDKzlCLFdBQVosRUFBakI7QUFDQSxNQUFNeUIsR0FBRyxHQUFHMUIsUUFBUSxDQUFDbjRDLENBQXJCO0FBQ0EsTUFBTTg1QyxHQUFHLEdBQUczQixRQUFRLENBQUNsNEMsQ0FBckI7O0FBQ0EsTUFBSThwQyxPQUFKOztBQUNBLE1BQUlnUSxJQUFJLEdBQUcsSUFBWDtBQUNBLE1BQUlDLEtBQUssR0FBRyxJQUFaO0FBRUFqUSxTQUFPLEdBQUdwaEMsTUFBTSxJQUFJQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBcEI7QUFDQWtoQyxTQUFPLENBQUNycEMsS0FBUixHQUFnQnkyQyxXQUFXLENBQUNuM0MsQ0FBNUI7QUFDQStwQyxTQUFPLENBQUNucEMsTUFBUixHQUFpQnUyQyxXQUFXLENBQUNsM0MsQ0FBN0I7QUFDQTg1QyxNQUFJLEdBQUdoUSxPQUFPLENBQUM5Z0MsVUFBUixDQUFtQixJQUFuQixDQUFQO0FBQ0Erd0MsT0FBSyxHQUFHLElBQUk5d0MsVUFBSixDQUFlMHdDLEtBQUssQ0FBQzU1QyxDQUFOLEdBQVU0NUMsS0FBSyxDQUFDMzVDLENBQS9CLENBQVI7O0FBQ0EsTUFBSWdXLElBQUosRUFBcUI7QUFDakIyRSxXQUFPLENBQUNDLEdBQVIsQ0FBWSxjQUFaLEVBQTRCQyxJQUFJLENBQUNDLFNBQUwsQ0FBZTtBQUN2Q3BhLFVBQUksRUFBRWk1QyxLQURpQztBQUV2Q3pCLGNBQVEsRUFBUkEsUUFGdUM7QUFHdkM4QixlQUFTLEVBQUVOLFVBSDRCO0FBSXZDdkgsZ0JBQVUsRUFBRStFO0FBSjJCLEtBQWYsQ0FBNUI7QUFNSDtBQUVEOzs7OztBQUdBc0MsT0FBSyxDQUFDUyxVQUFOLEdBQW1CLFVBQVV6NUMsSUFBVixFQUFnQjtBQUMvQnU1QyxTQUFLLEdBQUd2NUMsSUFBUjtBQUNILEdBRkQ7QUFJQTs7Ozs7QUFHQWc1QyxPQUFLLENBQUNVLE9BQU4sR0FBZ0IsWUFBWTtBQUN4QixXQUFPSCxLQUFQO0FBQ0gsR0FGRDtBQUlBOzs7Ozs7QUFJQVAsT0FBSyxDQUFDVyxJQUFOLEdBQWEsWUFBWTtBQUNyQixRQUFNQyxZQUFZLEdBQUdYLGFBQWEsQ0FBQ3Z3QyxVQUFuQztBQUNBLFFBQU1nSSxLQUFLLEdBQUdrSixXQUFXLENBQUNnK0IsUUFBWixFQUFkO0FBQ0EsUUFBSWlDLFFBQVEsR0FBR25wQyxLQUFmO0FBQ0EsUUFBSW9wQyxTQUFTLEdBQUcsQ0FBaEI7QUFDQSxRQUFJaHpDLE9BQUo7O0FBQ0EsUUFBSSt5QyxRQUFKLEVBQWM7QUFDVmhCLHNCQUFnQixDQUFDdlAsT0FBRCxFQUFVb04sV0FBVixDQUFoQjs7QUFDQSxVQUFJdUMsYUFBYSxDQUFDOW5DLElBQWQsS0FBdUIsYUFBM0IsRUFBMEM7QUFDdEMwb0MsZ0JBQVEsR0FBR25wQyxLQUFLLENBQUNySSxHQUFqQjs7QUFDQSxZQUFJcUksS0FBSyxDQUFDeWhDLElBQU4sSUFBY3poQyxLQUFLLENBQUN5aEMsSUFBTixDQUFXb0csV0FBN0IsRUFBMEM7QUFDdEMsa0JBQVE3bkMsS0FBSyxDQUFDeWhDLElBQU4sQ0FBV29HLFdBQW5CO0FBQ0ksaUJBQUssQ0FBTDtBQUNJdUIsdUJBQVMsR0FBRyxLQUFLbEIsVUFBakI7QUFDQTs7QUFDSixpQkFBSyxDQUFMO0FBQ0lrQix1QkFBUyxHQUFHLENBQUMsRUFBRCxHQUFNbEIsVUFBbEI7QUFDQTtBQU5SO0FBUUg7QUFDSjs7QUFFRCxVQUFJa0IsU0FBUyxLQUFLLENBQWxCLEVBQXFCO0FBQ2pCUixZQUFJLENBQUNTLFNBQUwsQ0FBZXJELFdBQVcsQ0FBQ24zQyxDQUFaLEdBQWdCLENBQS9CLEVBQWtDbTNDLFdBQVcsQ0FBQ2wzQyxDQUFaLEdBQWdCLENBQWxEOztBQUNBODVDLFlBQUksQ0FBQ3Q5QyxNQUFMLENBQVk4OUMsU0FBWjs7QUFDQVIsWUFBSSxDQUFDenlDLFNBQUwsQ0FBZWd6QyxRQUFmLEVBQXlCLENBQUNuRCxXQUFXLENBQUNsM0MsQ0FBYixHQUFpQixDQUExQyxFQUE2QyxDQUFDazNDLFdBQVcsQ0FBQ24zQyxDQUFiLEdBQWlCLENBQTlELEVBQWlFbTNDLFdBQVcsQ0FBQ2wzQyxDQUE3RSxFQUFnRmszQyxXQUFXLENBQUNuM0MsQ0FBNUY7O0FBQ0ErNUMsWUFBSSxDQUFDdDlDLE1BQUwsQ0FBWSxDQUFDODlDLFNBQWI7O0FBQ0FSLFlBQUksQ0FBQ1MsU0FBTCxDQUFlLENBQUNyRCxXQUFXLENBQUNuM0MsQ0FBYixHQUFpQixDQUFoQyxFQUFtQyxDQUFDbTNDLFdBQVcsQ0FBQ2wzQyxDQUFiLEdBQWlCLENBQXBEO0FBQ0gsT0FORCxNQU1PO0FBQ0g4NUMsWUFBSSxDQUFDenlDLFNBQUwsQ0FBZWd6QyxRQUFmLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCbkQsV0FBVyxDQUFDbjNDLENBQTNDLEVBQThDbTNDLFdBQVcsQ0FBQ2wzQyxDQUExRDtBQUNIOztBQUVEc0gsYUFBTyxHQUFHd3lDLElBQUksQ0FBQ3Z5QyxZQUFMLENBQWtCcXlDLEdBQWxCLEVBQXVCQyxHQUF2QixFQUE0QkYsS0FBSyxDQUFDNTVDLENBQWxDLEVBQXFDNDVDLEtBQUssQ0FBQzM1QyxDQUEzQyxFQUE4Q1EsSUFBeEQ7O0FBQ0EsVUFBSTQ1QyxZQUFKLEVBQWtCO0FBQ2R6eUMsbUVBQStCLENBQUNMLE9BQUQsRUFBVXF5QyxLQUFWLEVBQWlCSSxLQUFqQixDQUEvQjtBQUNILE9BRkQsTUFFTztBQUNIdnlDLCtDQUFXLENBQUNGLE9BQUQsRUFBVXl5QyxLQUFWLEVBQWlCTixhQUFqQixDQUFYO0FBQ0g7O0FBQ0QsYUFBTyxJQUFQO0FBQ0g7O0FBQ0QsV0FBTyxLQUFQO0FBQ0gsR0F6Q0Q7O0FBMkNBRCxPQUFLLENBQUNnQixPQUFOLEdBQWdCLFlBQVk7QUFDeEIsV0FBT2IsS0FBUDtBQUNILEdBRkQ7O0FBSUEsU0FBT0gsS0FBUDtBQUNILENBN0ZEOztBQStGZUQsc0VBQWYsRTs7Ozs7Ozs7QUMzSEE7Ozs7QUFPQTtBQVFBLElBQUlrQixVQUFnQyxHQUFHLEVBQXZDO0FBRU8sU0FBU0MsYUFBVCxDQUF1QkMsWUFBdkIsRUFBMEM7QUFDN0MsTUFBSUMsZUFBSjs7QUFDQSxNQUFJSCxVQUFVLENBQUNsZ0QsTUFBZixFQUF1QjtBQUNuQnFnRCxtQkFBZSxHQUFHSCxVQUFVLENBQUM3aEMsTUFBWCxDQUFrQixVQUFDaWlDLFlBQUQ7QUFBQSxhQUFrQixDQUFDQSxZQUFZLENBQUNDLElBQWhDO0FBQUEsS0FBbEIsRUFBd0QsQ0FBeEQsQ0FBbEI7O0FBQ0EsUUFBSUYsZUFBSixFQUFxQjtBQUNqQkQsa0JBQVksQ0FBQ1YsVUFBYixDQUF3QlcsZUFBZSxDQUFDcjZDLFNBQXhDOztBQUNBLFVBQUlvNkMsWUFBWSxDQUFDUixJQUFiLEVBQUosRUFBeUI7QUFDckJTLHVCQUFlLENBQUNFLElBQWhCLEdBQXVCLElBQXZCO0FBQ0FGLHVCQUFlLENBQUNHLE1BQWhCLENBQXVCQyxXQUF2QixDQUFtQztBQUMvQkMsYUFBRyxFQUFFLFNBRDBCO0FBRS9CMTZDLG1CQUFTLEVBQUVxNkMsZUFBZSxDQUFDcjZDO0FBRkksU0FBbkMsRUFHRyxDQUFDcTZDLGVBQWUsQ0FBQ3I2QyxTQUFoQixDQUEwQnFsQixNQUEzQixDQUhIO0FBSUg7O0FBQ0QsYUFBTyxJQUFQO0FBQ0gsS0FWRCxNQVVPO0FBQ0gsYUFBTyxLQUFQO0FBQ0g7QUFDSjs7QUFDRCxTQUFPLElBQVA7QUFDSDs7QUFFRCxTQUFTczFCLGVBQVQsQ0FBeUI5eUMsTUFBekIsRUFBdUQ7QUFDbkQsdURBQ09BLE1BRFA7QUFFSWdTLGVBQVcsRUFBRSw4Q0FDTmhTLE1BQU0sQ0FBQ2dTLFdBREg7QUFFUGhnQixZQUFNLEVBQUU7QUFGRDtBQUZmO0FBT0gsQyxDQUVEOzs7QUFDQSxTQUFTK2dELGVBQVQsQ0FBeUJDLE9BQXpCLEVBQWtDO0FBQzlCLE1BQUlBLE9BQUosRUFBYTtBQUNULFFBQUlDLE1BQU0sR0FBR0QsT0FBTyxhQUFwQjs7QUFDQSxRQUFJLENBQUNDLE1BQUwsRUFBYTtBQUNyQjtBQUNZN2hELFVBQUksQ0FBQ3doRCxXQUFMLENBQWlCO0FBQUUsaUJBQVMsT0FBWDtBQUFvQk0sZUFBTyxFQUFFO0FBQTdCLE9BQWpCO0FBQ0E7QUFDSDtBQUNKLEdBUjZCLENBU2xDOzs7QUFDSSxNQUFJajdDLFlBQUosQ0FWOEIsQ0FZbEM7O0FBQ0ksV0FBU2s3QyxXQUFULENBQXFCcDNDLE1BQXJCLEVBQTZCO0FBQ3pCM0ssUUFBSSxDQUFDd2hELFdBQUwsQ0FBaUI7QUFDYixlQUFTLFdBREk7QUFFekI7QUFDWXo2QyxlQUFTLEVBQUVGLFlBQVksQ0FBQ0csSUFIWDtBQUliMkQsWUFBTSxFQUFFQSxNQUpLLENBS3pCOztBQUx5QixLQUFqQixFQU1HLENBQUM5RCxZQUFZLENBQUNHLElBQWIsQ0FBa0JvbEIsTUFBbkIsQ0FOSDtBQU9IOztBQUVELFdBQVM0MUIsb0JBQVQsR0FBZ0M7QUFDNUJoaUQsUUFBSSxDQUFDd2hELFdBQUwsQ0FBaUI7QUFDYixlQUFTLGFBREk7QUFFekI7QUFDWXo2QyxlQUFTLEVBQUVGLFlBQVksQ0FBQ0csSUFIWCxDQUl6Qjs7QUFKeUIsS0FBakIsRUFLRyxDQUFDSCxZQUFZLENBQUNHLElBQWIsQ0FBa0JvbEIsTUFBbkIsQ0FMSDtBQU1ILEdBOUI2QixDQWdDbEM7OztBQUNJcHNCLE1BQUksQ0FBQ2lpRCxTQUFMLEdBQWlCLFVBQVV0aUMsQ0FBVixFQUFhO0FBQzFCLFFBQUlBLENBQUMsQ0FBQzNZLElBQUYsQ0FBT3k2QyxHQUFQLEtBQWUsTUFBbkIsRUFBMkI7QUFDdkIsVUFBSTd5QyxNQUFNLEdBQUcrUSxDQUFDLENBQUMzWSxJQUFGLENBQU80SCxNQUFwQjtBQUNBQSxZQUFNLENBQUM0b0MsWUFBUCxHQUFzQixDQUF0QjtBQUNBM3dDLGtCQUFZLEdBQUcsSUFBSWc3QyxNQUFNLENBQUNyc0MsWUFBWCxDQUF3QjtBQUNuQ2pQLFNBQUMsRUFBRW9aLENBQUMsQ0FBQzNZLElBQUYsQ0FBT0UsSUFBUCxDQUFZWCxDQURvQjtBQUVuQ0MsU0FBQyxFQUFFbVosQ0FBQyxDQUFDM1ksSUFBRixDQUFPRSxJQUFQLENBQVlWO0FBRm9CLE9BQXhCLEVBR1osSUFBSWlKLFVBQUosQ0FBZWtRLENBQUMsQ0FBQzNZLElBQUYsQ0FBT0QsU0FBdEIsQ0FIWSxDQUFmO0FBSUE4NkMsWUFBTSxDQUFDcDhDLElBQVAsQ0FBWW1KLE1BQVosRUFBb0JvekMsb0JBQXBCLEVBQTBDbjdDLFlBQTFDO0FBQ0FnN0MsWUFBTSxDQUFDRSxXQUFQLENBQW1CQSxXQUFuQjtBQUNILEtBVEQsTUFTTyxJQUFJcGlDLENBQUMsQ0FBQzNZLElBQUYsQ0FBT3k2QyxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDN0M7QUFDWTU2QyxrQkFBWSxDQUFDRyxJQUFiLEdBQW9CLElBQUl5SSxVQUFKLENBQWVrUSxDQUFDLENBQUMzWSxJQUFGLENBQU9ELFNBQXRCLENBQXBCO0FBQ0E4NkMsWUFBTSxDQUFDejRCLEtBQVA7QUFDSCxLQUpNLE1BSUEsSUFBSXpKLENBQUMsQ0FBQzNZLElBQUYsQ0FBT3k2QyxHQUFQLEtBQWUsWUFBbkIsRUFBaUM7QUFDcENJLFlBQU0sQ0FBQzNPLFVBQVAsQ0FBa0J2ekIsQ0FBQyxDQUFDM1ksSUFBRixDQUFPNHBDLE9BQXpCO0FBQ0gsS0FGTSxNQUVBLElBQUlqeEIsQ0FBQyxDQUFDM1ksSUFBRixDQUFPeTZDLEdBQVAsS0FBZSxnQkFBbkIsRUFBcUM7QUFDeENJLFlBQU0sQ0FBQ3pSLGNBQVAsQ0FBc0J6d0IsQ0FBQyxDQUFDM1ksSUFBRixDQUFPNGYsSUFBN0IsRUFBbUNqSCxDQUFDLENBQUMzWSxJQUFGLENBQU9xcEMsTUFBMUM7QUFDSDtBQUNKLEdBbkJEO0FBb0JIOztBQUVELFNBQVM2UixrQkFBVCxHQUE4QjtBQUMxQixNQUFJdEksSUFBSixFQUNJdUksYUFESjtBQUdBO0FBQ0E7O0FBQ0EsTUFBSSxPQUFPQyxpQkFBUCxLQUE2QixXQUFqQyxFQUE4QztBQUMxQztBQUNBRCxpQkFBYSxHQUFHQyxpQkFBaEIsQ0FGMEMsQ0FFUDtBQUN0QztBQUNEOzs7QUFFQXhJLE1BQUksR0FBRyxJQUFJeUksSUFBSixDQUFTLENBQUMsTUFBTVYsZUFBZSxDQUFDcCtCLFFBQWhCLEVBQU4sR0FBbUMsSUFBbkMsR0FBMEM0K0IsYUFBMUMsR0FBMEQsSUFBM0QsQ0FBVCxFQUNIO0FBQUVocUMsUUFBSSxFQUFFO0FBQVIsR0FERyxDQUFQO0FBR0EsU0FBT2dFLE1BQU0sQ0FBQ21tQyxHQUFQLENBQVdDLGVBQVgsQ0FBMkIzSSxJQUEzQixDQUFQO0FBQ0g7O0FBRU0sU0FBUzRJLFVBQVQsQ0FBb0I1ekMsTUFBcEIsRUFBa0RnUyxXQUFsRCxFQUFvRTZoQyxFQUFwRSxFQUFrRjtBQUNyRixNQUFNQyxPQUFPLEdBQUdSLGtCQUFrQixFQUFsQztBQUNBLE1BQU1YLE1BQU0sR0FBRyxJQUFJb0IsTUFBSixDQUFXRCxPQUFYLENBQWY7QUFFQSxNQUFNckIsWUFBMkIsR0FBRztBQUNoQ0UsVUFBTSxFQUFOQSxNQURnQztBQUVoQ3g2QyxhQUFTLEVBQUUsSUFBSTBJLFVBQUosQ0FBZW1SLFdBQVcsQ0FBQ0MsUUFBWixLQUF5QkQsV0FBVyxDQUFDRSxTQUFaLEVBQXhDLENBRnFCO0FBR2hDd2dDLFFBQUksRUFBRTtBQUgwQixHQUFwQzs7QUFNQUQsY0FBWSxDQUFDRSxNQUFiLENBQW9CVSxTQUFwQixHQUFnQyxVQUFVdGlDLENBQVYsRUFBYTtBQUN6QyxRQUFJQSxDQUFDLENBQUMzWSxJQUFGLENBQU80c0MsS0FBUCxLQUFpQixhQUFyQixFQUFvQztBQUNoQzBPLFNBQUcsQ0FBQ00sZUFBSixDQUFvQkYsT0FBcEI7QUFDQXJCLGtCQUFZLENBQUNDLElBQWIsR0FBb0IsS0FBcEI7QUFDQUQsa0JBQVksQ0FBQ3Q2QyxTQUFiLEdBQXlCLElBQUkwSSxVQUFKLENBQWVrUSxDQUFDLENBQUMzWSxJQUFGLENBQU9ELFNBQXRCLENBQXpCOztBQUNBLFVBQUl5VixJQUFKLEVBQXFCO0FBQ2pCMkUsZUFBTyxDQUFDQyxHQUFSLENBQVksb0JBQVo7QUFDSDs7QUFDRHFoQyxRQUFFLENBQUNwQixZQUFELENBQUY7QUFDSCxLQVJELE1BUU8sSUFBSTFoQyxDQUFDLENBQUMzWSxJQUFGLENBQU80c0MsS0FBUCxLQUFpQixXQUFyQixFQUFrQztBQUNyQ3lOLGtCQUFZLENBQUN0NkMsU0FBYixHQUF5QixJQUFJMEksVUFBSixDQUFla1EsQ0FBQyxDQUFDM1ksSUFBRixDQUFPRCxTQUF0QixDQUF6QjtBQUNBczZDLGtCQUFZLENBQUNDLElBQWIsR0FBb0IsS0FBcEIsQ0FGcUMsQ0FHckM7QUFDQTtBQUNILEtBTE0sTUFLQSxJQUFJM2hDLENBQUMsQ0FBQzNZLElBQUYsQ0FBTzRzQyxLQUFQLEtBQWlCLE9BQXJCLEVBQThCO0FBQ2pDLFVBQUlwM0IsSUFBSixFQUFxQjtBQUNqQjJFLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLG1CQUFtQnpCLENBQUMsQ0FBQzNZLElBQUYsQ0FBTzg2QyxPQUF0QztBQUNIO0FBQ0o7QUFDSixHQW5CRDs7QUFxQkFULGNBQVksQ0FBQ0UsTUFBYixDQUFvQkMsV0FBcEIsQ0FBZ0M7QUFDNUJDLE9BQUcsRUFBRSxNQUR1QjtBQUU1QnY2QyxRQUFJLEVBQUU7QUFBRVgsT0FBQyxFQUFFcWEsV0FBVyxDQUFDQyxRQUFaLEVBQUw7QUFBNkJyYSxPQUFDLEVBQUVvYSxXQUFXLENBQUNFLFNBQVo7QUFBaEMsS0FGc0I7QUFHNUIvWixhQUFTLEVBQUVzNkMsWUFBWSxDQUFDdDZDLFNBSEk7QUFJNUI2SCxVQUFNLEVBQUU4eUMsZUFBZSxDQUFDOXlDLE1BQUQ7QUFKSyxHQUFoQyxFQUtHLENBQUN5eUMsWUFBWSxDQUFDdDZDLFNBQWIsQ0FBdUJxbEIsTUFBeEIsQ0FMSDtBQU1IO0FBRU0sU0FBU3kyQixnQkFBVCxDQUEwQjlMLFFBQTFCLEVBQTRDbm9DLE1BQTVDLEVBQTJFZ1MsV0FBM0UsRUFBOEY2aEMsRUFBOUYsRUFBNkc7QUFDaEgsTUFBTUssVUFBVSxHQUFHL0wsUUFBUSxHQUFHa0ssVUFBVSxDQUFDbGdELE1BQXpDOztBQUNBLE1BQUkraEQsVUFBVSxLQUFLLENBQWYsSUFBb0JMLEVBQXhCLEVBQTRCO0FBQ3hCQSxNQUFFO0FBQ0wsR0FGRCxNQUVPLElBQUlLLFVBQVUsR0FBRyxDQUFqQixFQUFvQjtBQUN2QixRQUFNQyxrQkFBa0IsR0FBRzlCLFVBQVUsQ0FBQ3Q2QixLQUFYLENBQWlCbThCLFVBQWpCLENBQTNCO0FBQ0FDLHNCQUFrQixDQUFDeCtDLE9BQW5CLENBQTJCLFVBQVU4OEMsWUFBVixFQUF3QjtBQUMvQ0Esa0JBQVksQ0FBQ0UsTUFBYixDQUFvQnlCLFNBQXBCOztBQUNBLFVBQUl4bUMsSUFBSixFQUFxQjtBQUNqQjJFLGVBQU8sQ0FBQ0MsR0FBUixDQUFZLG9CQUFaO0FBQ0g7QUFDSixLQUxEO0FBTUE2L0IsY0FBVSxHQUFHQSxVQUFVLENBQUN0NkIsS0FBWCxDQUFpQixDQUFqQixFQUFvQm04QixVQUFwQixDQUFiOztBQUNBLFFBQUlMLEVBQUosRUFBUTtBQUNKQSxRQUFFO0FBQ0w7QUFDSixHQVpNLE1BWUE7QUFDSCxRQUFNUSxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQUM1QixZQUFELEVBQWlDO0FBQ3ZESixnQkFBVSxDQUFDOTdDLElBQVgsQ0FBZ0JrOEMsWUFBaEI7O0FBQ0EsVUFBSUosVUFBVSxDQUFDbGdELE1BQVgsSUFBcUJnMkMsUUFBckIsSUFBaUMwTCxFQUFyQyxFQUF5QztBQUNyQ0EsVUFBRTtBQUNMO0FBQ0osS0FMRDs7QUFPQSxRQUFJN3pDLE1BQUosRUFBWTtBQUNSLFdBQUssSUFBSTlOLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnaUQsVUFBcEIsRUFBZ0NoaUQsQ0FBQyxFQUFqQyxFQUFxQztBQUNqQzBoRCxrQkFBVSxDQUFDNXpDLE1BQUQsRUFBU2dTLFdBQVQsRUFBc0JxaUMsaUJBQXRCLENBQVY7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUVNLFNBQVMvUCxrQkFBVCxDQUFvQnRDLE9BQXBCLEVBQTBEO0FBQzdEcVEsWUFBVSxDQUFDMThDLE9BQVgsQ0FBbUIsVUFBQzg4QyxZQUFEO0FBQUEsV0FBa0JBLFlBQVksQ0FBQ0UsTUFBYixDQUFvQkMsV0FBcEIsQ0FBZ0M7QUFBRUMsU0FBRyxFQUFFLFlBQVA7QUFBcUI3USxhQUFPLEVBQVBBO0FBQXJCLEtBQWhDLENBQWxCO0FBQUEsR0FBbkI7QUFDSDtBQUVNLFNBQVNSLHNCQUFULENBQXdCeHBCLElBQXhCLEVBQXNDeXBCLE1BQXRDLEVBQW1EO0FBQ3RENFEsWUFBVSxDQUFDMThDLE9BQVgsQ0FBbUIsVUFBQzg4QyxZQUFEO0FBQUEsV0FBa0JBLFlBQVksQ0FBQ0UsTUFBYixDQUFvQkMsV0FBcEIsQ0FBZ0M7QUFBRUMsU0FBRyxFQUFFLGdCQUFQO0FBQXlCNzZCLFVBQUksRUFBSkEsSUFBekI7QUFBK0J5cEIsWUFBTSxFQUFOQTtBQUEvQixLQUFoQyxDQUFsQjtBQUFBLEdBQW5CO0FBQ0gsQzs7QUNyTUQ7QUFDZSxTQUFTNlMsZ0JBQVQsR0FBNEc7QUFBQSxNQUFsRi9xQyxJQUFrRix1RUFBMUQsWUFBMEQ7QUFBQSxNQUE1QzBnQyxRQUE0QztBQUFBLE1BQWxCc0ssV0FBa0I7O0FBQ3ZILFVBQVFockMsSUFBUjtBQUNJLFNBQUssYUFBTDtBQUFvQjtBQUNoQixZQUFNdThCLEtBQUssR0FBR3ZsQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBLGVBQU87QUFDSHNsQyxlQUFLLEVBQUxBLEtBREc7QUFFSDl6QixxQkFBVyxFQUFFdWlDLFdBQVcsQ0FBQy9GLGlCQUFaLENBQThCMUksS0FBOUI7QUFGVixTQUFQO0FBSUg7O0FBQ0QsU0FBSyxhQUFMO0FBQ0ksYUFBTztBQUFFOXpCLG1CQUFXLEVBQUV1aUMsV0FBVyxDQUFDckUsaUJBQVo7QUFBZixPQUFQOztBQUNKLFNBQUssWUFBTDtBQUFtQjtBQUNmLFlBQUlwSyxNQUE4QixHQUFHLElBQXJDOztBQUNBLFlBQUltRSxRQUFKLEVBQWM7QUFDVm5FLGdCQUFLLEdBQUdtRSxRQUFRLENBQUNsOEIsYUFBVCxDQUF1QixPQUF2QixDQUFSOztBQUNBLGNBQUksQ0FBQyszQixNQUFMLEVBQVk7QUFDUkEsa0JBQUssR0FBR3ZsQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBUjtBQUNBeXBDLG9CQUFRLENBQUNqOEIsV0FBVCxDQUFxQjgzQixNQUFyQjtBQUNIO0FBQ0o7O0FBQ0QsZUFBTztBQUNIQSxlQUFLLEVBQUxBLE1BREc7QUFFSDl6QixxQkFBVyxFQUFFdWlDLFdBQVcsQ0FBQ3RFLGdCQUFaLENBQTZCbkssTUFBN0I7QUFGVixTQUFQO0FBSUg7O0FBQ0Q7QUFDSXZ6QixhQUFPLENBQUNtRCxLQUFSLDJDQUFpRG5NLElBQWpEO0FBQ0EsYUFBTztBQUFFdThCLGFBQUssRUFBRSxJQUFUO0FBQWU5ekIsbUJBQVcsRUFBRTtBQUE1QixPQUFQO0FBMUJSO0FBNEJILEM7O0FDaENEO0FBT08sU0FBU3dpQyxPQUFULENBQWlCOWxDLEdBQWpCLEVBQTJCK2xDLE9BQTNCLEVBQTRDQyxPQUE1QyxFQUFtRTtBQUN0RSxNQUFJQyxNQUFNLEdBQUdqbUMsR0FBRyxDQUFDdmMsTUFBakI7O0FBQ0EsU0FBT3dpRCxNQUFNLEVBQWIsRUFBaUI7QUFDYmptQyxPQUFHLENBQUNpbUMsTUFBRCxDQUFILENBQVksQ0FBWixLQUFrQkYsT0FBbEI7QUFDQS9sQyxPQUFHLENBQUNpbUMsTUFBRCxDQUFILENBQVksQ0FBWixLQUFrQkQsT0FBbEI7QUFDSDtBQUNKO0FBRU0sU0FBU0UsUUFBVCxDQUFrQmw3QyxJQUFsQixFQUE4Qis2QyxPQUE5QixFQUErQ0MsT0FBL0MsRUFBc0U7QUFDekVoN0MsTUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRL0IsQ0FBUixJQUFhODhDLE9BQWI7QUFDQS82QyxNQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5QixDQUFSLElBQWE4OEMsT0FBYjtBQUNBaDdDLE1BQUksQ0FBQyxDQUFELENBQUosQ0FBUS9CLENBQVIsSUFBYTg4QyxPQUFiO0FBQ0EvNkMsTUFBSSxDQUFDLENBQUQsQ0FBSixDQUFROUIsQ0FBUixJQUFhODhDLE9BQWI7QUFDSCxDOzs7OztBQ3BCRDtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztJQUVxQnpCLGE7Ozs7Ozs4Q0FDUSxJQUFJOUosMkJBQUosRTs7Z0RBZ0RiLFVBQUM5b0MsUUFBRCxFQUFnQztBQUFBOztBQUN4QyxVQUFJLENBQUMsS0FBSSxDQUFDMEQsT0FBTCxDQUFhL0QsTUFBbEIsRUFBMEI7QUFDdEI7QUFDSDs7QUFDRHVwQyx3Q0FBYyxDQUFDeDNCLHFCQUFmLENBQXFDLEtBQUksQ0FBQ2hPLE9BQUwsQ0FBYWlPLFdBQWxELDBCQUErRCxLQUFJLENBQUNqTyxPQUFMLENBQWEvRCxNQUE1RSx5REFBK0QscUJBQXFCOG9DLE9BQXBGOztBQUNBLFdBQUksQ0FBQ3I3QixVQUFMOztBQUNBLFdBQUksQ0FBQzFKLE9BQUwsQ0FBYTh3QyxZQUFiLEdBQTRCMUQscUJBQVksQ0FBQ2wrQyxNQUFiLENBQ3hCLEtBQUksQ0FBQzhRLE9BQUwsQ0FBYWlPLFdBRFcsRUFFeEIsS0FBSSxDQUFDak8sT0FBTCxDQUFhK3dDLGVBQWIsQ0FBNkIvbkMsR0FBN0IsQ0FBaUNpOUIsS0FGVCxDQUE1Qjs7QUFLQSxVQUFJLEtBQUksQ0FBQ2ptQyxPQUFMLENBQWEvRCxNQUFiLENBQW9CNG9DLFlBQXBCLEtBQXFDMzhCLFNBQXpDLEVBQW9EO0FBQ2hELGFBQUksQ0FBQ2xJLE9BQUwsQ0FBYS9ELE1BQWIsQ0FBb0I0b0MsWUFBcEIsR0FBbUMsQ0FBbkM7QUFDSDs7QUFFRG1NLHNCQUFBLENBQTBCLEtBQUksQ0FBQ2h4QyxPQUFMLENBQWEvRCxNQUFiLENBQW9CNG9DLFlBQTlDLEVBQ0ksS0FBSSxDQUFDN2tDLE9BQUwsQ0FBYS9ELE1BRGpCLEVBRUksS0FBSSxDQUFDK0QsT0FBTCxDQUFhaU8sV0FGakIsRUFHSSxZQUFNO0FBQUE7O0FBQ0YsWUFBSSwrQkFBSSxDQUFDak8sT0FBTCxDQUFhL0QsTUFBYixnRkFBcUI0b0MsWUFBckIsTUFBc0MsQ0FBMUMsRUFBNkM7QUFDekMsZUFBSSxDQUFDb00sY0FBTDtBQUNIOztBQUNELGFBQUksQ0FBQ0MsS0FBTCxDQUFXNTBDLFFBQVg7QUFDSCxPQVJMO0FBU0gsSzs7NkNBd0hRLFlBQVk7QUFDakIsVUFBSSxLQUFJLENBQUMwRCxPQUFMLENBQWFteEMsVUFBakIsRUFBNkI7QUFDekIsWUFBTUMsY0FBYyxHQUFHSixhQUFBLENBQXVCLEtBQUksQ0FBQ2h4QyxPQUFMLENBQWE4d0MsWUFBcEMsQ0FBdkI7O0FBQ0EsWUFBSSxDQUFDTSxjQUFMLEVBQXFCO0FBQUE7O0FBQ2pCLGVBQUksQ0FBQ3B4QyxPQUFMLENBQWE4d0MsWUFBYixDQUEwQmhELFVBQTFCLDBCQUFxQyxLQUFJLENBQUM5dEMsT0FBTCxDQUFhOE4saUJBQWxELDBEQUFxQyxzQkFBZ0N6WixJQUFyRTs7QUFDQSxjQUFJLEtBQUksQ0FBQzJMLE9BQUwsQ0FBYTh3QyxZQUFiLENBQTBCOUMsSUFBMUIsRUFBSixFQUFzQztBQUNsQyxnQkFBSSxDQUFDb0QsY0FBTCxFQUFxQjtBQUNqQixtQkFBSSxDQUFDQyxlQUFMO0FBQ0g7QUFDSjtBQUNKO0FBQ0osT0FWRCxNQVVPO0FBQUE7O0FBQ0gsYUFBSSxDQUFDcnhDLE9BQUwsQ0FBYTh3QyxZQUFiLENBQTBCaEQsVUFBMUIsMkJBQXFDLEtBQUksQ0FBQzl0QyxPQUFMLENBQWE4TixpQkFBbEQsMkRBQXFDLHVCQUFnQ3paLElBQXJFOztBQUNBLGFBQUksQ0FBQzJMLE9BQUwsQ0FBYTh3QyxZQUFiLENBQTBCOUMsSUFBMUI7O0FBQ0EsYUFBSSxDQUFDcUQsZUFBTDtBQUNIO0FBQ0osSzs7Ozs7Z0NBOU1XbjlDLFksRUFBbUM7QUFDM0MsVUFBSSxDQUFDLEtBQUs4TCxPQUFMLENBQWEvRCxNQUFsQixFQUEwQjtBQUN0QjtBQUNIOztBQUgwQywwQkFJSnExQyx1QkFBWSxDQUMvQyxLQUFLdHhDLE9BQUwsQ0FBYWlPLFdBRGtDLEVBRS9DL1osWUFGK0MsRUFHL0MsS0FBSzhMLE9BQUwsQ0FBYS9ELE1BQWIsQ0FBb0I4b0MsT0FIMkIsQ0FKUjtBQUFBLFVBSW5DajNCLGlCQUptQyxpQkFJbkNBLGlCQUptQztBQUFBLFVBSWhCeTNCLE9BSmdCLGlCQUloQkEsT0FKZ0I7O0FBUzNDLFdBQUt2bEMsT0FBTCxDQUFhOE4saUJBQWIsR0FBaUNBLGlCQUFqQztBQUNBLFdBQUs5TixPQUFMLENBQWF1bEMsT0FBYixHQUF1QkEsT0FBdkI7QUFDSDs7O21DQUVjcnhDLFksRUFBbUM7QUFDOUMsVUFBSSxDQUFDLEtBQUs4TCxPQUFMLENBQWEvRCxNQUFsQixFQUEwQjtBQUN0QjtBQUNIOztBQUNELFdBQUttTixXQUFMLENBQWlCbFYsWUFBakI7QUFDQSxXQUFLOEwsT0FBTCxDQUFhOGtDLE9BQWIsR0FBdUJ5TSxlQUFjLENBQUNyaUQsTUFBZixDQUFzQixLQUFLOFEsT0FBTCxDQUFhL0QsTUFBYixDQUFvQjZvQyxPQUExQyxFQUFtRCxLQUFLOWtDLE9BQUwsQ0FBYThOLGlCQUFoRSxDQUF2QjtBQUNIOzs7a0NBRTZCO0FBQzFCLFVBQUksQ0FBQyxLQUFLOU4sT0FBTCxDQUFhL0QsTUFBZCxJQUF3QixDQUFDLEtBQUsrRCxPQUFMLENBQWEvRCxNQUFiLENBQW9CZ1MsV0FBakQsRUFBOEQ7QUFDMUQsZUFBTyxJQUFQO0FBQ0g7O0FBSHlCLFVBSWxCaGdCLE1BSmtCLEdBSVAsS0FBSytSLE9BQUwsQ0FBYS9ELE1BQWIsQ0FBb0JnUyxXQUpiLENBSWxCaGdCLE1BSmtCO0FBSzFCLGFBQU91akQsdUJBQVksQ0FBQ3ZqRCxNQUFELENBQW5CO0FBQ0g7OzswQkFFS3FPLFEsRUFBNEI7QUFDOUIsV0FBSzBELE9BQUwsQ0FBYWlPLFdBQWIsQ0FBeUJ3MEIsSUFBekI7QUFDQW5tQyxjQUFRO0FBQ1g7OztpQ0FFa0I7QUFDZixVQUFNNnBDLFNBQVMsR0FBR3NMLHFCQUFXLENBQUMsS0FBS3p4QyxPQUFOLENBQTdCOztBQUNBLFVBQUksQ0FBQ21tQyxTQUFMLEVBQWdCO0FBQ1o7QUFDSDs7QUFKYyxVQUtQbnJDLEdBTE8sR0FLTW1yQyxTQUxOLENBS1BuckMsR0FMTztBQUFBLFVBS0ZnTyxHQUxFLEdBS01tOUIsU0FMTixDQUtGbjlCLEdBTEU7QUFNZixXQUFLaEosT0FBTCxDQUFhK3dDLGVBQWIsQ0FBNkIvbkMsR0FBN0IsQ0FBaUNpOUIsS0FBakMsR0FBeUNqOUIsR0FBRyxDQUFDaTlCLEtBQTdDO0FBQ0EsV0FBS2ptQyxPQUFMLENBQWErd0MsZUFBYixDQUE2Qi9uQyxHQUE3QixDQUFpQzhDLE9BQWpDLEdBQTJDOUMsR0FBRyxDQUFDOEMsT0FBL0M7QUFDQSxXQUFLOUwsT0FBTCxDQUFhK3dDLGVBQWIsQ0FBNkIvMUMsR0FBN0IsQ0FBaUNpckMsS0FBakMsR0FBeUNqckMsR0FBRyxDQUFDaXJDLEtBQTdDO0FBQ0EsV0FBS2ptQyxPQUFMLENBQWErd0MsZUFBYixDQUE2Qi8xQyxHQUE3QixDQUFpQzhRLE9BQWpDLEdBQTJDOVEsR0FBRyxDQUFDOFEsT0FBL0M7QUFDSDs7O29DQTRCZXhQLFEsRUFBdUM7QUFDbkQsVUFBSSxDQUFDLEtBQUswRCxPQUFMLENBQWEvRCxNQUFkLElBQXdCLENBQUMsS0FBSytELE9BQUwsQ0FBYS9ELE1BQWIsQ0FBb0JnUyxXQUFqRCxFQUE4RDtBQUMxRDtBQUNIOztBQUhrRCxrQ0FJVixLQUFLak8sT0FBTCxDQUFhL0QsTUFBYixDQUFvQmdTLFdBSlY7QUFBQSxVQUlyQ3lqQyxTQUpxQyx5QkFJM0Nsc0MsSUFKMkM7QUFBQSxVQUkxQm84QixXQUowQix5QkFJMUJBLFdBSjBCOztBQUFBLDhCQUtwQjJPLGdCQUFnQixDQUFDbUIsU0FBRCxFQUFZLEtBQUtqTSxXQUFMLEVBQVosRUFBZ0MrSyxvQkFBaEMsQ0FMSTtBQUFBLFVBSzNDek8sS0FMMkMscUJBSzNDQSxLQUwyQztBQUFBLFVBS3BDOXpCLFdBTG9DLHFCQUtwQ0EsV0FMb0M7O0FBT25ELFVBQUl5akMsU0FBUyxLQUFLLFlBQWQsSUFBOEIzUCxLQUFsQyxFQUF5QztBQUNyQzRQLHFCQUFZLENBQUNqTyxPQUFiLENBQXFCM0IsS0FBckIsRUFBNEJILFdBQTVCLEVBQ0s5dkIsSUFETCxDQUNVO0FBQUEsaUJBQU03RCxXQUFXLENBQUM2OUIsT0FBWixDQUFvQixXQUFwQixDQUFOO0FBQUEsU0FEVixXQUVXLFVBQUM1NUIsR0FBRDtBQUFBLGlCQUFTNVYsUUFBUSxDQUFDNFYsR0FBRCxDQUFqQjtBQUFBLFNBRlg7QUFHSDs7QUFFRGpFLGlCQUFXLENBQUNxMEIsWUFBWixDQUF5QixTQUF6QixFQUFvQyxNQUFwQztBQUNBcjBCLGlCQUFXLENBQUNrOUIsY0FBWixDQUEyQixLQUFLbnJDLE9BQUwsQ0FBYS9ELE1BQWIsQ0FBb0JnUyxXQUEvQztBQUNBQSxpQkFBVyxDQUFDdTBCLGdCQUFaLENBQTZCLFdBQTdCLEVBQTBDLEtBQUtvUCxTQUFMLENBQWVDLElBQWYsQ0FBb0IzcEMsU0FBcEIsRUFBK0I1TCxRQUEvQixDQUExQztBQUVBLFdBQUswRCxPQUFMLENBQWFpTyxXQUFiLEdBQTJCQSxXQUEzQjtBQUNIOzs7dUNBRStDO0FBQUE7O0FBQzVDLGFBQU8sK0JBQUtqTyxPQUFMLENBQWEvRCxNQUFiLGdGQUFxQjhSLE1BQXJCLElBQThCeTNCLGtDQUFjLENBQUN6M0IsTUFBZixFQUE5QixHQUNELENBQUMsQ0FDQzFlLHdCQUFLLENBQUMsS0FBSzJRLE9BQUwsQ0FBYXVsQyxPQUFiLENBQXFCLENBQXJCLENBQUQsQ0FETixFQUVDbDJDLHdCQUFLLENBQUMsS0FBSzJRLE9BQUwsQ0FBYXVsQyxPQUFiLENBQXFCLENBQXJCLENBQUQsQ0FGTixFQUdDbDJDLHdCQUFLLENBQUMsS0FBSzJRLE9BQUwsQ0FBYXVsQyxPQUFiLENBQXFCLENBQXJCLENBQUQsQ0FITixFQUlDbDJDLHdCQUFLLENBQUMsS0FBSzJRLE9BQUwsQ0FBYXVsQyxPQUFiLENBQXFCLENBQXJCLENBQUQsQ0FKTixDQUFELENBRE47QUFPSCxLLENBRUQ7QUFDQTs7OztvQ0FDZ0J2dEMsTSxFQUFtQjtBQUFBOztBQUMvQixVQUFNK3pDLFFBQVEsR0FBRyxLQUFLL3JDLE9BQUwsQ0FBYWlPLFdBQWIsQ0FBeUIrOUIsV0FBekIsRUFBakI7QUFDQSxVQUFNMEUsT0FBTyxHQUFHM0UsUUFBUSxDQUFDbjRDLENBQXpCO0FBQ0EsVUFBTSs4QyxPQUFPLEdBQUc1RSxRQUFRLENBQUNsNEMsQ0FBekI7O0FBRUEsVUFBSTY4QyxPQUFPLEtBQUssQ0FBWixJQUFpQkMsT0FBTyxLQUFLLENBQWpDLEVBQW9DO0FBQ2hDO0FBQ0g7O0FBRUQsVUFBSTM0QyxNQUFNLENBQUNxb0MsUUFBWCxFQUFxQjtBQUNqQjtBQUNBcm9DLGNBQU0sQ0FBQ3FvQyxRQUFQLENBQWdCenVDLE9BQWhCLENBQXdCLFVBQUNrZ0QsT0FBRDtBQUFBLGlCQUEwQixNQUFJLENBQUNDLGVBQUwsQ0FBcUJELE9BQXJCLENBQTFCO0FBQUEsU0FBeEI7QUFDSDs7QUFFRCxVQUFJOTVDLE1BQU0sQ0FBQ3JDLElBQVAsSUFBZXFDLE1BQU0sQ0FBQ3JDLElBQVAsQ0FBWXZILE1BQVosS0FBdUIsQ0FBMUMsRUFBNkM7QUFDekN5aUQsZ0JBQVEsQ0FBQzc0QyxNQUFNLENBQUNyQyxJQUFSLEVBQWMrNkMsT0FBZCxFQUF1QkMsT0FBdkIsQ0FBUjtBQUNIOztBQUVELFVBQUkzNEMsTUFBTSxDQUFDMlMsR0FBWCxFQUFnQjtBQUNaOGxDLGVBQU8sQ0FBQ3o0QyxNQUFNLENBQUMyUyxHQUFSLEVBQWErbEMsT0FBYixFQUFzQkMsT0FBdEIsQ0FBUDtBQUNIOztBQUVELFVBQUkzNEMsTUFBTSxDQUFDNFUsS0FBUCxJQUFnQjVVLE1BQU0sQ0FBQzRVLEtBQVAsQ0FBYXhlLE1BQWIsR0FBc0IsQ0FBMUMsRUFBNkM7QUFDekMsYUFBSyxJQUFJRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNkosTUFBTSxDQUFDNFUsS0FBUCxDQUFheGUsTUFBakMsRUFBeUNELENBQUMsRUFBMUMsRUFBOEM7QUFDMUNzaUQsaUJBQU8sQ0FBQ3o0QyxNQUFNLENBQUM0VSxLQUFQLENBQWF6ZSxDQUFiLENBQUQsRUFBa0J1aUQsT0FBbEIsRUFBMkJDLE9BQTNCLENBQVA7QUFDSDtBQUNKO0FBQ0o7Ozs4QkFFUzM0QyxNLEVBQThCNUQsUyxFQUFnQztBQUFBOztBQUNwRSxVQUFJLENBQUNBLFNBQUQsSUFBYyxDQUFDLEtBQUs0TCxPQUFMLENBQWFneUMsZUFBaEMsRUFBaUQ7QUFDN0M7QUFDSCxPQUhtRSxDQUtwRTs7O0FBQ0EsVUFBSWg2QyxNQUFNLENBQUNxb0MsUUFBWCxFQUFxQjtBQUNqQnJvQyxjQUFNLENBQUNxb0MsUUFBUCxDQUFnQjV6QixNQUFoQixDQUF1QixVQUFDcWxDLE9BQUQ7QUFBQSxpQkFBbUNBLE9BQU8sQ0FBQ3pTLFVBQTNDO0FBQUEsU0FBdkIsRUFDS3p0QyxPQURMLENBQ2EsVUFBQ2tnRCxPQUFEO0FBQUEsaUJBQW1DLE1BQUksQ0FBQ3ROLFNBQUwsQ0FBZXNOLE9BQWYsRUFBd0IxOUMsU0FBeEIsQ0FBbkM7QUFBQSxTQURiO0FBRUgsT0FIRCxNQUdPLElBQUk0RCxNQUFNLENBQUNxbkMsVUFBWCxFQUF1QjtBQUMxQixhQUFLci9CLE9BQUwsQ0FBYWd5QyxlQUFiLENBQTZCeE4sU0FBN0IsQ0FDSXB3QyxTQURKLEVBRUksS0FBSzRMLE9BQUwsQ0FBYWlPLFdBQWIsQ0FBeUJtNEIsYUFBekIsRUFGSixFQUdJcHVDLE1BQU0sQ0FBQ3FuQyxVQUhYO0FBS0g7QUFDSixLLENBRUQ7Ozs7a0NBQ2NybkMsTSxFQUF1QztBQUNqRCxhQUFPLENBQUMsRUFBRUEsTUFBTSxLQUFLQSxNQUFNLENBQUNxb0MsUUFBUCxHQUNmcm9DLE1BQU0sQ0FBQ3FvQyxRQUFQLENBQWdCMkQsSUFBaEIsQ0FBcUIsVUFBQzhOLE9BQUQ7QUFBQSxlQUFhQSxPQUFPLENBQUN6UyxVQUFyQjtBQUFBLE9BQXJCLENBRGUsR0FFZnJuQyxNQUFNLENBQUNxbkMsVUFGRyxDQUFSLENBQVI7QUFHSCxLLENBRUQ7Ozs7b0NBQ2lGO0FBQUEsVUFBbkVybkMsTUFBbUUsdUVBQTdCLElBQTZCO0FBQUEsVUFBdkI1RCxTQUF1QjtBQUM3RSxVQUFJNjlDLGVBQTBFLEdBQUdqNkMsTUFBakY7O0FBRUEsVUFBSUEsTUFBTSxJQUFJLEtBQUtnSSxPQUFMLENBQWFteEMsVUFBM0IsRUFBdUM7QUFDbkMsYUFBS1ksZUFBTCxDQUFxQi81QyxNQUFyQjtBQUNBLGFBQUt3c0MsU0FBTCxDQUFleHNDLE1BQWYsRUFBdUI1RCxTQUF2QjtBQUNBNjlDLHVCQUFlLEdBQUdqNkMsTUFBTSxDQUFDcW9DLFFBQVAsSUFBbUJyb0MsTUFBckM7QUFDSDs7QUFFRGs2QyxZQUFNLENBQUMvUSxPQUFQLENBQWUsV0FBZixFQUE0QjhRLGVBQTVCOztBQUNBLFVBQUksS0FBS0UsYUFBTCxDQUFtQm42QyxNQUFuQixDQUFKLEVBQXdEO0FBQ3BEazZDLGNBQU0sQ0FBQy9RLE9BQVAsQ0FBZSxVQUFmLEVBQTJCOFEsZUFBM0I7QUFDSDtBQUNKOzs7c0NBRXVCO0FBQ3BCLFVBQU1ybEMsS0FBSyxHQUFHLEtBQUt3bEMsZ0JBQUwsRUFBZDs7QUFDQSxVQUFJeGxDLEtBQUosRUFBVztBQUFBOztBQUNQLFlBQU15bEMsWUFBWSxHQUFHLEtBQUtyeUMsT0FBTCxDQUFhOGtDLE9BQWIsQ0FBcUIxRSx1QkFBckIsQ0FBNkN4ekIsS0FBN0MsS0FBdUQsRUFBNUU7QUFDQXlsQyxvQkFBWSxDQUFDemxDLEtBQWIsR0FBcUJBLEtBQXJCO0FBQ0EsYUFBSzBsQyxhQUFMLENBQW1CRCxZQUFuQiw0QkFBaUMsS0FBS3J5QyxPQUFMLENBQWE4TixpQkFBOUMsMkRBQWlDLHVCQUFnQ3paLElBQWpFO0FBQ0gsT0FKRCxNQUlPO0FBQ0gsWUFBTWsrQyxXQUFXLEdBQUcsS0FBS3Z5QyxPQUFMLENBQWE4a0MsT0FBYixDQUFxQmpGLGVBQXJCLENBQXFDLEtBQUs3L0IsT0FBTCxDQUFhOE4saUJBQWxELENBQXBCOztBQUNBLFlBQUl5a0MsV0FBSixFQUFpQjtBQUFBOztBQUNiLGVBQUtELGFBQUwsQ0FBbUJDLFdBQW5CLDRCQUFnQyxLQUFLdnlDLE9BQUwsQ0FBYThOLGlCQUE3QywyREFBZ0MsdUJBQWdDelosSUFBaEU7QUFDSCxTQUZELE1BRU87QUFDSCxlQUFLaStDLGFBQUw7QUFDSDtBQUNKO0FBQ0o7Ozs0Q0FvQjZCO0FBQUE7QUFBQTs7QUFDMUIsVUFBSTV2QyxJQUFtQixHQUFHLElBQTFCO0FBQ0EsVUFBTTh2QyxLQUFLLEdBQUcsUUFBUSwrQkFBS3h5QyxPQUFMLENBQWEvRCxNQUFiLGdGQUFxQjJoQyxTQUFyQixLQUFrQyxFQUExQyxDQUFkO0FBRUEsV0FBSzU5QixPQUFMLENBQWF5eUMsT0FBYixHQUF1QixLQUF2QjtBQUowQixVQUtsQnp5QyxPQUxrQixHQUtOLElBTE0sQ0FLbEJBLE9BTGtCOztBQU8xQixVQUFNaUYsUUFBUSxHQUFHLFNBQVhBLFFBQVcsQ0FBQ3l0QyxTQUFELEVBQXVCO0FBQ3BDaHdDLFlBQUksR0FBR0EsSUFBSSxJQUFJZ3dDLFNBQWY7O0FBQ0EsWUFBSSxDQUFDMXlDLE9BQU8sQ0FBQ3l5QyxPQUFiLEVBQXNCO0FBQ2xCLGNBQUlDLFNBQVMsSUFBSWh3QyxJQUFqQixFQUF1QjtBQUNuQkEsZ0JBQUksSUFBSTh2QyxLQUFSOztBQUNBLGtCQUFJLENBQUNHLE1BQUw7QUFDSDs7QUFDRG5wQyxnQkFBTSxDQUFDZ1IscUJBQVAsQ0FBNkJ2VixRQUE3QjtBQUNIO0FBQ0osT0FURDs7QUFXQUEsY0FBUSxDQUFDMnRDLFdBQVcsQ0FBQ3J0QixHQUFaLEVBQUQsQ0FBUjtBQUNIOzs7NEJBRWE7QUFBQTs7QUFDVixVQUFJLEtBQUt2bEIsT0FBTCxDQUFhbXhDLFVBQWIsSUFBMkIsK0JBQUtueEMsT0FBTCxDQUFhL0QsTUFBYix5R0FBcUJnUyxXQUFyQixnRkFBa0N6SSxJQUFsQyxNQUEyQyxZQUExRSxFQUF3RjtBQUNwRixhQUFLcXRDLHFCQUFMO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBS0YsTUFBTDtBQUNIO0FBQ0o7OzsyQkFFWTtBQUFBOztBQUNULFdBQUszeUMsT0FBTCxDQUFheXlDLE9BQWIsR0FBdUIsSUFBdkI7QUFDQXpCLHNCQUFBLENBQTBCLENBQTFCOztBQUNBLFVBQUksK0JBQUtoeEMsT0FBTCxDQUFhL0QsTUFBYixnRkFBcUJnUyxXQUFyQixLQUFvQyxLQUFLak8sT0FBTCxDQUFhL0QsTUFBYixDQUFvQmdTLFdBQXBCLENBQWdDekksSUFBaEMsS0FBeUMsWUFBakYsRUFBK0Y7QUFDM0Ztc0MscUJBQVksQ0FBQy9OLE9BQWI7QUFDQSxhQUFLNWpDLE9BQUwsQ0FBYWlPLFdBQWIsQ0FBeUJ5OUIsa0JBQXpCO0FBQ0g7QUFDSjs7OytCQUVVek4sTyxFQUE0QztBQUNuRCxVQUFJLEtBQUtqK0IsT0FBTCxDQUFhOGtDLE9BQWpCLEVBQTBCO0FBQ3RCLGFBQUs5a0MsT0FBTCxDQUFhOGtDLE9BQWIsQ0FBcUJ2RSxVQUFyQixDQUFnQ3RDLE9BQWhDO0FBQ0g7O0FBQ0QrUyx3QkFBQSxDQUFvQi9TLE9BQXBCO0FBQ0g7OzttQ0FFY2hxQixJLEVBQWN5cEIsTSxFQUFvQztBQUM3RDZULHFCQUFjLENBQUM5VCxjQUFmLENBQThCeHBCLElBQTlCLEVBQW9DeXBCLE1BQXBDOztBQUNBLFVBQUksS0FBSzE5QixPQUFMLENBQWE4a0MsT0FBakIsRUFBMEI7QUFDdEIsYUFBSzlrQyxPQUFMLENBQWE4a0MsT0FBYixDQUFxQnJILGNBQXJCLENBQW9DeHBCLElBQXBDLEVBQTBDeXBCLE1BQTFDO0FBQ0g7O0FBQ0RzVCw0QkFBQSxDQUF3Qi84QixJQUF4QixFQUE4QnlwQixNQUE5QjtBQUNIOzs7Ozs7Ozs7Q0N4UnFDOztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBLElBQU03dkMsUUFBUSxHQUFHLElBQUlxaEQsYUFBSixFQUFqQjtBQUNBLElBQU00RCxRQUFRLEdBQUdqbEQsUUFBUSxDQUFDbVMsT0FBMUI7QUFFQSxJQUFNK3lDLHVCQUF1QixHQUFHO0FBQzVCamdELE1BQUksRUFBRSxjQUFVbUosTUFBVixFQUFrQjZ6QyxFQUFsQixFQUFzQjU3QyxZQUF0QixFQUErRDtBQUFBLFFBQTNCOCtDLGNBQTJCLHVFQUFWbmxELFFBQVU7QUFDakUsUUFBSW9sRCxPQUFKOztBQUNBLFFBQUksQ0FBQ25ELEVBQUwsRUFBUztBQUNMbUQsYUFBTyxHQUFHLElBQUlwaEMsT0FBSixDQUFZLFVBQUNSLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUN2Q3crQixVQUFFLEdBQUcsWUFBQzU5QixHQUFELEVBQVM7QUFBRUEsYUFBRyxHQUFHWixNQUFNLENBQUNZLEdBQUQsQ0FBVCxHQUFpQmIsT0FBTyxFQUEzQjtBQUFnQyxTQUFoRDtBQUNILE9BRlMsQ0FBVjtBQUdIOztBQUNEMmhDLGtCQUFjLENBQUNoekMsT0FBZixDQUF1Qi9ELE1BQXZCLEdBQWdDNEosZUFBSyxDQUFDLEVBQUQsRUFBS3F0QyxhQUFMLEVBQWFqM0MsTUFBYixDQUFyQyxDQVBpRSxDQVFqRTs7QUFDQSxRQUFJKzJDLGNBQWMsQ0FBQ2h6QyxPQUFmLENBQXVCL0QsTUFBdkIsQ0FBOEI0b0MsWUFBOUIsR0FBNkMsQ0FBakQsRUFBb0Q7QUFDaERtTyxvQkFBYyxDQUFDaHpDLE9BQWYsQ0FBdUIvRCxNQUF2QixDQUE4QjRvQyxZQUE5QixHQUE2QyxDQUE3QztBQUNIOztBQUNELFFBQUkzd0MsWUFBSixFQUFrQjtBQUNkOCtDLG9CQUFjLENBQUNoekMsT0FBZixDQUF1Qm14QyxVQUF2QixHQUFvQyxLQUFwQztBQUNBNkIsb0JBQWMsQ0FBQy9CLGNBQWYsQ0FBOEIvOEMsWUFBOUI7O0FBQ0EsVUFBSTQ3QyxFQUFKLEVBQVE7QUFDSkEsVUFBRTtBQUNMO0FBQ0osS0FORCxNQU1PO0FBQ0hrRCxvQkFBYyxDQUFDRyxlQUFmLENBQStCckQsRUFBL0I7QUFDSDs7QUFDRCxXQUFPbUQsT0FBUDtBQUNILEdBdkIyQjtBQXdCNUJ4OEIsT0FBSyxFQUFFLGlCQUFZO0FBQ2Y1b0IsWUFBUSxDQUFDNG9CLEtBQVQ7QUFDSCxHQTFCMkI7QUEyQjVCaVUsTUFBSSxFQUFFLGdCQUFZO0FBQ2Q3OEIsWUFBUSxDQUFDNjhCLElBQVQ7QUFDSCxHQTdCMkI7QUE4QjVCMmdCLE9BQUssRUFBRSxpQkFBWTtBQUNmeUgsWUFBUSxDQUFDTCxPQUFULEdBQW1CLElBQW5CO0FBQ0gsR0FoQzJCO0FBaUM1QlcsWUFBVSxFQUFFLG9CQUFVOTJDLFFBQVYsRUFBb0I7QUFDNUIsUUFBSSxDQUFDQSxRQUFELElBQWMsT0FBT0EsUUFBUCxLQUFvQixVQUFwQixLQUFtQyxpQkFBT0EsUUFBUCxNQUFvQixRQUFwQixJQUFnQyxDQUFDQSxRQUFRLENBQUNBLFFBQTdFLENBQWxCLEVBQTJHO0FBQ3ZHa1MsYUFBTyxDQUFDNVcsS0FBUixDQUFjLHFFQUFkO0FBQ0E7QUFDSDs7QUFDRHM2QyxVQUFNLENBQUNoUixTQUFQLENBQWlCLFVBQWpCLEVBQTZCNWtDLFFBQTdCO0FBQ0gsR0F2QzJCO0FBd0M1QisyQyxhQUFXLEVBQUUscUJBQVUvMkMsUUFBVixFQUFvQjtBQUM3QjQxQyxVQUFNLENBQUM1USxXQUFQLENBQW1CLFVBQW5CLEVBQStCaGxDLFFBQS9CO0FBQ0gsR0ExQzJCO0FBMkM1Qjh5QyxhQUFXLEVBQUUscUJBQVU5eUMsUUFBVixFQUFvQjtBQUM3QixRQUFJLENBQUNBLFFBQUQsSUFBYyxPQUFPQSxRQUFQLEtBQW9CLFVBQXBCLEtBQW1DLGlCQUFPQSxRQUFQLE1BQW9CLFFBQXBCLElBQWdDLENBQUNBLFFBQVEsQ0FBQ0EsUUFBN0UsQ0FBbEIsRUFBMkc7QUFDdkdrUyxhQUFPLENBQUM1VyxLQUFSLENBQWMsc0VBQWQ7QUFDQTtBQUNIOztBQUNEczZDLFVBQU0sQ0FBQ2hSLFNBQVAsQ0FBaUIsV0FBakIsRUFBOEI1a0MsUUFBOUI7QUFDSCxHQWpEMkI7QUFrRDVCZzNDLGNBQVksRUFBRSxzQkFBVWgzQyxRQUFWLEVBQW9CO0FBQzlCNDFDLFVBQU0sQ0FBQzVRLFdBQVAsQ0FBbUIsV0FBbkIsRUFBZ0NobEMsUUFBaEM7QUFDSCxHQXBEMkI7QUFxRDVCaWtDLFlBQVUsRUFBRSxvQkFBVXRDLE9BQVYsRUFBbUI7QUFDM0IsUUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDVnp2QixhQUFPLENBQUM1VyxLQUFSLENBQWMsK0RBQWQ7QUFDQTtBQUNIOztBQUNEL0osWUFBUSxDQUFDMHlDLFVBQVQsQ0FBb0J0QyxPQUFwQjtBQUNILEdBM0QyQjtBQTRENUJSLGdCQUFjLEVBQUUsd0JBQVV4cEIsSUFBVixFQUFnQnlwQixNQUFoQixFQUF3QjtBQUNwQyxRQUFJLENBQUN6cEIsSUFBTCxFQUFXO0FBQ1B6RixhQUFPLENBQUM1VyxLQUFSLENBQWMsZ0VBQWQ7QUFDQTtBQUNIOztBQUNELFFBQUksQ0FBQzhsQyxNQUFMLEVBQWE7QUFDVGx2QixhQUFPLENBQUM1VyxLQUFSLENBQWMsa0VBQWQ7QUFDQTtBQUNIOztBQUNEL0osWUFBUSxDQUFDNHZDLGNBQVQsQ0FBd0J4cEIsSUFBeEIsRUFBOEJ5cEIsTUFBOUI7QUFDSCxHQXRFMkI7QUF1RTVCNlYseUJBQXVCLEVBQUUsaUNBQVV2QixlQUFWLEVBQTJCO0FBQ2hELFFBQUlBLGVBQWUsSUFBSSxPQUFPQSxlQUFlLENBQUN4TixTQUF2QixLQUFxQyxVQUE1RCxFQUF3RTtBQUNwRXNPLGNBQVEsQ0FBQ2QsZUFBVCxHQUEyQkEsZUFBM0I7QUFDSDtBQUNKLEdBM0UyQjs7QUE0RTVCLE1BQUl6MUMsTUFBSixHQUFhO0FBQ1QsV0FBT3UyQyxRQUFRLENBQUMvQixlQUFoQjtBQUNILEdBOUUyQjs7QUErRTVCeUMsY0FBWSxFQUFFLHNCQUFVdjNDLE1BQVYsRUFBa0J3M0MsY0FBbEIsRUFBa0M7QUFBQTs7QUFDNUMsUUFBTVQsY0FBYyxHQUFHLElBQUk5RCxhQUFKLEVBQXZCO0FBQ0FqekMsVUFBTSxHQUFHNEosZUFBSyxDQUFDO0FBQ1hvSSxpQkFBVyxFQUFFO0FBQ1R6SSxZQUFJLEVBQUUsYUFERztBQUVUeS9CLGdCQUFRLEVBQUUsS0FGRDtBQUdUMXdDLFlBQUksRUFBRSxHQUhHO0FBSVQ4SCxXQUFHLEVBQUVKLE1BQU0sQ0FBQ0k7QUFKSCxPQURGO0FBT1h3b0Msa0JBQVksRUFBR2g3QixLQUFBLElBQW1CNU4sTUFBTSxDQUFDNk4sS0FBM0IsR0FBb0MsQ0FBcEMsR0FBd0MsQ0FQM0M7QUFRWGk3QixhQUFPLEVBQUU7QUFDTGhvQyxrQkFBVSxFQUFFO0FBRFA7QUFSRSxLQUFELEVBV1hkLE1BWFcsQ0FBZCxDQUY0QyxDQWM1QztBQUNBOztBQUNBLFFBQUlBLE1BQU0sQ0FBQzRvQyxZQUFQLEdBQXNCLENBQTFCLEVBQTZCO0FBQ3pCNW9DLFlBQU0sQ0FBQzRvQyxZQUFQLEdBQXNCLENBQXRCO0FBQ0gsS0FsQjJDLENBbUI1QztBQUNBOzs7QUFDQSxRQUFJNW9DLE1BQU0sQ0FBQzRvQyxZQUFQLEdBQXNCLENBQXRCLEtBQTRCLE9BQU82SyxJQUFQLEtBQWdCLFdBQWhCLElBQStCLE9BQU9NLE1BQVAsS0FBa0IsV0FBN0UsQ0FBSixFQUErRjtBQUMzRnhoQyxhQUFPLENBQUNrdEIsSUFBUixDQUFhLDZEQUFiO0FBQ0F6L0IsWUFBTSxDQUFDNG9DLFlBQVAsR0FBc0IsQ0FBdEI7QUFDSDs7QUFDRCxXQUFPLElBQUloekIsT0FBSixDQUFZLFVBQUNSLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUNwQyxVQUFJO0FBQ0EsYUFBSSxDQUFDeGUsSUFBTCxDQUFVbUosTUFBVixFQUFrQixZQUFNO0FBQ3BCaTJDLGdCQUFNLENBQUM3USxJQUFQLENBQVksV0FBWixFQUF5QixVQUFDcnBDLE1BQUQsRUFBWTtBQUNqQ2c3QywwQkFBYyxDQUFDdG9CLElBQWY7O0FBQ0EsZ0JBQUkrb0IsY0FBSixFQUFvQjtBQUNoQkEsNEJBQWMsQ0FBQzNrRCxJQUFmLENBQW9CLElBQXBCLEVBQTBCa0osTUFBMUI7QUFDSDs7QUFDRHFaLG1CQUFPLENBQUNyWixNQUFELENBQVA7QUFDSCxXQU5ELEVBTUcsSUFOSDtBQU9BZzdDLHdCQUFjLENBQUN2OEIsS0FBZjtBQUNILFNBVEQsRUFTRyxJQVRILEVBU1N1OEIsY0FUVDtBQVVILE9BWEQsQ0FXRSxPQUFPOWdDLEdBQVAsRUFBWTtBQUNWWixjQUFNLENBQUNZLEdBQUQsQ0FBTjtBQUNIO0FBQ0osS0FmTSxDQUFQO0FBZ0JILEdBeEgyQjs7QUF5SDVCO0FBQ0E7QUFDQSxNQUFJd2hDLE9BQUosR0FBYztBQUNWLFdBQU9YLHVCQUFQO0FBQ0gsR0E3SDJCOztBQThINUI5aUIsZUFBYSxFQUFiQSxjQTlINEI7QUErSDVCMGhCLGNBQVksRUFBWkEsYUEvSDRCO0FBZ0k1QjltQyxZQUFVLEVBQVZBLDhCQWhJNEI7QUFpSTVCaEksY0FBWSxFQUFaQSxnQ0FqSTRCO0FBa0k1Qjh3QyxpQkFBZSxFQUFmQSxnQkFBZUE7QUFsSWEsQ0FBaEM7QUFxSWVaLG1HQUFmLEUsQ0FDQSIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDg3KTtcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XG4gICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgaTsgbGV0XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZTogdjJjbG9uZSB9O1xuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XG4gICAgICAgIC8vIGFyci5maWxsKHZhbCk7XG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIC8vIFRPRE86IGNvZGVfMTI4IHN0YXJ0cyBmYWlsaW5nIG1pc2VyYWJseSB3aGVuIGkgb25seSBhbGxvdyBpbWdSZWYgdG8gY29udGFpbiBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueCk7XG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcbiAgICAvLyBlbmQgb2YgbmV3IGltYWdlV3JhcHBlciBzaXplLlxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgICAvLyB0b29cbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gICAgemVyb0JvcmRlcigpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xuICAgIC8vIGFsbCB0aGUgcmVzdCBvZiBpdCwgc28gdGhpcyBpcyBhIHZlcmJhdGltIGNvcHkgb2YgdGhlIGphdmFzY3JpcHQgc291cmNlLCB3aXRoIG9ubHkgdHdlYWtzXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgbGV0IHlzcTtcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IG11MTE7XG4gICAgICAgIGxldCBtdTAyO1xuICAgICAgICBsZXQgbXUyMDtcbiAgICAgICAgbGV0IHhfO1xuICAgICAgICBsZXQgeV87XG4gICAgICAgIGxldCB0bXA7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBQSV80ID0gUEkgLyA0O1xuXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcbiAgICAgICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXG4gICAgZ2V0QXNSR0JBKHNjYWxlID0gMS4wKTogVWludDhDbGFtcGVkQXJyYXkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2VcIik7XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwiLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFRyYWNlciA9IHtcbiAgICBzZWFyY2hEaXJlY3Rpb25zOiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dLFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHsgc2VhcmNoRGlyZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgICAgICBsZXQgcG9zO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgbGV0IHg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgICAgICAgICAgcG9zID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBDdjtcbiAgICAgICAgICAgIGxldCBQO1xuICAgICAgICAgICAgbGV0IGxkaXI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIGN4OiBzeCxcbiAgICAgICAgICAgICAgICBjeTogc3ksXG4gICAgICAgICAgICAgICAgZGlyOiAwLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSkge1xuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcbiAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnggPSBjdXJyZW50LmN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQuY3ggIT09IHN4IHx8IGN1cnJlbnQuY3kgIT09IHN5KTtcbiAgICAgICAgICAgICAgICBGdi5wcmV2ID0gQ3YucHJldjtcbiAgICAgICAgICAgICAgICBDdi5wcmV2Lm5leHQgPSBGdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gJ2dsLW1hdDInO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuXG5sZXQgX2NvbmZpZztcbmxldCBfY3VycmVudEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbEltYWdlV3JhcHBlcjtcbmxldCBfc3ViSW1hZ2VXcmFwcGVyO1xubGV0IF9sYWJlbEltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hHcmlkO1xubGV0IF9wYXRjaExhYmVsR3JpZDtcbmxldCBfaW1hZ2VUb1BhdGNoR3JpZDtcbmxldCBfYmluYXJ5SW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaFNpemU7XG5jb25zdCBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgIGN0eDoge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbiAgICBkb206IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG59O1xuY29uc3QgX251bVBhdGNoZXMgPSB7IHg6IDAsIHk6IDAgfTtcbmxldCBfaW5wdXRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy54ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3BhdGNoU2l6ZS54IHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xuXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XG5cbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuXG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiBnbG9iYWwsXG4gICAgICAgIHsgc2l6ZTogX3BhdGNoU2l6ZS54IH0sXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxuICAgICk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXG4gICAgfSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcnKS5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkpO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICBsZXQgb3ZlckF2ZztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IHRyYW5zTWF0O1xuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgYm94O1xuICAgIGxldCBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgIGlmIChvdmVyQXZnIDwgMCkge1xuICAgICAgICBvdmVyQXZnICs9IDE4MDtcbiAgICB9XG5cbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICAgICAgICAgIG1pbnggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xuICAgICAgICAgICAgICAgIG1heHggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xuICAgICAgICAgICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICAgICAgICAgIG1heHkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIoYm94W2pdLCBib3hbal0sIHRyYW5zTWF0KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd0JCKSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaW5hcnkgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcbiAgICBvdHN1VGhyZXNob2xkKF9jdXJyZW50SW1hZ2VXcmFwcGVyLCBfYmluYXJ5SW1hZ2VXcmFwcGVyKTtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xuICAgICAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNob3coX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAyNTUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxuICogZXh0cmFjdCBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBtb21lbnRzO1xuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBsZXQgcmFzdGVyaXplcjtcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xuICAgIGxldCBwYXRjaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX251bVBhdGNoZXMueDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XG4gICAgICAgICAgICB5ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgKiBqO1xuXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgc2tlbGV0b25pemUoeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcbiAgICAgICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgX2xhYmVsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCBNYXRoLmZsb29yKDM2MCAvIHJhc3RlclJlc3VsdC5jb3VudCksXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBzdW07XG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcCgodmFsLCBpZHgpID0+ICh7XG4gICAgICAgIHZhbCxcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXG4gICAgfSkpO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xuXG4gICAgLy8gZXh0cmFjdCB0b3AgYXJlYXMgd2l0aCBhdCBsZWFzdCA2IHBhdGNoZXMgcHJlc2VudFxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XG5cbiAgICByZXR1cm4gdG9wTGFiZWxzO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHN1bTtcbiAgICBjb25zdCBwYXRjaGVzID0gW107XG4gICAgbGV0IHBhdGNoO1xuICAgIGxldCBib3g7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcExhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA9PT0gdG9wTGFiZWxzW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib3ggPSBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXM7XG59XG5cbi8qKlxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcbiAqL1xuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICBjb25zdCB0b3BDbHVzdGVyID0gdG9wR2VuZXJpYyhjbHVzdGVycywgMSwgKGUpID0+IGUuZ2V0UG9pbnRzKCkubGVuZ3RoKTtcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGlmICh0b3BDbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNrZWxldG9uaXplKHgsIHkpIHtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcbiAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDM2MCwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge0FycmF5fSBtb21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUGF0Y2gobW9tZW50cywgcGF0Y2hQb3MsIHgsIHkpIHtcbiAgICBsZXQgaztcbiAgICBsZXQgYXZnO1xuICAgIGNvbnN0IGVsaWdpYmxlTW9tZW50cyA9IFtdO1xuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcblxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF2ZyArPSBtYXRjaGluZ01vbWVudHNba10ucmFkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBhdGNoIHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IChlbGlnaWJsZU1vbWVudHMubGVuZ3RoIC8gNCkgKiAzXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiBtb21lbnRzLmxlbmd0aCAvIDQpIHtcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhdGNoUG9zWzFdICogX251bVBhdGNoZXMueCArIHBhdGNoUG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhdGNoZXNGb3VuZC5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaGVzRm91bmRcbiAqL1xuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XG4gICAgbGV0IGxhYmVsID0gMDtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xuICAgIGxldCBjdXJySWR4ID0gMDtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBsZXQgZGlyO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwrKztcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZSgpIHtcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBwYXRjaFNpemU7XG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgICAgIGxldCBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgfTtcblxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXRjaC1TaXplOiAke0pTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpKTtcblxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoICgke1xuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcbiAgICB9LFxufTtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRldGVybWluYW50OiByZXF1aXJlKCcuL2RldGVybWluYW50JylcbiAgLCB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vdHJhbnNwb3NlJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgaWRlbnRpdHk6IHJlcXVpcmUoJy4vaWRlbnRpdHknKVxuICAsIGFkam9pbnQ6IHJlcXVpcmUoJy4vYWRqb2ludCcpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgaW52ZXJ0OiByZXF1aXJlKCcuL2ludmVydCcpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgZnJvYjogcmVxdWlyZSgnLi9mcm9iJylcbiAgLCBsZHU6IHJlcXVpcmUoJy4vbGR1Jylcbn1cbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZVxuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdXG4gICAgcmV0dXJuIHgqeCArIHkqeVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqelxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlblxuICAgIH1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwiaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5cbi8qKlxuICogaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vVGlwcy80MDcxNzIvQ29ubmVjdGVkLUNvbXBvbmVudC1MYWJlbGluZy1hbmQtVmVjdG9yaXphdGlvblxuICovXG5jb25zdCBSYXN0ZXJpemVyID0ge1xuICAgIGNyZWF0ZUNvbnRvdXIyRCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcjogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiBudWxsLFxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcbiAgICAgICAgICAgIG5leHRwZWVyOiBudWxsLFxuICAgICAgICAgICAgcHJldnBlZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBDT05UT1VSX0RJUjoge1xuICAgICAgICBDV19ESVI6IDAsXG4gICAgICAgIENDV19ESVI6IDEsXG4gICAgICAgIFVOS05PV05fRElSOiAyLFxuICAgIH0sXG4gICAgRElSOiB7XG4gICAgICAgIE9VVFNJREVfRURHRTogLTMyNzY3LFxuICAgICAgICBJTlNJREVfRURHRTogLTMyNzY2LFxuICAgIH0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgICAgICBjb25zdCB0cmFjZXIgPSBUcmFjZXIuY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFzdGVyaXplKGRlcHRobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sb3I7XG4gICAgICAgICAgICAgICAgbGV0IGJjO1xuICAgICAgICAgICAgICAgIGxldCBsYztcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgY3g7XG4gICAgICAgICAgICAgICAgbGV0IGN5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yTWFwID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHZlcnRleDtcbiAgICAgICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgICAgICBsZXQgY2M7XG4gICAgICAgICAgICAgICAgbGV0IHNjO1xuICAgICAgICAgICAgICAgIGxldCBwb3M7XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RlZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0MDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XG4gICAgICAgICAgICAgICAgY2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAoY3kgPSAxOyBjeSA8IGhlaWdodCAtIDE7IGN5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY3ggPSAxOyBjeCA8IHdpZHRoIC0gMTsgY3grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gY3kgKiB3aWR0aCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IgIT09IGJjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYyA9IGNvbm5lY3RlZENvdW50ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2xjXSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlci5jb250b3VyVHJhY2luZyhjeSwgY3gsIGxjLCBjb2xvciwgUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleCA9IHRyYWNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb250b3VyVHJhY2luZyhjeSwgY3gsIFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFLCBjb2xvciwgbGFiZWxpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGhsYWJlbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmRpciA9IFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoc2MgIT09IG51bGwpICYmIHNjLmluZGV4ICE9PSBsYWJlbGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gc2MuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYy5pbnNpZGVDb250b3VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuT1VUU0lERV9FREdFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBpbWFnZURhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxhYmVsRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbbGFiZWxpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2MuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgICAgICBkcmF3Q29udG91cihjYW52YXMsIGZpcnN0Q29udG91cikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBxID0gZmlyc3RDb250b3VyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcDtcblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBpcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IGlxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gcHE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHEgPSBwcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHEuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5VTktOT1dOX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBxLmZpcnN0VmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHAgIT09IHEuZmlyc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJhc3Rlcml6ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cbi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cbmZ1bmN0aW9uIFNrZWxldG9uaXplcihzdGRsaWIsIGZvcmVpZ24sIGJ1ZmZlcikge1xuICAgICd1c2UgYXNtJztcblxuICAgIGNvbnN0IGltYWdlcyA9IG5ldyBzdGRsaWIuVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHNpemUgPSBmb3JlaWduLnNpemUgfCAwO1xuICAgIGNvbnN0IHsgaW11bCB9ID0gc3RkbGliLk1hdGg7XG5cbiAgICBmdW5jdGlvbiBlcm9kZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHYgPSAwO1xuICAgICAgICBsZXQgdSA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA9PSAoNSB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgLSAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIHwgKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG4gICAgICAgIHZhbHVlIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPiAoMCB8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVtY3B5KHNyY0ltYWdlUHRyLCBkc3RJbWFnZVB0cikge1xuICAgICAgICBzcmNJbWFnZVB0ciB8PSAwO1xuICAgICAgICBkc3RJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICBsZXQgeSA9IDA7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHgpIHwgMF0gPSAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICgoeSArIHNpemUpIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xuICAgICAgICBjb25zdCBzdWJJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBlcm9kZWRJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCB0ZW1wSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgc2tlbEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gMDtcblxuICAgICAgICBlcm9kZWRJbWFnZVB0ciA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuICAgICAgICB0ZW1wSW1hZ2VQdHIgPSAoZXJvZGVkSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuICAgICAgICBza2VsSW1hZ2VQdHIgPSAodGVtcEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcblxuICAgICAgICAvLyBpbml0IHNrZWwtaW1hZ2VcbiAgICAgICAgaW5pdChza2VsSW1hZ2VQdHIsIDApO1xuICAgICAgICB6ZXJvQm9yZGVyKHN1YkltYWdlUHRyKTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlcm9kZShzdWJJbWFnZVB0ciwgZXJvZGVkSW1hZ2VQdHIpO1xuICAgICAgICAgICAgZGlsYXRlKGVyb2RlZEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VidHJhY3Qoc3ViSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIGJpdHdpc2VPcihza2VsSW1hZ2VQdHIsIHRlbXBJbWFnZVB0ciwgc2tlbEltYWdlUHRyKTtcbiAgICAgICAgICAgIG1lbWNweShlcm9kZWRJbWFnZVB0ciwgc3ViSW1hZ2VQdHIpO1xuICAgICAgICAgICAgc3VtID0gY291bnROb25aZXJvKHN1YkltYWdlUHRyKSB8IDA7XG4gICAgICAgICAgICBkb25lID0gKChzdW0gfCAwKSA9PSAwIHwgMCk7XG4gICAgICAgIH0gd2hpbGUgKCFkb25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2tlbGV0b25pemUsXG4gICAgfTtcbn1cbi8qIEBwcmVzZXJ2ZSBBU00gRU5EICovXG5leHBvcnQgZGVmYXVsdCBTa2VsZXRvbml6ZXI7XG4vKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuIiwiLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBNYXRoLmltdWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhbCA9IGEgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmwgPSBiICYgMHhmZmZmO1xuICAgICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxuICAgICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG5cbid1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfTtcbn1cbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXRcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWluXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heFxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgdmVjMiBieSBhbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGFuZ2xlKSB7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKVxuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXVxuXG4gIG91dFswXSA9IHggKiBjIC0geSAqIHNcbiAgb3V0WzFdID0geCAqIHMgKyB5ICogY1xuXG4gIHJldHVybiBvdXRcbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGRcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlXG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeVxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zc1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXG4gICAgb3V0WzBdID0gb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwXG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyZFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN11cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbFxuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgc3RyaWRlID0gMlxuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMFxuICAgIH1cbiAgICBcbiAgICBpZihjb3VudCkge1xuICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICB2ZWNbMF0gPSBhW2ldXG4gICAgICAgIHZlY1sxXSA9IGFbaSsxXVxuICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICBhW2ldID0gdmVjWzBdXG4gICAgICAgIGFbaSsxXSA9IHZlY1sxXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGltaXQ7XG5cbi8qKlxuICogTGltaXQgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZlY3RvciB0byB0aGUgdmFsdWUgdXNlZCBmb3IgdGhlIGBtYXhgXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtICB7dmVjMn0gdGhlIHZlY3RvciB0byBsaW1pdFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXggdGhlIG1heGltdW0gbWFnbml0dWRlIGZvciB0aGUgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxpbWl0KG91dCwgYSwgbWF4KSB7XG4gIHZhciBtU3EgPSBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuXG4gIGlmIChtU3EgPiBtYXggKiBtYXgpIHtcbiAgICB2YXIgbiA9IE1hdGguc3FydChtU3EpO1xuICAgIG91dFswXSA9IGFbMF0gLyBuICogbWF4O1xuICAgIG91dFsxXSA9IGFbMV0gLyBuICogbWF4O1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gYW5nbGVcblxudmFyIGZyb21WYWx1ZXMgPSByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbnZhciBkb3QgPSByZXF1aXJlKCcuL2RvdCcpXG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgdmFyIHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKVxuIFxuICAgIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpXG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQilcbiBcbiAgICB2YXIgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQilcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXG4gICAgfSAgICAgXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHZhciBiMiA9IGJbMl1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICBvdXRbMl0gPSBhWzJdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICBvdXRbMl0gPSAtYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIG91dFsyXSA9IDEuMCAvIGFbMl1cbiAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3M7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl1cblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYnpcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheilcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIHZhciB6ID0gKE1hdGgucmFuZG9tKCkgKiAyLjApIC0gMS4wXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlXG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdXG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdXG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddXG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUXVhdDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHpcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xelxuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ5ID0gYlsxXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIFRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG5cbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBieSArIHB5ICogY2MgLSBweiAqIHNjXG4gICAgb3V0WzJdID0gYnogKyBweSAqIHNjICsgcHogKiBjY1xuXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG4gICAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuICBcbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHogKiBzYyArIHB4ICogY2NcbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYnogKyBweiAqIGNjIC0gcHggKiBzY1xuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ5ID0gYlsxXVxuXG4gICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHggKiBjYyAtIHB5ICogc2NcbiAgICBvdXRbMV0gPSBieSArIHB4ICogc2MgKyBweSAqIGNjXG4gICAgb3V0WzJdID0gYVsyXVxuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbFxuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzXG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV0gXG4gICAgICAgICAgICB2ZWNbMV0gPSBhW2krMV0gXG4gICAgICAgICAgICB2ZWNbMl0gPSBhW2krMl1cbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdIFxuICAgICAgICAgICAgYVtpKzFdID0gdmVjWzFdIFxuICAgICAgICAgICAgYVtpKzJdID0gdmVjWzJdXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhXG59IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmFudFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmRldGVybWluYW50XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc3Bvc2VcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi50cmFuc3Bvc2VcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTEgPSBhWzFdXG4gICAgb3V0WzFdID0gYVsyXVxuICAgIG91dFsyXSA9IGExXG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhWzFdXG4gICAgb3V0WzNdID0gYVszXVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBhbGlhcyBtYXQyLm11bHRpcGx5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM11cbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjFcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjFcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjNcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eVxuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBhbGlhcyBtYXQyLmlkZW50aXR5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5hZGpvaW50XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gIGFbMF1cbiAgb3V0WzBdID0gIGFbM11cbiAgb3V0WzFdID0gLWFbMV1cbiAgb3V0WzJdID0gLWFbMl1cbiAgb3V0WzNdID0gIGEwXG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAYWxpYXMgbWF0Mi5yb3RhdGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKVxuICB2YXIgYyA9IE1hdGguY29zKHJhZClcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogc1xuICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzXG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGNcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogY1xuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydFxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuaW52ZXJ0XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGEzID0gYVszXVxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTFcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gIGEzICogZGV0XG4gIG91dFsxXSA9IC1hMSAqIGRldFxuICBvdXRbMl0gPSAtYTIgKiBkZXRcbiAgb3V0WzNdID0gIGEwICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5jcmVhdGVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNClcbiAgb3V0WzBdID0gMVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQGFsaWFzIG1hdDIuc2NhbGVcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgdjAgPSB2WzBdLCB2MSA9IHZbMV1cbiAgb3V0WzBdID0gYTAgKiB2MFxuICBvdXRbMV0gPSBhMSAqIHYwXG4gIG91dFsyXSA9IGEyICogdjFcbiAgb3V0WzNdID0gYTMgKiB2MVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQGFsaWFzIG1hdDIuY29weVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdXG4gIG91dFsxXSA9IGFbMV1cbiAgb3V0WzJdID0gYVsyXVxuICBvdXRbM10gPSBhWzNdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvYlxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuZnJvYlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5mdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyhhWzBdLCAyKSArXG4gICAgTWF0aC5wb3coYVsxXSwgMikgK1xuICAgIE1hdGgucG93KGFbMl0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzNdLCAyKVxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGxkdVxuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5sZHVcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuZnVuY3Rpb24gbGR1KEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0vYVswXVxuICBVWzBdID0gYVswXVxuICBVWzFdID0gYVsxXVxuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdXG4gIHJldHVybiBbTCwgRCwgVV1cbn1cbiIsImNvbnN0IEJyZXNlbmhhbSA9IHt9O1xuXG5jb25zdCBTbG9wZSA9IHtcbiAgICBESVI6IHtcbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IC0xLFxuICAgIH0sXG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24gKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGxldCB4MCA9IHAxLnggfCAwO1xuICAgIGxldCB5MCA9IHAxLnkgfCAwO1xuICAgIGxldCB4MSA9IHAyLnggfCAwO1xuICAgIGxldCB5MSA9IHAyLnkgfCAwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCB5O1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHg7XG4gICAgY29uc3QgbGluZSA9IFtdO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgdmFsO1xuICAgIGxldCBtaW4gPSAyNTU7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHgxIC0geDA7XG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGFYIC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICBjb25zdCB5U3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgLT0gZGVsdGFZO1xuICAgICAgICBpZiAoZXJyb3IgPCAwKSB7XG4gICAgICAgICAgICB5ICs9IHlTdGVwO1xuICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFYO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgY29uc3QgeyBtaW4gfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IG1heCB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbGluZSB9ID0gcmVzdWx0O1xuICAgIGxldCBzbG9wZTtcbiAgICBsZXQgc2xvcGUyO1xuICAgIGNvbnN0IGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMjtcbiAgICBjb25zdCBleHRyZW1hID0gW107XG4gICAgbGV0IGN1cnJlbnREaXI7XG4gICAgbGV0IGRpcjtcbiAgICBsZXQgdGhyZXNob2xkID0gKG1heCAtIG1pbikgLyAxMjtcbiAgICBjb25zdCByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICB2YWw6IGxpbmVbMF0sXG4gICAgfSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudERpciA9IGRpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IGxpbmUubGVuZ3RoLFxuICAgICAgICB2YWw6IGxpbmVbbGluZS5sZW5ndGggLSAxXSxcbiAgICB9KTtcblxuICAgIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xuICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IGNlbnRlciA/IDAgOiAxO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBleHRyZW1hIGFuZCBjb252ZXJ0IHRvIGJpbmFyeSBiYXNlZCBvbiBhdmcgYmV0d2VlbiBtaW5tYXhcbiAgICBmb3IgKGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXNlZCBmb3IgZGV2ZWxvcG1lbnQgb25seVxuICovXG5CcmVzZW5oYW0uZGVidWcgPSB7XG4gICAgcHJpbnRGcmVxdWVuY3kobGluZSwgY2FudmFzKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IGxldFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG4iLCJpbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmV4cG9ydCBlbnVtIEJhcmNvZGVEaXJlY3Rpb24ge1xuICAgIEZvcndhcmQgPSAxLFxuICAgIFJldmVyc2UgPSAtMSxcbn07XG5cbmV4cG9ydCB0eXBlIEJhcmNvZGVSZWFkZXJUeXBlID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgQmFyY29kZUZvcm1hdCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUmVhZGVyQ29uZmlnIHtcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoPzogYm9vbGVhbixcbiAgICBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXJUeXBlPixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUNvcnJlY3Rpb24ge1xuICAgIGJhcjogbnVtYmVyLFxuICAgIHNwYWNlOiBudW1iZXIsXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydENvdW50ZXI/OiBudW1iZXIsXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kQ291bnRlcj86IG51bWJlcixcbiAgICBlcnJvcj86IG51bWJlcixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUluZm8gZXh0ZW5kcyBCYXJjb2RlUG9zaXRpb24ge1xuICAgIGNvZGU6IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGUge1xuICAgIGNvZGU6IHN0cmluZyxcbiAgICBjb2Rlc2V0PzogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXG4gICAgZGlyZWN0aW9uPzogQmFyY29kZURpcmVjdGlvbixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxuICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxufTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9yb3c6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICBjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDA7XG4gICAgRk9STUFUOiBCYXJjb2RlRm9ybWF0ID0gJ3Vua25vd24nO1xuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgLy8gVE9ETzogc2hvdWxkIGFkZCBBTFBIQUJFVEhfU1RSSU5HLCBBTFBIQUJFVCwgQ0hBUkFDVEVSX0VOQ09ESU5HUyB0byBiYXNlIGNsYXNzLCBpZiB0aGV5XG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXG5cbiAgICBhYnN0cmFjdCBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG5cbiAgICAgICAgdGhpcy5fcm93ID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfbmV4dFVuc2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgc3RhcnQ6IG51bWJlciA9IDApOiBudW1iZXIge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBtYXhTaW5nbGVFcnJvcj86IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGxldCBzaW5nbGVFcnJvciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbW9kdWxvID0gMDtcbiAgICAgICAgbGV0IGJhcldpZHRoID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHNjYWxlZCA9IDA7XG5cbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgPSBtYXhTaW5nbGVFcnJvciB8fCB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SIHx8IDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdW0gPCBtb2R1bG8pIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XG4gICAgICAgIG1heFNpbmdsZUVycm9yICo9IGJhcldpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcbiAgICAgICAgICAgIHNjYWxlZCA9IGNvZGVbaV0gKiBiYXJXaWR0aDtcbiAgICAgICAgICAgIHNpbmdsZUVycm9yID0gTWF0aC5hYnMoY291bnQgLSBzY2FsZWQpIC8gc2NhbGVkO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbiAgICB9XG5cbiAgICBfbmV4dFNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdG1wID0gY291bnRlcltpbmRpY2VzW2xlbmd0aF1dICogKDEgLSAoKDEgLSBjb3JyZWN0aW9uKSAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0bXAgPiAxKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjb2RlUGF0dGVybihwYXR0ZXJuOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XG4gICAgICAgIHRoaXMuX3JvdyA9IHBhdHRlcm47XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuIGNhbGxpbmcgZGVjb2RlJywgdHlwZW9mIHRoaXMsIHRoaXMuY29uc3RydWN0b3IsIHRoaXMuRk9STUFULCBKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0IHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV2ZXJzZWQgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uUmV2ZXJzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmZvcm1hdCA9IHRoaXMuRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9tYXRjaFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2ZpbGxDb3VudGVycyhvZmZzZXQ6IG51bWJlciA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpLCBlbmQ6IG51bWJlciA9IHRoaXMuX3Jvdy5sZW5ndGgsIGlzV2hpdGU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgQ29kZTEyOFJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIENPREVfU0hJRlQgPSA5ODtcbiAgICBDT0RFX0MgPSA5OTtcbiAgICBDT0RFX0IgPSAxMDA7XG4gICAgQ09ERV9BID0gMTAxO1xuICAgIFNUQVJUX0NPREVfQSA9IDEwMztcbiAgICBTVEFSVF9DT0RFX0IgPSAxMDQ7XG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xuICAgIFNUT1BfQ09ERSA9IDEwNjtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMywgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMywgMywgMSwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMywgMywgMiwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMywgMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbNCwgMSwgMywgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMSwgNCwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl0sXG4gICAgICAgIF07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcbiAgICBGT1JNQVQgPSAnY29kZV8xMjgnO1xuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xuXG4gICAgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9jb3JyZWN0KGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IEJhcmNvZGVDb3JyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uYmFyLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xuICAgIF9maW5kU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IHRoaXMuU1RBUlRfQ09ERV9BOyBjb2RlIDw9IHRoaXMuU1RBUlRfQ09ERV9DOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgLy8gICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgbXVsdGlwbGllciA9IDAsXG4gICAgICAgIC8vICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAgIC8vICAgICBjb2Rlc2V0LFxuICAgICAgICAvLyAgICAgcmF3UmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgLy8gICAgIHNoaWZ0TmV4dCA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgdW5zaGlmdCxcbiAgICAgICAgLy8gICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBjb2RlOiBzdGFydEluZm8uY29kZSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiBzdGFydEluZm8uY29ycmVjdGlvbi5iYXIsXG4gICAgICAgICAgICAgICAgc3BhY2U6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLnNwYWNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICAgIGxldCBjb2Rlc2V0ID0gKChjOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShjb2RlLmNvZGUpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICBsZXQgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW107IC8vIFRPRE86IGkgdGhpbmsgdGhpcyBzaG91bGQgYmUgc3RyaW5nIG9ubHksIGJ1dCBpdCBjcmVhdGVzIHByb2JsZW1zIGlmIGl0IGlzXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gY29kZXNldCA9PT0gdGhpcy5DT0RFX0EgPyB0aGlzLkNPREVfQiA6IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgY29kZXNldDogY29kZXNldCBhcyBudW1iZXIsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kSW5mbzogY29kZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcblxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBjYWxjdWxhdGVDb3JyZWN0aW9uKGV4cGVjdGVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG5vcm1hbGl6ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogbnVtYmVyIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXG4gICAgICAgICAgICBzdW1FeHBlY3RlZCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW1FeHBlY3RlZCArPSBleHBlY3RlZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCArPSBub3JtYWxpemVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bUV4cGVjdGVkIC8gc3VtTm9ybWFsaXplZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUxMjhSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb2RlcmFuZ2U/OiBudW1iZXIpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZScsIHN0YXJ0LCBjb2RlcmFuZ2UpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYmVmb3JlIGxlbmd0aCcpO1xuICAgICAgICAgICAgY29kZXJhbmdlID0gQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGFmdGVyIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHN0YXJ0SW5mbz0nLCBKU09OLnN0cmluZ2lmeShzdGFydEluZm8pKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgc3RhcnRJbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGNhbGN1bGF0ZUZpcnN0RGlnaXQnLCBjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENPREVfRlJFUVVFTkNZW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC09IENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSB0aGlzLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcblxuICAgICAgICBsZXQgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBvdXRDb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm49JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZGVjb2RlQ29kZShtaWRkbGVQYXR0ZXJuIS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgICAgIGlmICghbWlkZGxlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgcmVzdWx0PScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZWRDb2Rlcz0nLCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICByZXR1cm4gbWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZScsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcblxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRFbmQnLCBvZmZzZXQsIGlzV2hpdGUpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogX2NoZWNrc3VtJywgcmVzdWx0KTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSAqPSAzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xuICAgICAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQ6IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMnLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoZXJlIGFyZSAnLCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCwgJyBzdXBwbGVtZW50cycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBleHRlbnNpb25zIGxvb3AnLCBpLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyUnO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgwMzQsIDB4MTIxLCAweDA2MSwgMHgxNjAsIDB4MDMxLCAweDEzMCwgMHgwNzAsIDB4MDI1LCAweDEyNCwgMHgwNjQsIDB4MTA5LCAweDA0OSxcbiAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDA5NDtcblxuY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzknO1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhOYXJyb3dXaWR0aCA9IDA7XG4gICAgICAgIGxldCBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzO1xuICAgICAgICBsZXQgd2lkZUJhcldpZHRoID0gMDtcblxuICAgICAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XG4gICAgICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgICAgIG51bVdpZGVCYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1XaWRlQmFycyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgX2ZpbmROZXh0V2lkdGgoY291bnRlcnM6IFVpbnQxNkFycmF5LCBjdXJyZW50OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbldpZHRoO1xuICAgIH07XG5cbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG5cbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gcGF0dGVyblNpemU7XG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5UmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vLFxufTtcblxuY2xhc3MgQ29kZTM5VklOUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOV92aW4nO1xuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuSU9RLCAnJyk7XG5cbiAgICAgICAgaWYgKCFjb2RlLm1hdGNoKHBhdHRlcm5zLkFaMDkpKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9XG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBTVEFSVF9FTkQgPSBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XG5jb25zdCBQQURESU5HID0gMS41O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGNvdW50czogbnVtYmVyLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZCB7XG4gICAgc3BhY2U6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxufTtcblxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9jb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcblxuICAgIF9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgobWluICsgbWF4KSAvIDIuMCkgfCAwO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XG5cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcblxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDB4MDtcbiAgICB9O1xuXG4gICAgX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XG4gICAgICAgICAgICAgICAgc3BhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgKFsnc3BhY2UnLCAnYmFyJ10gYXMgY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgbmV3a2luZCA9IGNhdGVnb3JpemF0aW9uW2tleV07XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICAgICAgbmV3a2luZC5uYXJyb3cubWF4ID0gTWF0aC5jZWlsKG5ld2tpbmQud2lkZS5taW4pO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgICB9O1xuXG4gICAgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICd1cGNfYSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuXG5jbGFzcyBFQU4yUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzInO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoMSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQpICE9PSBjb2RlRnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU4yUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBDSEVDS19ESUdJVF9FTkNPRElOR1MgPSBbMjQsIDIwLCAxOCwgMTcsIDEyLCA2LCAzLCAxMCwgOSwgNV07XG5cbmZ1bmN0aW9uIGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDSEVDS19ESUdJVF9FTkNPRElOR1NbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICBjb25zdCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICByZXR1cm4gc3VtICUgMTA7XG59XG5cbmNsYXNzIEVBTjVSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fNSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg0IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb25DaGVja3N1bShyZXN1bHQpICE9PSBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU41UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG5cbiAgICBfZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3k6IG51bWJlciwgcmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGZvciAobGV0IG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKyl7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG5yU3lzdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jb252ZXJ0VG9VUENBKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiB1cGNhO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuIiwiLy8gVE9ETzogaTJvZjVfcmVhZGVyIGFuZCAyb2Y1X3JlYWRlciBzaGFyZSB2ZXJ5IHNpbWlsYXIgY29kZSwgbWFrZSB1c2Ugb2YgdGhhdFxuXG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcblxuY2xhc3MgSTJvZjVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XG5cbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcbiAgICBdO1xuICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiA9IDU7XG4gICAgRk9STUFUID0gJ2kyb2Y1JztcblxuICAgIGNvbnN0cnVjdG9yKG9wdHM6IEJhcmNvZGVSZWFkZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlclN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvID0gdGhpcy5NQVhfQ09SUkVDVElPTl9GQUNUT1I7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hQYXR0ZXJuLmNhbGwodGhpcywgY291bnRlciwgY29kZSk7XG4gICAgfTtcblxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldD86IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiA9IGZhbHNlLCB0cnlIYXJkZXI6IGJvb2xlYW4gPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gNCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiAxMDtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZmluZEVuZCgpIHtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZVBhaXIoY291bnRlclBhaXI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IGNvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQYWlyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyUGFpcltpXSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZVBvc2l0aW9uPigpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMiAhPT0gMCB8fFxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBJMm9mNVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbVywgTiwgVywgTiwgTiwgTl07XG5jb25zdCBTVE9QX1BBVFRFUk4gPSBbVywgTiwgTiwgTiwgV107XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgW04sIE4sIFcsIFcsIE5dLFxuICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgW1csIFcsIE4sIE4sIE5dLFxuICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgW04sIFcsIFcsIE4sIE5dLFxuICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgW04sIFcsIE4sIFcsIE5dLFxuXTtcbmNvbnN0IFNUQVJUX1BBVFRFUk5fTEVOR1RIID0gU1RBUlRfUEFUVEVSTi5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuXG5jbGFzcyBUd29PZkZpdmVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuXG4gICAgRk9STUFUID0gJzJvZjUnO1xuXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuXG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGUgPSBmYWxzZSwgdHJ5SGFyZGVyID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgfVxuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbykge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZmluZEVuZCgpIHtcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgX2RlY29kZUNvZGUoY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBDT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7Y29kZS5jb2RlfWApO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gJC8rJWFiY2QqJztcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLFxuICAgIDB4MUE4LCAweDFBNCwgMHgxQTIsIDB4MTk0LCAweDE5MiwgMHgxOEEsIDB4MTY4LCAweDE2NCwgMHgxNjIsIDB4MTM0LFxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxuICAgIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLFxuICAgIDB4MTZFLCAweDE3NiwgMHgxQUUsIDB4MTI2LCAweDFEQSwgMHgxRDYsIDB4MTMyLCAweDE1RSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDE1RTtcblxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfOTMnO1xuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gTWF0aC5yb3VuZChjb3VudGVyc1tpXSAqIDkgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA8PD0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGxhc3RTdGFydCA9PT0gbmV4dFN0YXJ0IHx8ICF0aGlzLl9yb3dbbmV4dFN0YXJ0XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoYXJBcnJheS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAobGVuZ3RoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhckFycmF5WysraV07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gbmV4dENoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDM4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdLJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnUCcgJiYgbmV4dENoYXIgPD0gJ1MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBjb2RlXzkzX3JlYWRlciBfZGVjb2RlRXh0ZW5kZWQgaGl0IGRlZmF1bHQgY2FzZSwgdGhpcyBtYXkgYmUgYW4gZXJyb3InLCBkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBhcnJheVRvQ2hlY2sgPSBjaGFyQXJyYXkuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9ICgoKGkgKiAtMSkgKyAobGVuZ3RoIC0gMSkpICUgbWF4V2VpZ2h0KSArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5Q2hlY2tzdW1zKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXG4gICAgICAgICAgICAmJiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAxLCAxNSk7XG4gICAgfTtcblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmc+IHwgbnVsbCA9IFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ7XG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tzdW1zKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcbiAgICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXG4gICAgICAgIGlmICgocmVzdWx0ID0gdGhpcy5fZGVjb2RlRXh0ZW5kZWQocmVzdWx0KSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBBRUlPOiAvW0FFSU9dL2csXG4gICAgQVowOTogL1tBLVowLTldLyxcbn07XG5cbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XG5cbmNsYXNzIENvZGUzMlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcblxuICAgIF9kZWNvZGVDb2RlMzIoY29kZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICgvW14wLTlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaXS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gcmVzICogMzIgKyBjb2RlMzJzZXQuaW5kZXhPZihjb2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZTMyID0gJycgKyByZXM7XG4gICAgICAgIGlmIChjb2RlMzIubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgY29kZTMyID0gKCcwMDAwMDAwMDAnICsgY29kZTMyKS5zbGljZSgtOSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdBJyArIGNvZGUzMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuX2RlY29kZShyb3csIHN0YXJ0KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlMzIgPSB0aGlzLl9kZWNvZGVDb2RlMzIoY29kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNvZGUzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTMyUmVhZGVyO1xuIiwiaW1wb3J0IEJyZXNlbmhhbSBmcm9tICcuL2JyZXNlbmhhbSc7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlcic7XG5pbXBvcnQgQ29kYWJhclJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kYWJhcl9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX3JlYWRlcic7XG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl81X3JlYWRlcic7XG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX2VfcmVhZGVyJztcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuLi9yZWFkZXIvaTJvZjVfcmVhZGVyJztcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyLzJvZjVfcmVhZGVyJztcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzJfcmVhZGVyJztcblxuY29uc3QgUkVBREVSUyA9IHtcbiAgICBjb2RlXzEyOF9yZWFkZXI6IENvZGUxMjhSZWFkZXIsXG4gICAgZWFuX3JlYWRlcjogRUFOUmVhZGVyLFxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcbiAgICBlYW5fMl9yZWFkZXI6IEVBTjJSZWFkZXIsXG4gICAgZWFuXzhfcmVhZGVyOiBFQU44UmVhZGVyLFxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXG4gICAgY29kZV8zOV92aW5fcmVhZGVyOiBDb2RlMzlWSU5SZWFkZXIsXG4gICAgY29kYWJhcl9yZWFkZXI6IENvZGFiYXJSZWFkZXIsXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxuICAgIHVwY19lX3JlYWRlcjogVVBDRVJlYWRlcixcbiAgICBpMm9mNV9yZWFkZXI6IEkyb2Y1UmVhZGVyLFxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcbiAgICBjb2RlXzkzX3JlYWRlcjogQ29kZTkzUmVhZGVyLFxuICAgIGNvZGVfMzJfcmVhZGVyOiBDb2RlMzJSZWFkZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcbiAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICB9LFxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IF9jYW52YXMgPSB7XG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYmFyY29kZVJlYWRlcnMgPSBbXTtcblxuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgIGluaXRDb25maWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5mcmVxdWVuY3knKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5LmNsYXNzTmFtZSA9ICdmcmVxdWVuY3knO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMucGF0dGVybkJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gJ3BhdHRlcm5CdWZmZXInO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgucGF0dGVybiA9IF9jYW52YXMuZG9tLnBhdHRlcm4uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FudmFzLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFJlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25maWcucmVhZGVycy5mb3JFYWNoKChyZWFkZXJDb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xuICAgICAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZm9yZSByZWdpc3RlcmluZyByZWFkZXI6ICcsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMucHVzaChyZWFkZXJPYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlZ2lzdGVyZWQgUmVhZGVyczogJHtfYmFyY29kZVJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzW2ldLnByb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGFtb3VudCAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgICAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgICAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSlcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGV4dCAtPSBNYXRoLmNlaWwoZXh0IC8gMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZShib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzFdWzFdIC0gYm94WzBdWzFdKSAvIDIgKyBib3hbMF1bMV0sXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogKGJveFszXVswXSAtIGJveFsyXVswXSkgLyAyICsgYm94WzJdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbM11bMV0gLSBib3hbMl1bMV0pIC8gMiArIGJveFsyXVsxXSxcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRGcmVxdWVuY3koYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQnJlc2VuaGFtLnRvQmluYXJ5TGluZShiYXJjb2RlTGluZSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50UGF0dGVybihiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlUGF0dGVybihiYXJjb2RlTGluZS5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzbGljZXMgdGhlIGdpdmVuIGFyZWEgYXBhcnQgYW5kIHRyaWVzIHRvIGRldGVjdCBhIGJhcmNvZGUtcGF0dGVyblxuICAgICAgICAgKiBmb3IgZWFjaCBzbGljZS4gSXQgcmV0dXJucyB0aGUgZGVjb2RlZCBiYXJjb2RlLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGJveFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lQW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSk7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlcyA9IDE2O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGlyO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHhkaXIgPSBNYXRoLnNpbihsaW5lQW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgeWRpciA9IE1hdGguY29zKGxpbmVBbmdsZSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBkaXIgKiB4ZGlyLFxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVMZW5ndGgobGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnkgLSBsaW5lWzBdLnkpLCAyKVxuICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS54IC0gbGluZVswXS54KSwgMiksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UgPyBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Zy5kcmF3Qm91bmRpbmdCb3ggJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgY3R4LCB7IGNvbG9yOiAnYmx1ZScsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gZ2V0TGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgcmVzdWx0ICYmIGNvbmZpZy5kZWJ1Zy5kcmF3U2NhbmxpbmUgJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7IGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG11bHRpcGxlIH0gPSBjb25maWc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlRnJvbUltYWdlKGlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChSRUFERVJTW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcbiAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsInR5cGUgRXZlbnROYW1lID0gc3RyaW5nO1xuXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcbiAgICBhc3luYz86IGJvb2xlYW47XG4gICAgY2FsbGJhY2s6IEZ1bmN0aW9uO1xuICAgIG9uY2U/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcbiAgICBzdWJzY3JpYmVyczogQXJyYXk8U3Vic2NyaXB0aW9uPjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50cyB7XG4gICAgW2tleTogc3RyaW5nXTogRXZlbnREYXRhO1xufVxuXG5pbnRlcmZhY2UgRXZlbnRJbnRlcmZhY2Uge1xuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZDtcbiAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xuICAgIGxldCBldmVudHM6IEV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xuICAgICAgICBpZiAoIWV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiwgZGF0YTogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHdhcyBub3Qgc3BlY2lmaWVkIG9uIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgICAgICByZXR1cm4gX3N1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSBldmVudDtcblxuICAgICAgICAgICAgLy8gUHVibGlzaCBvbmUtdGltZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICEhc3Vic2NyaWJlci5vbmNlKS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gIXN1YnNjcmliZXIub25jZSk7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYyA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn0oKSk7XG4iLCJjb25zdCBFUlJPUl9ERVNDID0gJ1RoaXMgbWF5IG1lYW4gdGhhdCB0aGUgdXNlciBoYXMgZGVjbGluZWQgY2FtZXJhIGFjY2Vzcywgb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtZWRpYSBBUElzLiBJZiB5b3UgYXJlIHJ1bm5pbmcgaW4gaU9TLCB5b3UgbXVzdCB1c2UgU2FmYXJpLic7XG5cbmludGVyZmFjZSBFcnJvciB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBzdGFjaz86IHN0cmluZztcbiAgICBjb2RlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFcnJvcihgZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWApO1xuICAgICAgICBlcnJvci5jb2RlID0gLTE7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFcnJvcihgZ2V0VXNlck1lZGlhIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAtMTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XG5pbXBvcnQgeyBnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXMgfSBmcm9tICcuLi9jb21tb24vbWVkaWFEZXZpY2VzJztcbmltcG9ydCB7IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCogZGV2OiBjaGVja1ZpZGVvIGZvdW5kICR7dmlkZW8udmlkZW9XaWR0aH1weCB4ICR7dmlkZW8udmlkZW9IZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpOyAvLyBub3QgbGlzdGVkIG9uIE1ETi4uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBNZWRpYVRyYWNrQ29uc3RyYWludHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuXG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IGVudW1lcmF0ZURldmljZXMoKTtcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGRldmljZTogTWVkaWFEZXZpY2VJbmZvKSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xuICAgIGlmICghc3RyZWFtUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICByZXR1cm4gdHJhY2tzICYmIHRyYWNrcz8ubGVuZ3RoID8gdHJhY2tzWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxuICovXG5jb25zdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcyA9IHtcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCB2aWRlb0NvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIGluaXRDYW1lcmEodmlkZW8sIG5ld0NvbnN0cmFpbnRzKTtcbiAgICB9LFxuICAgIHJlbGVhc2UoKTogdm9pZCB7XG4gICAgICAgIC8vIFRPRE86IGkgd29uZGVyIGlmIHRlbGxpbmcgdGhlIFZpZGVvIGVsZW1lbnQgdG8gcGF1c2UoKSBiZWZvcmUgY2FsbGluZyBNZWRpYVN0cmVhbVRyYWNrLnN0b3AoKSB3b3VsZCBhbGxldmlhdGUgc29tZSBvZiB0aGUgaXNzdWVzIHdpdGggdGhlIGNhbWVyYSBhcHBlYXJpbmcgdG8gc3RheSBvcGVuIG9uIEFuZHJvaWQgZXZlbiBhZnRlciBzdG9wcGluZy5cbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRyYWNrc1swXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtUmVmID0gbnVsbDtcbiAgICB9LFxuICAgIGVudW1lcmF0ZVZpZGVvRGV2aWNlcyxcbiAgICBnZXRBY3RpdmVTdHJlYW1MYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFjayxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xuIiwiaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCB7XG4gICAgUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yLFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24sXG4gICAgWFlTaXplLFxuICAgIFF1YWdnYUltYWdlRGF0YSxcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCwgbGlzdDogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBsaXN0ICYmIGxpc3Quc29tZSgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSkgYXMgQXJyYXk8a2V5b2YgUXVhZ2dhSlNDb2RlUmVzdWx0PjtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGtleSkgPT4gaXRlbVtrZXldID09PSBjb2RlUmVzdWx0W2tleV0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXNzZXNGaWx0ZXIoXG4gICAgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIGZpbHRlcjogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbiB8IHVuZGVmaW5lZCxcbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyKGNvZGVSZXN1bHQpIDogdHJ1ZTtcbn1cblxuaW50ZXJmYWNlIFJlc3VsdENvbGxlY3RvciB7XG4gICAgYWRkUmVzdWx0OiAoZGF0YTogUXVhZ2dhSW1hZ2VEYXRhLCBpbWFnZVNpemU6IFhZU2l6ZSwgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KSA9PiB2b2lkO1xuICAgIGdldFJlc3VsdHM6ICgpID0+IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUoY29uZmlnOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3Rvcik6IFJlc3VsdENvbGxlY3RvciB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcbiAgICAgICAgbGV0IGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5ID8/IDIwO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gY29uZmlnLmNhcHR1cmUgPT09IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgcmV0dXJuICEhY2FwYWNpdHlcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QgYXMgQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PilcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0geyB9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3SW1hZ2UoZGF0YSwgaW1hZ2VTaXplLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bHRzKCk6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IERldkNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGcmVxdWVuY3k6IGZhbHNlLFxuICAgICAgICAgICAgZHJhd1NjYW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dDYW52YXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93U2tlbGV0b246IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZXZDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBOb2RlQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgUHJvZENvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogNCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9kQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBEZXZDb25maWcgZnJvbSAnLi9jb25maWcuZGV2JztcbmltcG9ydCBOb2RlQ29uZmlnIGZyb20gJy4vY29uZmlnLm5vZGUnO1xuaW1wb3J0IFByb2RDb25maWcgZnJvbSAnLi9jb25maWcucHJvZCc7XG5cbi8vIEB0cy1pZ25vcmUgLy8gVE9ETzogdGhpcyBwcm9kdWNlcyBhIGJpemFycmUgdHlwZXNjcmlwdCBlcnJvclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG5jb25zdCBRdWFnZ2FDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0gRU5WLmRldmVsb3BtZW50XG4gICAgPyBEZXZDb25maWdcbiAgICA6IEVOVi5ub2RlXG4gICAgICAgID8gTm9kZUNvbmZpZ1xuICAgICAgICA6IFByb2RDb25maWc7XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gXCJjb21tb24vaW1hZ2Vfd3JhcHBlclwiO1xuXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XG4gICAgcHVibGljIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XG5cbiAgICBwdWJsaWMgZnJhbWVncmFiYmVyOiBhbnk7XG5cbiAgICBwdWJsaWMgaW5wdXRJbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXI7XG5cbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHVibGljIGJveFNpemU6IGFueTtcblxuICAgIHB1YmxpYyByZXN1bHRDb2xsZWN0b3I6IGFueTtcblxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XG5cbiAgICBwdWJsaWMgd29ya2VyUG9vbDogYW55W10gPSBbXTtcblxuICAgIHB1YmxpYyBvblVJVGhyZWFkID0gdHJ1ZTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcbiAgICBpbWFnZTogYW55O1xuICAgIG92ZXJsYXk6IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRhaW5lciB7XG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9tOiBDYW52YXNJbmZvO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICAgICAgdGhpcy5kb20gPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+Pjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbmNvbnN0IEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGAke2RpcmVjdG9yeX1pbWFnZS0keyhgMDAke251bX1gKS5zbGljZSgtMyl9LmpwZ2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBodG1sSW1hZ2VzU3JjQXJyYXlbeV0uc3Vic3RyKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGxvYWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJy4uL2ltYWdlX2xvYWRlcic7XG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnksIElucHV0U3RyZWFtLCBFdmVudEhhbmRsZXJMaXN0IH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0uZCc7XG5cbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCk6IGZhbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8vIE5PVEUgRk9SIEFOWU9ORSBJTiBIRVJFIElOIFRIRSBGVVRVUkU6XG4vLyB3ZWJwYWNrLmNvbmZpZy5qcyByZXBsYWNlcyB0aGUgZnJhbWVfZ3JhYmJlciBtb2R1bGUgd2l0aCBUSElTIG1vZHVsZSB3aGVuIGl0IGlzIGJ1aWxkaW5nIGZvciBhIEJyb3dzZXIgZW52aXJvbm1lbnQuXG5cbmltcG9ydCB7XG4gICAgaW1hZ2VSZWYsXG4gICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSxcbiAgICBjb21wdXRlR3JheSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcblxuY29uc3QgVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIGFkanVzdENhbnZhc1NpemUoY2FudmFzLCB0YXJnZXRTaXplKSB7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gdGFyZ2V0U2l6ZS54KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRhcmdldFNpemUueDtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5oZWlnaHQgIT09IHRhcmdldFNpemUueSkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0U2l6ZS55O1xuICAgIH1cbn1cblxuY29uc3QgRnJhbWVHcmFiYmVyID0ge307XG5cbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0sIGNhbnZhcykge1xuICAgIGNvbnN0IF90aGF0ID0ge307XG4gICAgY29uc3QgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpO1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcbiAgICBjb25zdCBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgY29uc3QgX3N4ID0gdG9wUmlnaHQueDtcbiAgICBjb25zdCBfc3kgPSB0b3BSaWdodC55O1xuICAgIGxldCBfY2FudmFzO1xuICAgIGxldCBfY3R4ID0gbnVsbDtcbiAgICBsZXQgX2RhdGEgPSBudWxsO1xuXG4gICAgX2NhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBfY2FudmFzLndpZHRoID0gX2NhbnZhc1NpemUueDtcbiAgICBfY2FudmFzLmhlaWdodCA9IF9jYW52YXNTaXplLnk7XG4gICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmFtZUdyYWJiZXInLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzaXplOiBfc2l6ZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0LFxuICAgICAgICAgICAgdmlkZW9TaXplOiBfdmlkZW9TaXplLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc1NpemUsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgX3RoYXQuZ3JhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZG9IYWxmU2FtcGxlID0gX3N0cmVhbUNvbmZpZy5oYWxmU2FtcGxlO1xuICAgICAgICBjb25zdCBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG4gICAgICAgIGxldCBkcmF3YWJsZSA9IGZyYW1lO1xuICAgICAgICBsZXQgZHJhd0FuZ2xlID0gMDtcbiAgICAgICAgbGV0IGN0eERhdGE7XG4gICAgICAgIGlmIChkcmF3YWJsZSkge1xuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSk7XG4gICAgICAgICAgICBpZiAoX3N0cmVhbUNvbmZpZy50eXBlID09PSAnSW1hZ2VTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgZHJhd2FibGUgPSBmcmFtZS5pbWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKF9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKC1kcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKC1fY2FudmFzU2l6ZS54IC8gMiwgLV9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIDAsIDAsIF9jYW52YXNTaXplLngsIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHhEYXRhID0gX2N0eC5nZXRJbWFnZURhdGEoX3N4LCBfc3ksIF9zaXplLngsIF9zaXplLnkpLmRhdGE7XG4gICAgICAgICAgICBpZiAoZG9IYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjdHhEYXRhLCBfc2l6ZSwgX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlR3JheShjdHhEYXRhLCBfZGF0YSwgX3N0cmVhbUNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGF0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVHcmFiYmVyO1xuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG5pbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgaW50ZXJmYWNlIGZvciBGcmFtZUdyYWJiZXJcblxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xuICAgIGltYWdlRGF0YTogVWludDhBcnJheTtcbiAgICBidXN5OiBib29sZWFuO1xuICAgIHdvcmtlcjogV29ya2VyO1xufVxuXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdvcmtlcnMoZnJhbWVHcmFiYmVyOiBhbnkpIHtcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xuICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCkge1xuICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSB3b3JrZXJQb29sLmZpbHRlcigod29ya2VyVGhyZWFkKSA9PiAhd29ya2VyVGhyZWFkLmJ1c3kpWzBdO1xuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICAgICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChmcmFtZUdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zvcldvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XG4gICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xuICAgICAgICBpZiAoIVF1YWdnYSkge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuLy8gQHRzLWlnbm9yZVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBmdW5jdGlvbiBvblByb2Nlc3NlZChyZXN1bHQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdpbml0aWFsaXplZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4vLyBAdHMtaWdub3JlXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmNtZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyID0gbmV3IFF1YWdnYS5JbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueSxcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdyZWdpc3RlclJlYWRlcicpIHtcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gICAgdmFyIGJsb2IsXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBibG9iID0gbmV3IEJsb2IoWycoJyArIHdvcmtlckludGVyZmFjZS50b1N0cmluZygpICsgJykoJyArIGZhY3RvcnlTb3VyY2UgKyAnKTsnXSxcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcblxuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW06IGFueSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG5cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XG4gICAgICAgIHdvcmtlcixcbiAgICAgICAgaW1hZ2VEYXRhOiBuZXcgVWludDhBcnJheShpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgICAgICBidXN5OiB0cnVlLFxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHdvcmtlclRocmVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/XG4gICAgICAgICAgICAvLyBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgZXJyb3I6ICcgKyBlLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICBzaXplOiB7IHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpIH0sXG4gICAgICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcbiAgICAgICAgY29uZmlnOiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSxcbiAgICB9LCBbd29ya2VyVGhyZWFkLmltYWdlRGF0YS5idWZmZXJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFdvcmtlclBvb2woY2FwYWNpdHk6IG51bWJlciwgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtPzogYW55LCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaW5jcmVhc2VCeSA9IGNhcGFjaXR5IC0gd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDAgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9IGVsc2UgaWYgKGluY3JlYXNlQnkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IHdvcmtlclBvb2wuc2xpY2UoaW5jcmVhc2VCeSk7XG4gICAgICAgIHdvcmtlcnNUb1Rlcm1pbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciB0ZXJtaW5hdGVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlclBvb2wuc2xpY2UoMCwgaW5jcmVhc2VCeSk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmtlckluaXRpYWxpemVkID0gKHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCkgPT4ge1xuICAgICAgICAgICAgd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAod29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkgJiYgY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jcmVhc2VCeTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPikge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnMgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IGFueSkge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAncmVnaXN0ZXJSZWFkZXInLCBuYW1lLCByZWFkZXIgfSkpO1xufVxuIiwiaW1wb3J0IHsgSW5wdXRTdHJlYW1UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBJbnB1dFN0cmVhbSh0eXBlOiBJbnB1dFN0cmVhbVR5cGUgPSAnTGl2ZVN0cmVhbScsIHZpZXdwb3J0OiBFbGVtZW50IHwgbnVsbCwgSW5wdXRTdHJlYW06IGFueSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdWaWRlb1N0cmVhbSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSW1hZ2VTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtLmNyZWF0ZUltYWdlU3RyZWFtKCkgfTtcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcbiAgICAgICAgICAgIGxldCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZpZGVvOiBudWxsLCBpbnB1dFN0cmVhbTogbnVsbCB9O1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5leHBvcnQgdHlwZSBCb3ggPSBBcnJheTxbIG51bWJlciwgbnVtYmVyIF0+O1xuXG5leHBvcnQgdHlwZSBMaW5lID0gWyBQb2ludCwgUG9pbnQgXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGNvcm5lciA9IGJveC5sZW5ndGg7XG4gICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgICAgIGJveFtjb3JuZXJdWzFdICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUxpbmUobGluZTogTGluZSwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzBdLnkgKz0geU9mZnNldDtcbiAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgeyBRdWFnZ2FDb250ZXh0IH0gZnJvbSAnLi4vUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgX2luaXRCdWZmZXJzIGZyb20gJy4vaW5pdEJ1ZmZlcnMnO1xuaW1wb3J0IF9nZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4uL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBfaW5pdENhbnZhcyBmcm9tICcuL2luaXRDYW52YXMnO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcbmltcG9ydCBJbnB1dFN0cmVhbSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtJztcbmltcG9ydCBGcmFtZUdyYWJiZXIgZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyc7XG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhZ2dhIHtcbiAgICBjb250ZXh0OiBRdWFnZ2FDb250ZXh0ID0gbmV3IFF1YWdnYUNvbnRleHQoKTtcblxuICAgIGluaXRCdWZmZXJzKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH0gPSBfaW5pdEJ1ZmZlcnMoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLmxvY2F0b3IsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIgPSBCYXJjb2RlRGVjb2Rlci5jcmVhdGUodGhpcy5jb250ZXh0LmNvbmZpZy5kZWNvZGVyLCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgIH1cblxuICAgIGdldFZpZXdQb3J0KCk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgcmV0dXJuIF9nZXRWaWV3UG9ydCh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlYWR5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5wbGF5KCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgaW5pdENhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2luaXRDYW52YXModGhpcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN0eCwgZG9tIH0gPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9tLmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9tLm92ZXJsYXk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4LmltYWdlID0gY3R4LmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gY3R4Lm92ZXJsYXk7XG4gICAgfVxuXG4gICAgY2FuUmVjb3JkID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEJhcmNvZGVMb2NhdG9yLmNoZWNrSW1hZ2VDb25zdHJhaW50cyh0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0b3IpO1xuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/Lm51bU9mV29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGluaXRJbnB1dFN0cmVhbShjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHlwZTogaW5wdXRUeXBlLCBjb25zdHJhaW50cyB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgY29uc3QgeyB2aWRlbywgaW5wdXRTdHJlYW0gfSA9IHNldHVwSW5wdXRTdHJlYW0oaW5wdXRUeXBlLCB0aGlzLmdldFZpZXdQb3J0KCksIElucHV0U3RyZWFtKTtcblxuICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnTGl2ZVN0cmVhbScgJiYgdmlkZW8pIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZXF1ZXN0KHZpZGVvLCBjb25zdHJhaW50cylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBpbnB1dFN0cmVhbS50cmlnZ2VyKCdjYW5yZWNvcmQnKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRBdHRyaWJ1dGUoJ3ByZWxvYWQnLCAnYXV0bycpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbSh0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucmVjb3JkJywgdGhpcy5jYW5SZWNvcmQuYmluZCh1bmRlZmluZWQsIGNhbGxiYWNrKSk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdCb3hlcygpOiBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRlID8gQmFyY29kZUxvY2F0b3IubG9jYXRlKClcbiAgICAgICAgICAgIDogW1tcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVswXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzJdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVszXSksXG4gICAgICAgICAgICBdXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCB0eXBlIGZvciByZXN1bHQgaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQ6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gdG9wUmlnaHQueDtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHRvcFJpZ2h0Lnk7XG5cbiAgICAgICAgaWYgKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICAgICAgLy8gVE9ETzogQmFyY29kZUluZm8gbWF5IG5vdCBiZSB0aGUgcmlnaHQgdHlwZSBoZXJlLlxuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZvckVhY2goKGJhcmNvZGU6IEJhcmNvZGVJbmZvKSA9PiB0aGlzLnRyYW5zZm9ybVJlc3VsdChiYXJjb2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmxpbmUgJiYgcmVzdWx0LmxpbmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBtb3ZlTGluZShyZXN1bHQubGluZSwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveCkge1xuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94LCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYm94ZXMgJiYgcmVzdWx0LmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LmJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0sIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QsIGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xuICAgICAgICBpZiAoIWltYWdlRGF0YSB8fCAhdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IGRhdGEgc3RydWN0dXJlIGhvbGRzIGEgXCJiYXJjb2Rlc1wiIHJlc3VsdCwgaWYgYW55Li4uXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5maWx0ZXIoKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiB0aGlzLmFkZFJlc3VsdChiYXJjb2RlLCBpbWFnZURhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQoXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBoYXNDb2RlUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKHJlc3VsdCAmJiAocmVzdWx0LmJhcmNvZGVzXG4gICAgICAgICAgICA/IHJlc3VsdC5iYXJjb2Rlcy5zb21lKChiYXJjb2RlKSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXG4gICAgICAgICAgICA6IHJlc3VsdC5jb2RlUmVzdWx0KSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBwdWJsaXNoUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gbnVsbCwgaW1hZ2VEYXRhPzogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCByZXN1bHRUb1B1Ymxpc2g6IEFycmF5PFF1YWdnYUpTUmVzdWx0T2JqZWN0PiB8IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IHJlc3VsdDtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZXN1bHQocmVzdWx0LCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgcmVzdWx0VG9QdWJsaXNoID0gcmVzdWx0LmJhcmNvZGVzIHx8IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50cy5wdWJsaXNoKCdwcm9jZXNzZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb2RlUmVzdWx0KHJlc3VsdCBhcyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkpIHtcbiAgICAgICAgICAgIEV2ZW50cy5wdWJsaXNoKCdkZXRlY3RlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2NhdGVBbmREZWNvZGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRCb3VuZGluZ0JveGVzKCk7XG4gICAgICAgIGlmIChib3hlcykge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHx8IHt9O1xuICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoZGVjb2RlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tSW1hZ2UodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIGlmIChpbWFnZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChpbWFnZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgY29uc3Qgd29ya2Vyc1VwZGF0ZWQgPSBRV29ya2Vycy51cGRhdGVXb3JrZXJzKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIpO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhcnRDb250aW51b3VzVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICBsZXQgbmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAvICh0aGlzLmNvbnRleHQuY29uZmlnPy5mcmVxdWVuY3kgfHwgNjApO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cblxuICAgIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBRdWFnZ2FKU1JlYWRlckNvbmZpZyk6IHZvaWQge1xuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgVHlwZURlZnMgZnJvbSAnLi9jb21tb24vdHlwZWRlZnMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJlc3VsdENvbGxlY3RvciBmcm9tICcuL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuXG5pbXBvcnQgUXVhZ2dhIGZyb20gJy4vcXVhZ2dhL3F1YWdnYSc7XG5cbmNvbnN0IGluc3RhbmNlID0gbmV3IFF1YWdnYSgpO1xuY29uc3QgX2NvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuXG5jb25zdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoY29uZmlnLCBjYiwgaW1hZ2VXcmFwcGVyLCBxdWFnZ2FJbnN0YW5jZSA9IGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNiID0gKGVycikgPT4geyBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnID0gbWVyZ2Uoe30sIENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc5OiBwZW5kaW5nIHJlc3RydWN0dXJlIGluIElzc3VlICMxNzksIHdlIGFyZSB0ZW1wIGRpc2FibGluZyB3b3JrZXJzXG4gICAgICAgIGlmIChxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQub25VSVRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0SW5wdXRTdHJlYW0oY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhcnQoKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RvcCgpO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2NvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvbkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZEZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvblByb2Nlc3NlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25Qcm9jZXNzZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIChyZWFkZXJzKSB7XG4gICAgICAgIGlmICghcmVhZGVycykge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Euc2V0UmVhZGVycyBjYWxsZWQgd2l0aCBubyByZWFkZXJzLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfSxcbiAgICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHJlYWRlcikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIHJlYWRlciwgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3I6IGZ1bmN0aW9uIChyZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHJlc3VsdENvbGxlY3RvciAmJiB0eXBlb2YgcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX2NvbnRleHQucmVzdWx0Q29sbGVjdG9yID0gcmVzdWx0Q29sbGVjdG9yO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gX2NvbnRleHQuY2FudmFzQ29udGFpbmVyO1xuICAgIH0sXG4gICAgZGVjb2RlU2luZ2xlOiBmdW5jdGlvbiAoY29uZmlnLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBxdWFnZ2FJbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbiAgICAgICAgY29uZmlnID0gbWVyZ2Uoe1xuICAgICAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgICAgICAgICAgc3JjOiBjb25maWcuc3JjLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bU9mV29ya2VyczogKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcpID8gMCA6IDEsXG4gICAgICAgICAgICBsb2NhdG9yOiB7XG4gICAgICAgICAgICAgICAgaGFsZlNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzU6IHJlc3RydWN0dXJlIHdvcmtlciBzdXBwb3J0IHNvIHRoYXQgaXQgd2lsbCB3b3JrIHdpdGggdHlwZXNjcmlwdCB1c2luZyB3b3JrZXItbG9hZGVyXG4gICAgICAgIC8vIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvbG9hZGVycy93b3JrZXItbG9hZGVyL1xuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdvcmtlcnMgcmVxdWlyZSBXb3JrZXIgYW5kIEJsb2Igc3VwcG9ydCBwcmVzZW50bHksIHNvIGlmIG5vIEJsb2Igb3IgV29ya2VyIHRoZW4gc2V0XG4gICAgICAgIC8vIHdvcmtlcnMgdG8gMC5cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwICYmICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFdvcmtlciA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyogbm8gV29ya2VyIGFuZC9vciBCbG9iIHN1cHBvcnQgLSBmb3JjaW5nIG51bU9mV29ya2VycyB0byAwJyk7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoY29uZmlnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEV2ZW50cy5vbmNlKCdwcm9jZXNzZWQnLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH0sIG51bGwsIHF1YWdnYUluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGFkZCB0aGUgdXN1YWxseSBleHBlY3RlZCBcImRlZmF1bHRcIiBmb3IgdXNlIHdpdGggcmVxdWlyZSwgYnVpbGQgc3RlcCB3b24ndCBhbGxvdyB1cyB0b1xuICAgIC8vIHdyaXRlIHRvIG1vZHVsZS5leHBvcnRzIHNvIGRvIGl0IGhlcmUuXG4gICAgZ2V0IGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbiAgICB9LFxuICAgIEJhcmNvZGVSZWFkZXIsXG4gICAgQ2FtZXJhQWNjZXNzLFxuICAgIEltYWdlRGVidWcsXG4gICAgSW1hZ2VXcmFwcGVyLFxuICAgIFJlc3VsdENvbGxlY3Rvcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xuLy8gZXhwb3J0IEJhcmNvZGVSZWFkZXIgYW5kIG90aGVyIHV0aWxpdGllcyBmb3IgZXh0ZXJuYWwgcGx1Z2luc1xuZXhwb3J0IHtcbiAgICBCYXJjb2RlRGVjb2RlcixcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==